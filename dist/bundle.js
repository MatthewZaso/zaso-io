/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/app/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@odopod/odo-carousel/dist/odo-carousel.esm.js":
/*!********************************************************************!*\
  !*** ./node_modules/@odopod/odo-carousel/dist/odo-carousel.esm.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var tiny_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tiny-emitter */ \"./node_modules/tiny-emitter/index.js\");\n/* harmony import */ var tiny_emitter__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tiny_emitter__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _odopod_odo_device__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @odopod/odo-device */ \"./node_modules/@odopod/odo-device/dist/odo-device.esm.js\");\n/* harmony import */ var _odopod_odo_pointer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @odopod/odo-pointer */ \"./node_modules/@odopod/odo-pointer/dist/odo-pointer.esm.js\");\n/* harmony import */ var _odopod_odo_draggable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @odopod/odo-draggable */ \"./node_modules/@odopod/odo-draggable/dist/odo-draggable.esm.js\");\n/* harmony import */ var _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @odopod/odo-helpers */ \"./node_modules/@odopod/odo-helpers/dist/odo-helpers.esm.js\");\n\n\n\n\n\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar CarouselEvent = function () {\n  /**\n   * Object representing a carousel event.\n   * @param {string} type Event type.\n   * @param {Carousel} carousel The carousel instance.\n   * @param {number=} optFrom The logical index the carousel is coming from.\n   * @param {number=} optTo The logical index the carouesl is going to.\n   * @constructor\n   */\n  function CarouselEvent(type, carousel, optFrom, optTo) {\n    classCallCheck(this, CarouselEvent);\n\n    this.type = type;\n\n    /** @type {HTMLElement} */\n    this.target = carousel.element;\n\n    /** @type {number} carousel slid from this index. */\n    this.from = optFrom;\n\n    /** @type {number} carousel slid to this index. */\n    this.to = optTo;\n\n    /** @type {boolean} Whether the carousel actually changed slides. */\n    this.hasSlideChanged = optFrom !== optTo;\n\n    /** @type {boolean} Whether `preventDefault` has been called. */\n    this.defaultPrevented = false;\n  }\n\n  CarouselEvent.prototype.preventDefault = function preventDefault() {\n    this.defaultPrevented = true;\n  };\n\n  return CarouselEvent;\n}();\n\nvar settings = {\n\n  /**\n   * Event types emitted by the carousel.\n   * @enum {string}\n   */\n  EventType: {\n    WILL_NAVIGATE: 'odocarousel:willnavigate',\n    SLIDE_START: 'odocarousel:slidestart',\n    SLIDE_END: 'odocarousel:slideend'\n  },\n\n  /** @enum {string} */\n  Classes: {\n    BASE: 'odo-carousel',\n    FADE: 'odo-carousel--fade',\n    VERTICAL: 'odo-carousel--vertical',\n    WRAPPER: 'odo-carousel__wrapper',\n    CAROUSEL_ELEMENT: 'odo-carousel__element',\n\n    SLIDE: 'odo-carousel__slide',\n    ACTIVE_SLIDE: 'odo-carousel__slide--active',\n    PREVIOUS_SLIDE: 'odo-carousel__slide--previous',\n    PAST_SLIDE: 'odo-carousel__slide--past',\n    NEXT_SLIDE: 'odo-carousel__slide--next',\n    FUTURE_SLIDE: 'odo-carousel__slide--future',\n\n    VISIBLE: 'odo-carousel__slide--visible',\n    BEHIND: 'odo-carousel__slide--behind',\n\n    PAGINATION: 'odo-carousel__pagination',\n    PAGINATION_DOT: 'odo-carousel__pagination-dot',\n    PAGINATION_DOT_SELECTED: 'is-selected',\n\n    PADDLES: 'odo-carousel__nav-paddles',\n    PADDLE: 'odo-carousel__nav-paddle',\n    PADDLE_NEXT: 'odo-carousel__nav-next',\n    PADDLE_PREV: 'odo-carousel__nav-prev',\n    PADDLE_DISABLED: 'is-disabled',\n\n    SLIDE_CHILD: 'odo-carousel__slide-child'\n  },\n\n  Defaults: {\n    startIndex: 0,\n    isVertical: false,\n    isLooped: false,\n    isJumped: false,\n    isFade: false,\n    isCentered: false,\n    neighborCount: 1,\n    slideshowSpeed: 1000,\n    animationSpeed: 400,\n    crossfadeAmount: 0.875,\n    easing: 'cubic-bezier(0.250, 0.460, 0.450, 0.940)',\n    pagination: false,\n    getNavPaddleHtml: null,\n    getPaginationHtml: null,\n    template: {\n      paddles: '<nav class=\"odo-carousel__nav-paddles\">{{ prev }}{{ next }}</nav>',\n      paddleNext: '<a href=\"javascript:void(0)\" role=\"button\" aria-label=\"next slide\" class=\"odo-carousel__nav-paddle odo-carousel__nav-next\">{{ paddleInner }}</a>',\n      paddlePrev: '<a href=\"javascript:void(0)\" role=\"button\" aria-label=\"previous slide\" class=\"odo-carousel__nav-paddle odo-carousel__nav-prev\">{{ paddleInner }}</a>',\n      paddleNextInner: '<svg viewBox=\"75.4 27 461.2 738\"><path d=\"M167.7 27l368.9 369-368.9 369-92.3-92.3 276.7-276.7-276.7-276.7z\"/></svg>',\n      paddlePrevInner: '<svg viewBox=\"75.396 26.994 461.208 738.012\"><path d=\"M444.336 765.006l-368.94-369.006 368.94-369.006 92.268 92.268-276.738 276.738 276.738 276.738z\"/></svg>',\n      pagination: '<nav class=\"odo-carousel__pagination\" role=\"tablist\">{{ dots }}</nav>',\n      paginationDot: '<a href=\"javascript:void(0)\" role=\"tab\" aria-label=\"Go to slide {{ index1 }}\" aria-controls=\"{{ slideId }}\" aria-selected=\"false\" class=\"odo-carousel__pagination-dot\" data-index=\"{{ index }}\"></a>',\n      paginationDotSecondary: '<a href=\"javascript:void(0)\" role=\"tab\" aria-label=\"Go to slide {{ index1 }}\" aria-controls=\"{{ slideId }}\" aria-selected=\"false\" class=\"odo-carousel__pagination-dot\" data-index=\"{{ index }}\" data-secondary-index=\"{{ secondaryIndex }}\" aria-hidden=\"{{ hidden }}\"></a>'\n    }\n  },\n\n  TRANSITION_END_WAIT: 32\n};\n\n/**\n * A simple string replacement template with double curly braces. You can use\n * nested objects and functions too.\n *\n * @example\n * // \"Today is Thursday\"\n * template(\"Today is {{ day }}\", {\n *   day: 'Thursday',\n * });\n *\n * // \"Today is Friday\"\n * template(\"Today is {{ month.day }}\", {\n *   month: {\n *     day: 'Friday',\n *   },\n * });\n *\n * // \"Today is Saturday\"\n * template(\"Today is {{ day }}\", {\n *   today: 'Saturday',\n *   day() {\n *     return this.today;\n *   },\n * });\n *\n * @param {string} str Template.\n * @param {object} data Data object with keys which match your template.\n * @return {string}\n */\nfunction template(str, data) {\n  // A modified version of Malsup's template method for Cycle.\n  // https://github.com/malsup/cycle2/blob/master/src/jquery.cycle2.tmpl.js\n\n  // Regex which matches {{cool}} or {{ cool }} where `cool` is what should\n  // be replaced.\n  return str.replace(/{{\\s?((.)?.*?)\\s?}}/g, function (match, str) {\n    var names = str.split('.');\n    var obj = data;\n    var property = void 0;\n\n    // If the name has dots in it, \"person.name\", loop through each one.\n    if (names.length > 1) {\n      property = obj;\n      for (var i = 0; i < names.length; i++) {\n        obj = property;\n        property = property[names[i]] || str;\n      }\n\n      // Otherwise, it's a simple assignment from the data object.\n    } else {\n      property = obj[str];\n    }\n\n    // If they passed a function, use that.\n    if (typeof property === 'function') {\n      return property.call(obj);\n    }\n\n    // Return the string if it exists.\n    if (property !== undefined && property !== null && property !== str) {\n      return property;\n    }\n\n    // Otherwise, return the original string.\n    return str;\n  });\n}\n\n/**\n * Parse the transform matrix into x and y translation values.\n * @param {string} str Transform matrix, or \"none\".\n * @return {{ x: number, y: number}}\n */\nfunction getTranslate(str) {\n  // If no transform is set, the computed transform will be \"none\".\n  if (str === 'none') {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  var array = str.match(/(-?[\\d.]+)/g);\n  return {\n    x: parseFloat(array[4]),\n    y: parseFloat(array[5])\n  };\n}\n\nvar count = 0;\nfunction uniqueId() {\n  count += 1;\n  return 'odo-carousel' + count;\n}\n\n/**\n * Find every element within the parent which is focusable via tabbing and\n * enable/disable it. Ideally, some property could be set on the parent\n * element itself to prevent tabbing into it. visibility:hidden accomplishes\n * this, but there can be slides in view which are not the current slide.\n * @param {Element} parent Ancestor element to disable tabbing into.\n * @param {boolean} canFocus Whether to enable or disable focusability.\n */\nfunction toggleFocusability(parent, canFocus) {\n  var focusableElements = 'a[href],button,details,iframe,input,textarea,select,*[tabindex]';\n  var elements = Array.from(parent.querySelectorAll(focusableElements));\n\n  // Test the parent element itself. Odo Helpers polyfills `matches`.\n  if (parent.matches(focusableElements)) {\n    elements.push(parent);\n  }\n\n  for (var i = elements.length - 1; i >= 0; i--) {\n    if (canFocus) {\n      // Prefer resetting the tabIndex property by using removeAttribute to lets\n      // the browser decide if it should go back to 0 (like if it was a button)\n      // or to -1 if it wasn't originally focusable.\n      elements[i].removeAttribute('tabindex');\n    } else {\n      elements[i].tabIndex = -1;\n    }\n  }\n}\n\n/**\n * @fileoverview A UI Component for creating versatile carousels. They are\n * peformant, draggable, and can ininitely loop.\n *\n * @author Glen Cheney <glen@odopod.com>\n */\n\nvar Carousel = function (_TinyEmitter) {\n  inherits(Carousel, _TinyEmitter);\n\n  /**\n   * @param {HTMLElement} element The outermost carousel element.\n   * @param {Object} [options] An options object.\n   * @constructor\n   * @throws {TypeError} if element isn't an element.\n   */\n  function Carousel(element) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    classCallCheck(this, Carousel);\n\n    var _this = possibleConstructorReturn(this, _TinyEmitter.call(this));\n\n    if (!(element instanceof HTMLElement)) {\n      throw new TypeError('OdoCarousel requires an element. Got: \"' + element + '\"');\n    }\n\n    _this.element = element;\n\n    /**\n     * Deep copy from the defaults and override defaults with options passed in.\n     * @public\n     */\n    _this.options = Carousel.getOptions(options);\n\n    /**\n     * Whether the carousel is vertical or horizontal.\n     * @type {boolean}\n     * @protected\n     */\n    _this.isVertical = _this.options.isVertical;\n\n    /**\n     * Whether this is a looped carousel which is not a fading carousel.\n     * @type {boolean}\n     */\n    _this._isSlidingLooped = _this.options.isLooped && !_this.options.isFade;\n\n    /**\n     * The DOM index of the current slide element within the slides' parent.\n     * @type {number}\n     * @protected\n     */\n    _this.domIndex = 0;\n\n    /**\n     * The previous domIndex value.\n     * @type {number}\n     * @protected\n     */\n    _this.lastDomIndex = 0;\n\n    /**\n     * Current logical index.\n     * @type {number}\n     */\n    _this._selectedIndex = 0;\n\n    /**\n     * The slide container's parent.\n     * @type {HTMLElement}\n     * @private\n     */\n    _this._slideContainerParentEl = null;\n\n    /**\n     * The container for the slides and the element which is moved around with\n     * transforms or absolute positioning.\n     * @type {HTMLElement}\n     * @private\n     */\n    _this._carouselEl = null;\n\n    /**\n     * An array of slides (elements) in the carousel.\n     * @type {Array.<!HTMLElement>}\n     * @private\n     */\n    _this._slides = [];\n\n    /**\n     * Whether the carousel is currently skipping slides. For example, going from\n     * slide 1 to 3, a jumping carousel repositions the slides so that 3 is next\n     * to 1 and only has to animate one slide length to get to it. This flag\n     * indicates a slide has been repositioned.\n     * @type {boolean}\n     * @private\n     */\n    _this._isJumped = false;\n\n    /**\n     * Whether the carousel is able to be used. This can be changed with the\n     * `setEnabled` method.\n     * @type {boolean}\n     * @private\n     */\n    _this._isEnabled = true;\n\n    /**\n     * Top or left.\n     * @type {string}\n     * @private\n     */\n    _this._posAttr = _this.isVertical ? 'top' : 'left';\n\n    /**\n     * offsetTop or offsetLeft.\n     * @type {string}\n     * @private\n     */\n    _this._offsetPosition = 'offset' + Object(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_4__[\"capitalize\"])(_this._posAttr);\n\n    /**\n     * Height or width.\n     * @type {string}\n     * @private\n     */\n    _this._dimensionAttr = _this.isVertical ? 'height' : 'width';\n\n    /**\n     * Value used in `translate{X|Y}()`.\n     * @type {string}\n     */\n    _this._translateAxis = _this.isVertical ? 'Y' : 'X';\n\n    /**\n     * A flag indicating that the carousel is animating. It also will have\n     * a transition end event lister bound to it if the browser can\n     * transition transforms.\n     * @type {boolean}\n     * @protected\n     */\n    _this.isTransitioning = false;\n\n    /**\n     * The id returned from onTransitionEnd which is used to cancel\n     * the transitionend listener.\n     * @type {number}\n     */\n    _this._transitionId = null;\n\n    /**\n     * If a selector is specified, gotoSlide will look for this on the last\n     * slide and not reveal unneccesary whitespace to the right of the last\n     * matched element.\n     * @type {boolean}\n     * @private\n     */\n    _this._hasSlideChildren = false;\n\n    /**\n     * Default to true for being able to drag the carousel between slides.\n     * @type {boolean}\n     * @private\n     */\n    _this._isDraggable = true;\n\n    /**\n     * Flag indicating dragging has happened. It is set on dragmove and reset\n     * after the draggableend event has been dispatched.\n     * @type {boolean}\n     */\n    _this.hasDragged = false;\n\n    /**\n     * Whether the carousel is at a resting position or between slides.\n     * @type {boolean}\n     */\n    _this._isOffset = false;\n\n    /**\n     * A Timer used to make the carousel an autoplaying slideshow.\n     * @type {Timer}\n     * @private\n     */\n    _this._timer = null;\n\n    /**\n     * Time, in milliseconds, to wait before adding zero opacity to the slide,\n     * which triggers the css transition. timeout = speed - (speed * %).\n     * @type {number}\n     * @private\n     */\n    _this._crossfadeTimeout = _this.options.animationSpeed - _this.options.animationSpeed * _this.options.crossfadeAmount;\n\n    /**\n     * When carousel slides are centered, they won't be aligned with the starting\n     * edge of the carousel wrapper. The starting edge (relative zero) is used\n     * to determine which slide is closest to the current position.\n     * @type {number}\n     */\n    _this._startEdge = 0;\n\n    /**\n     * Draggable attached to the carousel element. Used for non-fade carousels.\n     * @type {OdoDraggable}\n     */\n    _this.draggable = null;\n\n    /**\n     * Pointer attached to the main element. Used for fading carousels.\n     * @type {OdoPointer}\n     */\n    _this.pointer = null;\n\n    /**\n     * Carousels containing only two slides with looping functionality are special\n     * cases. Slides need to be duplicated and pagination needs to be rendered\n     * differently. This is because in order for the user to navigate in either\n     * direction from the active slide, the second slide would need to be present in\n     * both the 'previous' and 'next' positions. 'Bidirectional' will refer to\n     * carousels with content that unnaturally exists for the sake of navigational\n     * purposes.\n     * @type {boolean}\n     */\n    _this._isBidirectional = false;\n\n    // Deprecated method.\n    _this.resetSync = _this.reset;\n\n    // Go.\n    _this.decorate();\n    return _this;\n  }\n\n  /**\n   * Finds an element within this class' main element based on a class name.\n   * @param {string} className Class name to search for.\n   * @param {HTMLElement} [context] Optionally provide the context (scope)\n   *     for the query. Default is the main element of the class.\n   * @return {HTMLElement[]} An array which may or may not contain the element\n   *     which was searched for.\n   */\n\n\n  Carousel.prototype.getElementsByClass = function getElementsByClass(className) {\n    var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.element;\n\n    return Array.from(context.getElementsByClassName(className));\n  };\n\n  /**\n   * Retrieve an element by its class name.\n   * @param {string} className Class name to search for.\n   * @param {HTMLElement} [context] Optinal scope for search.\n   * @return {HTMLElement|null} The element or null if it isn't found.\n   */\n\n\n  Carousel.prototype.getElementByClass = function getElementByClass(className, context) {\n    return this.getElementsByClass(className, context)[0] || null;\n  };\n\n  /**\n   * Modify the DOM to be a carousel.\n   */\n\n\n  Carousel.prototype.decorate = function decorate() {\n    this._saveDomElements();\n\n    // After we determine the number of slides, we have enough information to decide if\n    // this carousel will be a special bidirectional one.\n    if (this.options.isLooped && this._slides.length === 2) {\n      this._decorateBidirectionalCarousel();\n    }\n\n    this._setA11yAttributes();\n    this._renderPaddles();\n\n    if (this.options.pagination) {\n      this._renderPagination();\n    }\n\n    this._saveRenderedElements();\n\n    this._setSlideIndices();\n\n    if (this.options.isFade) {\n      this._decorateFadeCarousel();\n    } else {\n      this._decorateRegularCarousel();\n    }\n\n    this._onClick = this._handleClick.bind(this);\n    this.element.addEventListener('click', this._onClick);\n\n    // Set the selected index without animation.\n    this.setSelectedIndex(this._getSafeIndex(this.options.startIndex), true);\n\n    // Changes viewport, so it needs to come after the goto zero.\n    if (this._isSlidingLooped) {\n      this._setNeighborSlides();\n      this._snapToCurrentSlide();\n    }\n  };\n\n  /**\n   * Sliding (regular) carousels needs a few more styles and events.\n   * @private\n   */\n\n\n  Carousel.prototype._decorateRegularCarousel = function _decorateRegularCarousel() {\n    // Add easing to container\n    this._carouselEl.style[_odopod_odo_device__WEBPACK_IMPORTED_MODULE_1__[\"default\"].Dom.TRANSITION_PROPERTY] = _odopod_odo_device__WEBPACK_IMPORTED_MODULE_1__[\"default\"].Css.TRANSFORM;\n    this._carouselEl.style[_odopod_odo_device__WEBPACK_IMPORTED_MODULE_1__[\"default\"].Dom.TRANSITION_TIMING_FUNCTION] = this.options.easing;\n\n    this._hasSlideChildren = this._getSlideChildren().length > 0;\n\n    this.bindDragEvents();\n  };\n\n  /**\n   * Sliding (regular) carousels needs a few more styles and events.\n   * @private\n   */\n\n\n  Carousel.prototype._decorateFadeCarousel = function _decorateFadeCarousel() {\n    var _this2 = this;\n\n    this._isDraggable = false;\n\n    // Add transitions to each slide.\n    this.getSlides().forEach(function (slide, i) {\n      slide.style[_odopod_odo_device__WEBPACK_IMPORTED_MODULE_1__[\"default\"].Dom.TRANSITION] = 'opacity ' + _this2.options.animationSpeed + 'ms linear';\n\n      // The first slide needs to have the visible class.\n      if (i === 0) {\n        slide.classList.add(Carousel.Classes.VISIBLE);\n      }\n    });\n\n    this.bindSwipeEvents();\n  };\n\n  /**\n   * Sets up the additional DOM modifications that will be needed for bidirectional\n   * carousels. We will essentially be duplicating both carousel slides so that no\n   * matter the current index, the active slide will alway have neighbors on either side.\n   * Then later on, we hide the additional pagination.\n   * @private\n   */\n\n\n  Carousel.prototype._decorateBidirectionalCarousel = function _decorateBidirectionalCarousel() {\n    var _this3 = this;\n\n    // Bidirectional carousels automatically will need to become a jumped carousels,\n    // since we will be adding artificial slides that ruin natural navigation.\n    this._isBidirectional = true;\n    this._isJumped = true;\n\n    // Turn 2 slides into 4.\n    this._slides.forEach(function (slide) {\n      _this3.getCarouselElement().appendChild(slide.cloneNode(true));\n    });\n\n    // Update the global slides variable to include the new elements.\n    this._slides = this.getElementsByClass(Carousel.Classes.SLIDE);\n  };\n\n  /**\n   * Set static accessibility attributes.\n   */\n\n\n  Carousel.prototype._setA11yAttributes = function _setA11yAttributes() {\n    this.getWrapper().setAttribute('aria-live', 'polite');\n    this.getCarouselElement().setAttribute('role', 'list');\n    this.getSlides().forEach(function (slide) {\n      Object(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_4__[\"giveId\"])(slide, uniqueId);\n      slide.setAttribute('role', 'listitem');\n    });\n  };\n\n  /**\n   * Remove static accessibility attributes.\n   */\n\n\n  Carousel.prototype._removeA11yAttributes = function _removeA11yAttributes() {\n    this.getWrapper().removeAttribute('aria-live');\n    this.getCarouselElement().removeAttribute('role');\n    this.getSlides().forEach(function (slide) {\n      slide.removeAttribute('role');\n    });\n  };\n\n  /**\n   * Store references to commonly used DOM elements.\n   * @private\n   */\n\n\n  Carousel.prototype._saveDomElements = function _saveDomElements() {\n    // Element which wraps the element which contains all the slides.\n    this._slideContainerParentEl = this.getElementByClass(Carousel.Classes.WRAPPER);\n\n    // Element which contains all the slides.\n    this._carouselEl = this.getElementByClass(Carousel.Classes.CAROUSEL_ELEMENT);\n\n    // Because carousels can have carousels inside them, finding elements by\n    // class retrieves too many elements.\n    this._slides = this.getElementsByClass(Carousel.Classes.SLIDE);\n  };\n\n  /**\n   * Store references to generated elements. The pagination dots cannot be save in\n   * `_saveDomElements` because the number of slides is not yet known.\n   * @private\n   */\n\n\n  Carousel.prototype._saveRenderedElements = function _saveRenderedElements() {\n    this._paddlePrevious = this.getElementByClass(Carousel.Classes.PADDLE_PREV);\n    this._paddleNext = this.getElementByClass(Carousel.Classes.PADDLE_NEXT);\n    this._paginationDots = this.getElementsByClass(Carousel.Classes.PAGINATION_DOT).map(function (dot) {\n      return {\n        dot: dot,\n        i: parseInt(dot.getAttribute('data-index'), 10),\n        i2: parseInt(dot.getAttribute('data-secondary-index'), 10)\n      };\n    });\n  };\n\n  /**\n   * Add navigation paddles (previous and next buttons) to the carousel.\n   * @private\n   */\n\n\n  Carousel.prototype._renderPaddles = function _renderPaddles() {\n    this.element.insertAdjacentHTML('beforeend', this._getNavPaddleHtml());\n  };\n\n  /**\n   * Remove navigation paddles from the carousel (if they exist).\n   * @private\n   */\n\n\n  Carousel.prototype._removePaddles = function _removePaddles() {\n    this._removeByClass(Carousel.Classes.PADDLES);\n  };\n\n  /**\n   * Remove a child element by class, if it exists.\n   * @param {string} className Class name of the element to find and remove.\n   */\n\n\n  Carousel.prototype._removeByClass = function _removeByClass(className) {\n    var element = this.getElementByClass(className);\n    if (element) {\n      element.parentNode.removeChild(element);\n    }\n  };\n\n  /**\n   * Retrieves the html string for the nav paddles from the templates.\n   * @return {string} A string of html.\n   * @private\n   */\n\n\n  Carousel.prototype._getNavPaddleHtml = function _getNavPaddleHtml() {\n    if (typeof this.options.getNavPaddleHtml === 'function') {\n      return this.options.getNavPaddleHtml.call(this, this);\n    }\n\n    return Carousel.template(this.options.template.paddles, {\n      prev: Carousel.template(this.options.template.paddlePrev, {\n        paddleInner: this.options.template.paddlePrevInner\n      }),\n      next: Carousel.template(this.options.template.paddleNext, {\n        paddleInner: this.options.template.paddleNextInner\n      })\n    });\n  };\n\n  /**\n   * Add pagination (the dots) to the carousel.\n   * @private\n   */\n\n\n  Carousel.prototype._renderPagination = function _renderPagination() {\n    this.element.insertAdjacentHTML('beforeend', this._getPaginationHtml());\n  };\n\n  /**\n   * Remove pagination from the carousel (if they exist).\n   * @private\n   */\n\n\n  Carousel.prototype._removePagination = function _removePagination() {\n    this._removeByClass(Carousel.Classes.PAGINATION);\n  };\n\n  /**\n   * Retrieves the html string for the pagination from the templates.\n   * @return {string} A string of html.\n   * @private\n   */\n\n\n  Carousel.prototype._getPaginationHtml = function _getPaginationHtml() {\n    if (typeof this.options.getPaginationHtml === 'function') {\n      return this.options.getPaginationHtml.call(this, this);\n    }\n\n    var dots = this._buildPaginationHtml();\n\n    return Carousel.template(this.options.template.pagination, {\n      dots: dots\n    });\n  };\n\n  /**\n   * Builds and returns the HTML string of the pagination dots.\n   * Bidirectional carousels utilize a separate template that includes\n   * secondary indices.\n   * @return {string}\n   * @private\n   */\n\n\n  Carousel.prototype._buildPaginationHtml = function _buildPaginationHtml() {\n    var _this4 = this;\n\n    var template$$1 = this._isBidirectional ? this.options.template.paginationDotSecondary : this.options.template.paginationDot;\n\n    return this.getSlides().reduce(function (dotsHtml, slide, i, arr) {\n      var data = {\n        index: i,\n        index1: i + 1,\n        slideId: slide.id\n      };\n\n      if (_this4._isBidirectional) {\n        // If you are rendering pagination for a bidirectional carousel, you will need\n        // secondary indices computed. This returns the secondary index based on the primary.\n        // i.e. For 4 slides, 1 returns 3, 2 returns 4 and the inverse.\n        data.secondaryIndex = i > 1 ? i % 2 : i + 2;\n        data.hidden = i >= arr.length / 2;\n      }\n\n      return dotsHtml + Carousel.template(template$$1, data);\n    }, '');\n  };\n\n  /**\n   * Listen for dragging events.\n   * @protected\n   */\n\n\n  Carousel.prototype.bindDragEvents = function bindDragEvents() {\n    this.draggable = new _odopod_odo_draggable__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this._carouselEl, {\n      axis: this.isVertical ? _odopod_odo_pointer__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Axis.Y : _odopod_odo_pointer__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Axis.X\n    });\n\n    this._onDragStart = this._handleDragStart.bind(this);\n    this._onDragMove = this._handleDragMove.bind(this);\n    this._onDragEnd = this._handleDragEnd.bind(this);\n\n    this.draggable.on(_odopod_odo_draggable__WEBPACK_IMPORTED_MODULE_3__[\"default\"].EventType.START, this._onDragStart);\n    this.draggable.on(_odopod_odo_draggable__WEBPACK_IMPORTED_MODULE_3__[\"default\"].EventType.MOVE, this._onDragMove);\n    this.draggable.on(_odopod_odo_draggable__WEBPACK_IMPORTED_MODULE_3__[\"default\"].EventType.END, this._onDragEnd);\n  };\n\n  /**\n   * Listen for the pointer to come up from the screen, then execute a callback.\n   * @protected\n   */\n\n\n  Carousel.prototype.bindSwipeEvents = function bindSwipeEvents() {\n    this.pointer = new _odopod_odo_pointer__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this._carouselEl, {\n      axis: _odopod_odo_pointer__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Axis.X,\n      preventEventDefault: true\n    });\n\n    this._onPointerEnd = this._handlePointerEnd.bind(this);\n    this.pointer.on(_odopod_odo_pointer__WEBPACK_IMPORTED_MODULE_2__[\"default\"].EventType.END, this._onPointerEnd);\n  };\n\n  /**\n   * Add a slide to the end of the carousel.\n   * @param {string} slideHtml Html string for the slide.\n   */\n\n\n  Carousel.prototype.addSlide = function addSlide(slideHtml) {\n    // Make sure looped carousels are in the right order without any neighbors.\n    this._setSlidesToLogicalOrder();\n\n    // Insert new slide at the end.\n    this._carouselEl.insertAdjacentHTML('beforeend', slideHtml);\n\n    this.reset();\n  };\n\n  /**\n   * Synchronously reset the slides. Use this when you're sure the elements\n   * within the carousel are done changing.\n   */\n\n\n  Carousel.prototype.reset = function reset() {\n    // Update the slides.\n    this._saveDomElements();\n\n    // Remove old paddles + pagination.\n    this._removePaddles();\n    this._removePagination();\n\n    this._setA11yAttributes();\n\n    // Re-render paddles and pagination.\n    this._renderPaddles();\n    if (this.options.pagination) {\n      this._renderPagination();\n    }\n\n    this._saveRenderedElements();\n\n    // Update slide indices now that there's a new slide.\n    this._setSlideIndices();\n\n    // Go to the slide it was at before.\n    var selected = this.getSelectedIndex();\n    this.setSelectedIndex(0, true);\n\n    // Try going back to the previous one.\n    this.setSelectedIndex(selected, true);\n\n    // Set neighbors slides for looped carousels.\n    if (this._isSlidingLooped) {\n      this._setNeighborSlides();\n      this._snapToCurrentSlide();\n    }\n  };\n\n  /**\n   * Retreives the cached carousel wrapper element.\n   * @return {HTMLElement}\n   */\n\n\n  Carousel.prototype.getWrapper = function getWrapper() {\n    return this._slideContainerParentEl;\n  };\n\n  /**\n   * Retreives the cached carousel element.\n   * @return {HTMLElement}\n   */\n\n\n  Carousel.prototype.getCarouselElement = function getCarouselElement() {\n    return this._carouselEl;\n  };\n\n  /**\n   * Returns the array of slides in the carousel.\n   * @return {!Array.<!HTMLElement>} The slides array.\n   */\n\n\n  Carousel.prototype.getSlides = function getSlides() {\n    return this._slides;\n  };\n\n  /**\n   * Get the slide element at the given index.\n   * @param {number} index The logical index of the slide you want.\n   * @return {HTMLElement} The slide element.\n   */\n\n\n  Carousel.prototype.getSlide = function getSlide(index) {\n    return this.getSlides()[index];\n  };\n\n  /**\n   * Get the index of the currently active slide.\n   * @return {number} Index of the current slide.\n   */\n\n\n  Carousel.prototype.getSelectedIndex = function getSelectedIndex() {\n    return this._selectedIndex;\n  };\n\n  /**\n   * Translates the original index to the current DOM index.\n   * @param {number} logicalIndex The original index of the slide to get.\n   * @return {number} Index of the slide (zero based).\n   * @private\n   */\n\n\n  Carousel.prototype._getDomIndex = function _getDomIndex(logicalIndex) {\n    return this.getSlideIndices().indexOf(logicalIndex);\n  };\n\n  /**\n   * Translates the DOM index to the original logical index.\n   * @param {number} domIndex The original index of the slide to get.\n   * @return {number} Index of the slide (zero based).\n   * @private\n   */\n\n\n  Carousel.prototype._getLogicalIndex = function _getLogicalIndex(domIndex) {\n    return this.getSlideIndices()[domIndex];\n  };\n\n  /**\n   * Takes a logical index which could potentially be out of range and returns\n   * the logical index within range.\n   * @param {number} logicalIndex Logical index to make safe.\n   * @return {number} Safe logical index.\n   * @private\n   */\n\n\n  Carousel.prototype._getSafeIndex = function _getSafeIndex(logicalIndex) {\n    if (this.isIndexOutOfRange(logicalIndex)) {\n      if (this.options.isLooped) {\n        return this._getRelativeIndex(logicalIndex, 0);\n      }\n      return this.clampIndexToSlides(logicalIndex);\n    }\n    return logicalIndex;\n  };\n\n  /**\n   * Calculates the offset index for a circular list.\n   * @param {number} index Starting index.\n   * @param {number} displacement Offset from the starting index. Can be negative\n   *     or positive. For example, -2 or 2.\n   * @return {number} The index of the relative displacement, wrapping around\n   *     the end of the list to the start when the displacement is larger than\n   *     what's left in the list.\n   */\n\n\n  Carousel.prototype._getRelativeIndex = function _getRelativeIndex(index, displacement) {\n    return Object(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_4__[\"wrapAroundList\"])(index, displacement, this._slides.length);\n  };\n\n  /**\n   * @param {number} index Index to test.\n   * @return {boolean} Whether a given index is out of range of the carousel.\n   */\n\n\n  Carousel.prototype.isIndexOutOfRange = function isIndexOutOfRange(index) {\n    return index <= -1 || index >= this._slides.length;\n  };\n\n  /**\n   * Constrain an index within bounds.\n   * @param {number} index Index to clamp.\n   * @return {number}\n   */\n\n\n  Carousel.prototype.clampIndexToSlides = function clampIndexToSlides(index) {\n    return Object(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_4__[\"clamp\"])(index, 0, this._slides.length - 1);\n  };\n\n  /**\n   * @return {boolean} Whether the carousel is currently on the first slide.\n   */\n\n\n  Carousel.prototype.isFirstSlide = function isFirstSlide() {\n    return this.getSelectedIndex() === 0;\n  };\n\n  /**\n   * @return {boolean} Whether the carousel is currently on the last slide.\n   */\n\n\n  Carousel.prototype.isLastSlide = function isLastSlide() {\n    return this.getSelectedIndex() === this._slides.length - 1;\n  };\n\n  /**\n   * Generates the array which will follow the DOM order of the slides in their\n   * container and saves it.\n   * @private\n   */\n\n\n  Carousel.prototype._setSlideIndices = function _setSlideIndices() {\n    this._slideIndices = new Array(this._slides.length);\n\n    for (var i = 0, len = this._slides.length; i < len; i++) {\n      this._slideIndices[i] = i;\n    }\n  };\n\n  /** @return {!Array.<!number>} The slide indices array. */\n\n\n  Carousel.prototype.getSlideIndices = function getSlideIndices() {\n    return this._slideIndices;\n  };\n\n  /**\n   * Retrieves the slide children.\n   * @param {HTMLElement} [optSlide] Slide to look within.\n   * @return {HTMLElement[]} NodeList of slide children.\n   * @private\n   */\n\n\n  Carousel.prototype._getSlideChildren = function _getSlideChildren(optSlide) {\n    return this.getElementsByClass(Carousel.Classes.SLIDE_CHILD, optSlide);\n  };\n\n  /**\n   * Modifieds the _slideIndices array to represent the DOM order of the slides\n   * within their container.\n   * @param {number} currentValue The value to be moved. This is the same as the\n   *     logical index.\n   * @param {number} toIndex The location to move it to in the array. It will be\n   *     clamped between zero and one less than the length of the array. This is\n   *     also referred to as the DOM index.\n   * @private\n   */\n\n\n  Carousel.prototype._moveIndex = function _moveIndex(currentValue, toIndex) {\n    var clampedIndex = this.clampIndexToSlides(toIndex);\n    var fromIndex = this._getDomIndex(currentValue);\n    var arr = this._slideIndices;\n\n    // Array moveIndex.\n    arr.splice(clampedIndex, 0, arr.splice(fromIndex, 1)[0]);\n  };\n\n  /**\n   * Swaps positions of two logical indices in the slide indices array.\n   * @param {number} logIndex1 First logical index which will be swappeed.\n   * @param {number} logIndex2 Second logical index to be swapped.\n   * @private\n   */\n\n\n  Carousel.prototype._swapIndexes = function _swapIndexes(logIndex1, logIndex2) {\n    var domIndexOfLogicalIndex1 = this._getDomIndex(logIndex1);\n    this._slideIndices[domIndexOfLogicalIndex1] = -1;\n    this._slideIndices[this._getDomIndex(logIndex2)] = logIndex1;\n    this._slideIndices[domIndexOfLogicalIndex1] = logIndex2;\n  };\n\n  /**\n   * Gets the slide positions (offsets from the left|top) array.\n   * @param {HTMLElement[]} slideSet the slides array.\n   * @return {Array.<number>} array of slide positions.\n   * @private\n   */\n\n\n  Carousel.prototype._getPositions = function _getPositions(slideSet) {\n    var _this5 = this;\n\n    var bounds = this.getWrapper().getBoundingClientRect()[this._posAttr];\n    return slideSet.map(function (el) {\n      return el.getBoundingClientRect()[_this5._posAttr] - bounds;\n    });\n  };\n\n  /**\n   * Enable or disable dragging.\n   * @param {boolean} enabled Whether it should be draggable.\n   * @private\n   */\n\n\n  Carousel.prototype._setDraggableEnabled = function _setDraggableEnabled(enabled) {\n    if (this.draggable) {\n      this.draggable.isEnabled = enabled;\n    } else {\n      this.pointer.isEnabled = enabled;\n    }\n  };\n\n  /**\n   * Enable or disable dragging of the carousel.\n   * @param {boolean} isDraggable Whether it should be draggable.\n   */\n\n\n  Carousel.prototype.setDraggable = function setDraggable(isDraggable) {\n    this._isDraggable = isDraggable;\n    this._setDraggableEnabled(isDraggable);\n  };\n\n  /**\n   * Public method which returns the enabled state.\n   * @return {boolean}\n   */\n\n\n  /**\n   * Gets the adjusted position.\n   * @param {HTMLElement} destinationSlide The slide the carousel is headed to.\n   * @return {number} The position it is.\n   * @private\n   */\n  Carousel.prototype._getNewPosition = function _getNewPosition(destinationSlide) {\n    // Destination position.\n    var destinationPosition = destinationSlide[this._offsetPosition];\n\n    // Width or height of the carousel element.\n    var carouselSize = Object(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_4__[\"getSize\"])(this.getCarouselElement())[this._dimensionAttr];\n\n    if (this.options.isCentered) {\n      var destinationSize = Object(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_4__[\"getSize\"])(destinationSlide)[this._dimensionAttr];\n      var wrapperSize = Object(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_4__[\"getSize\"])(this.getWrapper())[this._dimensionAttr];\n      this._startEdge = (wrapperSize - destinationSize) / 2;\n      destinationPosition -= this._startEdge;\n    }\n\n    var position = destinationPosition / carouselSize;\n\n    if (this._hasSlideChildren && this.isLastSlide()) {\n      // Adjust the position again if there are slide children in the last slide.\n      position = this._getPositionForSlideChildren(destinationSlide, destinationPosition, carouselSize);\n    }\n\n    return position;\n  };\n\n  /**\n   * Adjust the destination position again if there are slide children.\n   * @param {HTMLElement} destinationSlide Slide element.\n   * @param {number} destinationPosition Where the slide would initially go.\n   * @param {number} carouselSize Width or height of the carousel element.\n   * @return {number} New destination position.\n   * @private\n   */\n\n\n  Carousel.prototype._getPositionForSlideChildren = function _getPositionForSlideChildren(destinationSlide, destinationPosition, carouselSize) {\n    // Size of the combined width/height + margins of the slide children\n    // within the destination slide.\n    var childrenSum = Object(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_4__[\"getElementsSize\"])(this._getSlideChildren(destinationSlide), this._dimensionAttr);\n\n    // width|height of the carousel slide.\n    var slideSize = Object(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_4__[\"getSize\"])(destinationSlide)[this._dimensionAttr];\n\n    // The destination position minus the empty space in the next slide in px.\n    var newPosition = destinationPosition - (slideSize - childrenSum);\n\n    // Calculate the percentage from the pixel value.\n    return newPosition / carouselSize;\n  };\n\n  /**\n   * Returns the translated position based on carousel direction.\n   * @param {string} pos The position (eg \"25%\").\n   * @return {string} the css value for transform.\n   * @private\n   */\n\n\n  Carousel.prototype._getCssPosition = function _getCssPosition(pos) {\n    return 'translate' + this._translateAxis + '(' + pos + ')';\n  };\n\n  /** @private */\n\n\n  Carousel.prototype._setSlidesToLogicalOrder = function _setSlidesToLogicalOrder() {\n    var frag = document.createDocumentFragment();\n\n    this._slides.forEach(frag.appendChild, frag);\n\n    this._carouselEl.appendChild(frag);\n\n    // Reset the slide indices array.\n    this._setSlideIndices();\n  };\n\n  /**\n   * If this is a jumped carousel, prepare the slides for the jump by swapping\n   * elements out and setting the `isJumped` option.\n   * @param {number} toDomIndex Index of the slide the carousel is jumping to.\n   * @return {number} If this function changed the order the slides, it returns\n   *     the new DOM index the carousel is going to. Otherwise it returns the\n   *     DOM index parameter it was given.\n   * @private\n   */\n\n\n  Carousel.prototype._setNeighborSlidesForJump = function _setNeighborSlidesForJump(toDomIndex) {\n    var toLogicalIndex = this._getLogicalIndex(toDomIndex);\n    var currentLogicalIndex = this._getLogicalIndex(this.domIndex);\n\n    this._isJumped = true;\n\n    // Where to move the slide to. Next to the current index.\n    var destinationDomIndex = toLogicalIndex > currentLogicalIndex ? this.domIndex + 1 : this.domIndex - 1;\n\n    // Swap indices.\n    // Swap destination slide with current slide at the destination.\n    this._swapSlides(toLogicalIndex, this._getLogicalIndex(destinationDomIndex));\n\n    // Return the dom index the carousel is actually going to.\n    return destinationDomIndex;\n  };\n\n  /**\n   * Swap indices and DOM elements.\n   * @param {number} index1 Logical index 1.\n   * @param {number} index2 Logical index 2.\n   * @private\n   */\n\n\n  Carousel.prototype._swapSlides = function _swapSlides(index1, index2) {\n    this._swapIndexes(index1, index2);\n    Object(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_4__[\"swapElements\"])(this.getSlide(index1), this.getSlide(index2));\n  };\n\n  /**\n   * This function initializes the slideshow functionality for the\n   * carousel. It sets an interval for the slideshow to continue animate\n   * based on the option slideshowSpeed.\n   */\n\n\n  Carousel.prototype.startSlideshow = function startSlideshow() {\n    // Create the timer if it doesn't already exist.\n    if (!this._timer) {\n      this._timer = new _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_4__[\"Timer\"](this._slideshowTimerExpired.bind(this), this.options.slideshowSpeed, true);\n    }\n\n    this._timer.start();\n  };\n\n  /**\n   * A simple method which pauses the _timer\n   * once thats paused the slideshow will stop ticking.\n   * Can be re-initialzed by running `startSlideshow()`\n   */\n\n\n  Carousel.prototype.pauseSlideshow = function pauseSlideshow() {\n    if (this._isSlideshowPlaying()) {\n      this._timer.stop();\n    }\n  };\n\n  /**\n   * Whether the slideshow timer exists and is currently ticking.\n   * @return {boolean}\n   * @private\n   */\n\n\n  Carousel.prototype._isSlideshowPlaying = function _isSlideshowPlaying() {\n    return !!this._timer && this._timer.isTicking;\n  };\n\n  // getNthSibling returns null if it cannot find the nth sibling,\n  // but if `null` is used in `insertBefore`, it will append the element\n  // to the end.\n\n\n  Carousel.prototype.getInnocentNeighbor = function getInnocentNeighbor(iterator, isNext) {\n    var currentSlideEl = this.getSlide(this.getSelectedIndex());\n    return isNext ? Object(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_4__[\"getNthSibling\"])(currentSlideEl, iterator + 1) : Object(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_4__[\"getNthSibling\"])(currentSlideEl, iterator, false) || this._carouselEl.firstElementChild;\n  };\n\n  // eslint-disable-next-line class-methods-use-this\n\n\n  Carousel.prototype.getNeighborInsertionIndex = function getNeighborInsertionIndex(iterator, isNext, currentDomIndex) {\n    return isNext ? currentDomIndex + iterator + 1 : currentDomIndex - iterator;\n  };\n\n  /**\n   *\n   * @param {number} iterator Neighbor index.\n   * @param {number} relativePos Neighbor index relative to the current index.\n   * @param {boolean} isNext Whether to move the slide next or previous.\n   * @private\n   */\n\n\n  Carousel.prototype._setNeighborSlide = function _setNeighborSlide(iterator, relativePos, isNext) {\n    var index = this.getSelectedIndex();\n    var indices = this.getSlideIndices();\n\n    // Previous calls to set neighbor slide may have changed the DOM, so\n    // don't rely on stored variables.\n    var currentDomIndex = this._getDomIndex(index);\n\n    // Index of the future neighbor relative to the original DOM order.\n    var logicalNeighborIndex = this._getRelativeIndex(index, relativePos);\n\n    // Do the slides need to be rearranged? Check the current indices to see\n    // if the new neighbors are already there.\n    if (indices[currentDomIndex + relativePos] !== logicalNeighborIndex) {\n      // The slide to insert the new neighbor before.\n      var innocentNeighbor = this.getInnocentNeighbor(iterator, isNext);\n      var insertionIndex = this.getNeighborInsertionIndex(iterator, isNext, currentDomIndex);\n      var neighborEl = this.getSlide(logicalNeighborIndex);\n\n      // Move the neighbor's index to be a neighbor to the current dom index.\n      this._moveIndex(logicalNeighborIndex, insertionIndex);\n      this._carouselEl.insertBefore(neighborEl, innocentNeighbor);\n    }\n  };\n\n  /**\n   * This function makes sure that looped carousels always have a neighbor to\n   * go to. It repositions the viewport if it has to move slides around.\n   * @private\n   */\n\n\n  Carousel.prototype._setNeighborSlides = function _setNeighborSlides() {\n    var i = void 0;\n\n    // Set the left neighbor(s).\n    for (i = 0; i < this.options.neighborCount; i++) {\n      this._setNeighborSlide(i, -(i + 1), false);\n    }\n\n    // Set the right neighbor(s).\n    for (i = 0; i < this.options.neighborCount; i++) {\n      this._setNeighborSlide(i, i + 1, true);\n    }\n  };\n\n  /**\n   * Reset the carousel back to the currently selected slide without animation.\n   */\n\n\n  Carousel.prototype._snapToCurrentSlide = function _snapToCurrentSlide() {\n    this.goToSlide(this._getDomIndex(this.getSelectedIndex()), true);\n  };\n\n  /**\n   * Determine if the distance between current and destination slides is more\n   * than one slide. If it's not, there is no need to \"jump\".\n   * @param {number} domIndex DOM index of the slide to go to.\n   * @param {boolean} noAnimation Whether or not the slide will be animating.\n   * @return {number} DOM index of the slide to go to because moving slides\n   *     around to \"jump\" them will causes indices to change.\n   */\n\n\n  Carousel.prototype._maybeSetJumpedSlides = function _maybeSetJumpedSlides(domIndex, noAnimation) {\n    // Determine if the distance between current and destination slides\n    // is more than one slide. If it's not, there's no need to \"jump\".\n    if (this.options.isJumped && !noAnimation && Math.abs(this.domIndex - domIndex) > 1) {\n      return this._setNeighborSlidesForJump(domIndex);\n    }\n    return domIndex;\n  };\n\n  /**\n   * Determine whether or not the carousel can navigate in its current condition.\n   * @param {number} domIndex Dom index of the slide to go to.\n   * @param {boolean} noAnimation Whether or not the slide will be animating there.\n   * @return {boolean}\n   */\n\n\n  Carousel.prototype._canNavigate = function _canNavigate(domIndex, noAnimation) {\n    var isSameSlideWithAnimation = domIndex === this.domIndex && !noAnimation;\n\n    // Whether the carousel would be able to move.\n    var isOffset = this.hasDragged || this._isOffset;\n\n    // 1) Whether the carousel is enabled.\n    // 2) The index is out of range and the carousel isn't set to loop. Silently\n    // exit here instead of throwing errors everywhere.\n    // 3) Trying to go to the slide it's already on with a transition and no\n    // dragging has occured or the carousel is not offset.\n    return !(!this._isEnabled || !this.options.isLooped && this.isIndexOutOfRange(domIndex) || isSameSlideWithAnimation && !isOffset);\n  };\n\n  Carousel.prototype._toNewSlide = function _toNewSlide() {\n    // Set flag meaning the carousel is waiting for a transition end.\n    this.isTransitioning = true;\n\n    // Fire event saying the slide started to transition.\n    this._emitEvent(new CarouselEvent(Carousel.EventType.SLIDE_START, this, this._getLogicalIndex(this.lastDomIndex), this._getLogicalIndex(this.domIndex)));\n  };\n\n  /**\n   * Uses Css transforms to move the carousel to a new position.\n   * @param {string} position The percentage value.\n   * @param {boolean} noAnimation Whether to move with animation or not.\n   * @private\n   */\n\n\n  Carousel.prototype._moveToPosition = function _moveToPosition(position, noAnimation) {\n    // Set transform.\n    this._carouselEl.style[_odopod_odo_device__WEBPACK_IMPORTED_MODULE_1__[\"default\"].Dom.TRANSFORM] = this._getCssPosition(position);\n\n    // Set transition speed to zero so that it happens instantly.\n    if (noAnimation) {\n      this._carouselEl.style[_odopod_odo_device__WEBPACK_IMPORTED_MODULE_1__[\"default\"].Dom.TRANSITION_DURATION] = '0ms';\n\n      // Listen for transitionend if it will animate.\n    } else {\n      // Set transition speed.\n      this._carouselEl.style[_odopod_odo_device__WEBPACK_IMPORTED_MODULE_1__[\"default\"].Dom.TRANSITION_DURATION] = this.options.animationSpeed + 'ms';\n\n      // This is used as a backup to the transitionend event, which sometimes\n      // doesn't fire on iOS 7 Safari when the carousel has only been dragged a\n      // few pixels. It's set to go off ~2 frames after the transition end event\n      // should have occurred.\n      this._transitionId = Object(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_4__[\"onTransitionEnd\"])(this._carouselEl, this._transitionDone, this, _odopod_odo_device__WEBPACK_IMPORTED_MODULE_1__[\"default\"].Dom.TRANSFORM, this.options.animationSpeed + Carousel.TRANSITION_END_WAIT);\n\n      this._toNewSlide();\n    }\n  };\n\n  /**\n   * Calculates the offset of the carousel relative to the current slide.\n   * @return {number}\n   */\n\n\n  Carousel.prototype._getCarouselOffset = function _getCarouselOffset() {\n    var matrix = getComputedStyle(this._carouselEl)[_odopod_odo_device__WEBPACK_IMPORTED_MODULE_1__[\"default\"].Dom.TRANSFORM];\n\n    // Round to 1 decimal place because the `_startEdge` can be a decimal.\n    var translate = Math.round(getTranslate(matrix)[this._translateAxis.toLowerCase()] * 10) / 10;\n\n    var slideOffset = this.getSlide(this.getSelectedIndex())[this._offsetPosition];\n    return slideOffset + translate;\n  };\n\n  /**\n   * If the carousel is waiting for a transition to finish (going to a slide),\n   * but the user tells it to navigate again, the previous listener for the\n   * transition end event needs to be canceled. This allows the user to quickly\n   * click through the carousel without waiting for each navigation to finish.\n   *\n   * For jumped and looped carousels, the carousel element needs to be\n   * repositioned because setting neighbor slides will cause the elements to\n   * shift within the main carousel element. The current offset relative to\n   * the current slide is saved before moving any slide elements, then the slide\n   * elements are moved, and finally the carousel is set to appear as if the\n   * elements never moved.\n   */\n\n\n  Carousel.prototype._cancelMovement = function _cancelMovement() {\n    if (!this.isTransitioning) {\n      return;\n    }\n\n    this.isTransitioning = false;\n    Object(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_4__[\"cancelTransitionEnd\"])(this._transitionId);\n\n    if (this.options.isFade) {\n      // Remove the \"behind\" class which is usually removed after the on\n      // transition end.\n      this.getSlide(this._getLogicalIndex(this.lastDomIndex)).classList.remove(Carousel.Classes.BEHIND);\n      // Fading carousels do not need to reposition themselves, end here.\n      return;\n    }\n\n    // Save the offset relative to the current slide before slides are moved.\n    var carouselSize = Object(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_4__[\"getSize\"])(this.getCarouselElement())[this._dimensionAttr];\n    var offset = this._getCarouselOffset();\n\n    if (this._isJumped) {\n      this._setSlidesToLogicalOrder();\n    }\n\n    if (this._isSlidingLooped) {\n      this._setNeighborSlides();\n    }\n\n    // Now that the current slide has potentially moved in the DOM, update the\n    // carousel's offset.\n    var currentSlideEl = this.getSlide(this.getSelectedIndex());\n    var newSlideOffset = currentSlideEl[this._offsetPosition];\n    var position = (newSlideOffset - offset) / carouselSize;\n\n    // Setting the position here stops the browser from transitioning to the\n    // previous position, allowing the user to \"catch\" the carousel mid-nav.\n    this._moveToPosition(position * -100 + '%', true);\n    this.draggable.update();\n  };\n\n  /**\n   * Goes to a given slide.\n   * @param {!number} domIndex The slide index relative to DOM order.\n   * @param {boolean} [noAnimation] Whether going to the slide should animate.\n   * @protected\n   */\n\n\n  Carousel.prototype.fadeToSlide = function fadeToSlide(domIndex, noAnimation) {\n    // Get next and previous slides.\n    var nextSlide = this.getSlide(domIndex);\n    var previousSlide = this.getSlide(this.domIndex);\n\n    // Listen for transitionend if it will animate.\n    if (!noAnimation) {\n      // Going to a new slide, wait for callback.\n      this._transitionId = Object(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_4__[\"onTransitionEnd\"])(nextSlide, this._transitionDone, this);\n    }\n\n    // Show next slide. Put the previous behind the next.\n    nextSlide.classList.add(Carousel.Classes.VISIBLE);\n\n    if (previousSlide !== nextSlide) {\n      previousSlide.classList.add(Carousel.Classes.BEHIND);\n\n      // Delay the previous slide fading out by the specified percentage.\n      // The crossfade amount is between 0 and 1. A value of 1 means that both slides\n      // will fade at the same time. A crossfade of zero means the previous slide\n      // will wait until the next slide has completely faded in before it fades out.\n      setTimeout(function () {\n        previousSlide.classList.remove(Carousel.Classes.VISIBLE);\n      }, this._crossfadeTimeout);\n    }\n\n    // Save the last slide index.\n    this.lastDomIndex = this.domIndex;\n    this.domIndex = domIndex;\n\n    // Emit event for slide start.\n    if (!noAnimation) {\n      this._toNewSlide();\n    }\n  };\n\n  /**\n   * Goes to a given slide.\n   * @param {!number} domIndex The slide index relative to DOM order.\n   * @param {boolean} [noAnimation] Whether going to the slide should animate.\n   * @protected\n   */\n\n\n  Carousel.prototype.goToSlide = function goToSlide(domIndex, noAnimation) {\n    // Get the destion slide element from the current DOM order.\n    var destinationSlide = this.getSlide(this._getLogicalIndex(domIndex));\n\n    // If the carousel skips inbetween slides, reposition them.\n    // DOM index is reassinged here because if the slides are repositioned,\n    // the DOM index of the carousel changes.\n    var updatedDomIndex = this._maybeSetJumpedSlides(domIndex, noAnimation);\n\n    // The position the container will go to.\n    var adjustedPosition = this._getNewPosition(destinationSlide) * -100 + '%';\n\n    // Save the last slide index.\n    this.lastDomIndex = this.domIndex;\n    this.domIndex = updatedDomIndex;\n\n    // Set the css styles to move the carousel element. This also dispatches\n    // the slide start event if the carousel element will move with animation.\n    this._moveToPosition(adjustedPosition, noAnimation);\n  };\n\n  /**\n   * Helper function for going to a given index. This method should be used\n   * instead of the private one to abstract the DOM order stuff.\n   * @param {number} index The logical, zero based index of the slide you wish\n   *     the carousel to go to.\n   * @param {boolean} [noAnimation] Optional skip the animation in goToSlide.\n   * @return {boolean} Whether the carousel will go to the specified slide.\n   */\n\n\n  Carousel.prototype.setSelectedIndex = function setSelectedIndex(index, noAnimation) {\n    var domIndex = this._getDomIndex(index);\n    var canNavigate = this._canNavigate(domIndex, noAnimation);\n\n    // Will go the the give slide.\n    if (canNavigate) {\n      // If the event's default action was prevented, return false.\n      if (this._emitEvent(new CarouselEvent(Carousel.EventType.WILL_NAVIGATE, this))) {\n        return false;\n      }\n\n      this._cancelMovement();\n\n      this._selectedIndex = this._getSafeIndex(index);\n\n      // Convert new safe logical index to a DOM index.\n      domIndex = this._getDomIndex(this._selectedIndex);\n\n      // Set new classes on the slide elements. This is also where toggling\n      // paddles and pagination should go.\n      this._setSlidesState();\n      this._setPaddleState();\n      this._setPaginationState();\n      if (this.options.isFade) {\n        this.fadeToSlide(domIndex, noAnimation);\n      } else {\n        this.goToSlide(domIndex, noAnimation);\n      }\n    }\n\n    // Otherwise, it will not go to the give slide due to unmet conditions.\n    return canNavigate;\n  };\n\n  /**\n   * Find the nearest slide, and move the carousel to that.\n   * @param {boolean} [isNext] Whether it should go to the nearest slide, but\n   *     only in the next direction. False means it should go previous and\n   *     anything not true or false will go to the nearest slide regardless\n   *     of direction.\n   * @return {boolean} Whether the carousel will go to the specified slide.\n   */\n\n\n  Carousel.prototype.goToNearestSlide = function goToNearestSlide(isNext) {\n    // Gets positions relative to the wrapper element of each slide.\n    var positions = this._getPositions(this.getSlides());\n\n    // Current position (the left side of the carousel wrapper)\n    // Gets the closest value in the array to the given value.\n    // Index of the closest value.\n    var logicalIndex = positions.indexOf(Object(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_4__[\"closest\"])(positions, this._startEdge));\n\n    // When going to a next or previous slide, the closest index could\n    // still be the one that's currently selected, but the carousel should\n    // still move next/previous because it has enough velocity.\n    if (logicalIndex === this.getSelectedIndex()) {\n      if (isNext === true) {\n        logicalIndex = this._getSafeIndex(logicalIndex + 1);\n      } else if (isNext === false) {\n        logicalIndex = this._getSafeIndex(logicalIndex - 1);\n      }\n    }\n\n    return this.setSelectedIndex(logicalIndex);\n  };\n\n  /**\n   * Go to the next slide.\n   * @return {boolean} Whether the carousel will go to the specified slide.\n   */\n\n\n  Carousel.prototype.goToNextSlide = function goToNextSlide() {\n    return this.setSelectedIndex(this.getSelectedIndex() + 1);\n  };\n\n  /**\n   * Go to the previous slide.\n   * @return {boolean} Whether the carousel will go to the specified slide.\n   */\n\n\n  Carousel.prototype.goToPreviousSlide = function goToPreviousSlide() {\n    return this.setSelectedIndex(this.getSelectedIndex() - 1);\n  };\n\n  /**\n   * Sets the past, previous, active, next, and future classes to the appropriate\n   * slides.\n   * @private\n   */\n\n\n  Carousel.prototype._setSlidesState = function _setSlidesState() {\n    var selectedIndex = this.getSelectedIndex();\n    var past = this._getSafeIndex(selectedIndex - 2);\n    var previous = this._getSafeIndex(selectedIndex - 1);\n    var next = this._getSafeIndex(selectedIndex + 1);\n    var future = this._getSafeIndex(selectedIndex + 2);\n\n    // This works because the _slides array does not mimic the DOM order.\n    this.getSlides().forEach(function (slide, i) {\n      var isActive = i === selectedIndex;\n\n      toggleFocusability(slide, isActive);\n\n      slide.setAttribute('aria-hidden', !isActive);\n\n      // Active slide.\n      slide.classList.toggle(Carousel.Classes.ACTIVE_SLIDE, isActive);\n\n      // Previous previous slide.\n      slide.classList.toggle(Carousel.Classes.PAST_SLIDE, i === past && selectedIndex !== past && previous !== past);\n\n      // Previous slide.\n      slide.classList.toggle(Carousel.Classes.PREVIOUS_SLIDE, i === previous && selectedIndex !== previous);\n\n      // Next slide.\n      slide.classList.toggle(Carousel.Classes.NEXT_SLIDE, i === next && selectedIndex !== next);\n\n      // Next next slide.\n      slide.classList.toggle(Carousel.Classes.FUTURE_SLIDE, i === future && selectedIndex !== future && next !== future);\n    });\n  };\n\n  Carousel.prototype._setPaginationState = function _setPaginationState() {\n    if (this.options.pagination) {\n      var selectedIndex = this.getSelectedIndex();\n      this._paginationDots.forEach(function (_ref) {\n        var dot = _ref.dot,\n            i = _ref.i,\n            i2 = _ref.i2;\n\n        var selected = selectedIndex === i || selectedIndex === i2;\n        dot.classList.toggle(Carousel.Classes.PAGINATION_DOT_SELECTED, selected);\n        dot.setAttribute('aria-selected', selected);\n      });\n    }\n  };\n\n  Carousel.prototype._setPaddleState = function _setPaddleState() {\n    var notLooped = !this.options.isLooped;\n    if (notLooped && this._paddlePrevious) {\n      var first = this.isFirstSlide();\n      this._paddlePrevious.classList.toggle(Carousel.Classes.PADDLE_DISABLED, first);\n      this._paddlePrevious.setAttribute('aria-disabled', first);\n    }\n\n    if (notLooped && this._paddleNext) {\n      var last = this.isLastSlide();\n      this._paddleNext.classList.toggle(Carousel.Classes.PADDLE_DISABLED, last);\n      this._paddleNext.setAttribute('aria-disabled', last);\n    }\n  };\n\n  /**\n   * Callback for when the slideshow timer expires.\n   * @private\n   */\n\n\n  Carousel.prototype._slideshowTimerExpired = function _slideshowTimerExpired() {\n    // Pause the timer if it's at the end.\n    if (!this.options.isLooped && this.isLastSlide()) {\n      this.pauseSlideshow();\n    } else {\n      this.goToNextSlide();\n    }\n  };\n\n  Carousel.prototype._transitionDone = function _transitionDone() {\n    var from = this._getLogicalIndex(this.lastDomIndex);\n    var to = this._getLogicalIndex(this.domIndex);\n\n    // Needs to come before setting neighbor slides.\n    this.isTransitioning = false;\n\n    if (this._isJumped) {\n      this._setSlidesToLogicalOrder();\n    }\n\n    // Neighboring slides must be set after each transition for looped carousels.\n    if (this._isSlidingLooped) {\n      this._setNeighborSlides();\n    }\n\n    if (this._isJumped || this._isSlidingLooped) {\n      this._snapToCurrentSlide();\n    }\n\n    if (this.options.isFade) {\n      this.getSlide(from).classList.remove(Carousel.Classes.BEHIND);\n    }\n\n    // No longer jumped.\n    this._isJumped = false;\n\n    // Dispatch slide end event.\n    this._emitEvent(new CarouselEvent(Carousel.EventType.SLIDE_END, this, from, to));\n  };\n\n  /**\n   * Received the pointer end event.\n   * @param {PointerEvent} pointerEvent Pointer event object.\n   */\n\n\n  Carousel.prototype._handlePointerEnd = function _handlePointerEnd(pointerEvent) {\n    if (this.pointer.hasVelocity(pointerEvent.velocity)) {\n      if (pointerEvent.direction === _odopod_odo_pointer__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Direction.RIGHT) {\n        this.goToPreviousSlide();\n      } else if (pointerEvent.direction === _odopod_odo_pointer__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Direction.LEFT) {\n        this.goToNextSlide();\n      }\n    }\n  };\n\n  /**\n   * The click listener is bound to the main element. Inside the handler, the target\n   * of the click is tested and if it is a pagination dot or paddle, navigation\n   * will be started.\n   * @param {Event} evt Event object.\n   * @private\n   */\n\n\n  Carousel.prototype._handleClick = function _handleClick(evt) {\n    var target = evt.target;\n\n    var willNavigate = false;\n\n    // Determine what was clicked.\n    var dot = target.closest('.' + Carousel.Classes.PAGINATION_DOT);\n    var prev = target.closest('.' + Carousel.Classes.PADDLE_PREV);\n    var next = target.closest('.' + Carousel.Classes.PADDLE_NEXT);\n\n    // Navigation dot.\n    if (dot) {\n      willNavigate = true;\n      this.setSelectedIndex(parseInt(dot.getAttribute('data-index'), 10));\n\n      // Left paddle or child of left paddle.\n    } else if (prev) {\n      willNavigate = true;\n      this.goToPreviousSlide();\n\n      // Right paddle or child of right paddle.\n    } else if (next) {\n      willNavigate = true;\n      this.goToNextSlide();\n\n      // If the carousel slides have links in them, some browsers (Firefox), will\n      // emit the click event even after a drag if the mouse is still on the\n      // clickable element.\n    } else if (this.isTransitioning) {\n      evt.preventDefault();\n    }\n\n    if (willNavigate) {\n      evt.preventDefault();\n\n      // Pause slideshow if it's playing.\n      this.pauseSlideshow();\n    }\n  };\n\n  /**\n   * Stop animations that were ongoing when you started to drag.\n   * @private\n   */\n\n\n  Carousel.prototype._handleDragStart = function _handleDragStart() {\n    this.pauseSlideshow();\n    this._cancelMovement();\n\n    // Remove transition while dragging.\n    this._carouselEl.style[_odopod_odo_device__WEBPACK_IMPORTED_MODULE_1__[\"default\"].Dom.TRANSITION_DURATION] = '0ms';\n  };\n\n  /**\n   * Pointer move event. Set a friction value if on the first/last slide and\n   * going towards the edge.\n   * @param {PointerEvent} evt Pointer event emitted by draggable.\n   * @private\n   */\n\n\n  Carousel.prototype._handleDragMove = function _handleDragMove(_ref2) {\n    var delta = _ref2.delta;\n\n    this.hasDragged = this.isVertical ? Math.abs(delta.y) > 0 : Math.abs(delta.x) > 0;\n    if (!this.options.isLooped) {\n      var friction = this._isMovingTowardsEdge(delta.x, delta.y) ? 0.4 : 1;\n      this.draggable.friction = friction;\n    }\n  };\n\n  /**\n   * Depending on how fast you were dragging, either proceed to an adjacent\n   * slide or reset position to the nearest one.\n   * @param {PointerEvent} evt Pointer event emitted by draggable.\n   * @private\n   */\n\n\n  Carousel.prototype._handleDragEnd = function _handleDragEnd(evt) {\n    this.draggable.friction = 1;\n    this.navigateAfterDrag(evt.velocity, evt.axisDirection, evt.didMoveOnAxis);\n    this.hasDragged = false;\n    this._isOffset = false;\n  };\n\n  Carousel.prototype._shouldGoToPrevious = function _shouldGoToPrevious(hasVelocity, direction) {\n    return hasVelocity && (this.options.isLooped || !this.isFirstSlide()) && (direction === _odopod_odo_pointer__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Direction.RIGHT || direction === _odopod_odo_pointer__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Direction.DOWN);\n  };\n\n  Carousel.prototype._shouldGoToNext = function _shouldGoToNext(hasVelocity, direction) {\n    return hasVelocity && (this.options.isLooped || !this.isLastSlide()) && (direction === _odopod_odo_pointer__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Direction.LEFT || direction === _odopod_odo_pointer__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Direction.UP);\n  };\n\n  /**\n   * Decide what to do after the user drags the carousel.\n   * @param {Coordinate} velocity Velocity for x and y directions.\n   * @param {OdoPointer.Direction} direction Drag direction.\n   * @param {boolean} didMoveOnAxis Whether the drag direction was on the defined axis.\n   * @protected\n   */\n\n\n  Carousel.prototype.navigateAfterDrag = function navigateAfterDrag(velocity, direction, didMoveOnAxis) {\n    var hasVelocity = this.hasDragged && this.draggable.pointer.hasVelocity(velocity);\n\n    // If dragging has not occurred, the user simply clicked on the carousel.\n    // If the user is quickly navigating through the carousel, then clicks on\n    // it, the movement will be canceled, but it wouldn't go anywhere because it\n    // appears to be going to the same slide. Determine if the carousel is still\n    // between slides (offset). If it is, it needs to go to the nearest slide.\n    if (!this.hasDragged) {\n      this._isOffset = Math.abs(Math.round(this._getCarouselOffset())) > Math.round(this._startEdge);\n    }\n\n    // Previous.\n    if (this._shouldGoToPrevious(hasVelocity, direction)) {\n      this.goToNearestSlide(false);\n\n      // Next.\n    } else if (this._shouldGoToNext(hasVelocity, direction)) {\n      this.goToNearestSlide(true);\n\n      // Not enough velocity, go to the nearest slide.\n      // The distance must at least be 1, otherwise gotoSlide creates an event\n      // listener for moving the element by zero pixels and the transition end\n      // event doesn't fire.\n    } else if (didMoveOnAxis || this._isOffset) {\n      this.goToNearestSlide();\n    }\n  };\n\n  /**\n   * Emits a event on this instance.\n   * @param {CarouselEvent} event Event object with data.\n   * @return {boolean} Whether preventDefault was called on the event.\n   */\n\n\n  Carousel.prototype._emitEvent = function _emitEvent(event) {\n    this.emit(event.type, event);\n    return event.defaultPrevented;\n  };\n\n  /**\n   * Whether the carousel is being dragged towards an edge.\n   * @param {number} deltaX Change in x during drag.\n   * @param {number} deltaY Change in y during drag.\n   * @return {boolean}\n   * @private\n   */\n\n\n  Carousel.prototype._isMovingTowardsEdge = function _isMovingTowardsEdge(deltaX, deltaY) {\n    var toStartEdge = this.isVertical ? deltaY > 0 : deltaX > 0;\n    var toEndEdge = this.isVertical ? deltaY < 0 : deltaX < 0;\n\n    return this.isFirstSlide() && toStartEdge || this.isLastSlide() && toEndEdge;\n  };\n\n  /**\n   * Remove event listeners, DOM references, inline styles, class names, paddles,\n   * and pagination added by Carousel.\n   */\n\n\n  Carousel.prototype.dispose = function dispose() {\n    if (this._timer) {\n      this._timer.dispose();\n    }\n\n    this._removeA11yAttributes();\n    this._removePaddles();\n    this._removePagination();\n\n    // Reset container styles.\n    this._carouselEl.style[_odopod_odo_device__WEBPACK_IMPORTED_MODULE_1__[\"default\"].Dom.TRANSFORM] = '';\n    this._carouselEl.style[_odopod_odo_device__WEBPACK_IMPORTED_MODULE_1__[\"default\"].Dom.TRANSITION] = '';\n\n    if (this.options.isFade) {\n      this.pointer.off(_odopod_odo_pointer__WEBPACK_IMPORTED_MODULE_2__[\"default\"].EventType.END, this._onPointerEnd);\n      this.pointer.dispose();\n\n      this.getSlides().forEach(function (slide) {\n        slide.style[_odopod_odo_device__WEBPACK_IMPORTED_MODULE_1__[\"default\"].Dom.TRANSITION] = '';\n      });\n    } else {\n      this.draggable.off(_odopod_odo_draggable__WEBPACK_IMPORTED_MODULE_3__[\"default\"].EventType.START, this._onDragStart);\n      this.draggable.off(_odopod_odo_draggable__WEBPACK_IMPORTED_MODULE_3__[\"default\"].EventType.MOVE, this._onDragMove);\n      this.draggable.off(_odopod_odo_draggable__WEBPACK_IMPORTED_MODULE_3__[\"default\"].EventType.END, this._onDragEnd);\n\n      this.draggable.dispose();\n    }\n\n    this.element.removeEventListener('click', this._onClick);\n\n    this._slides.forEach(function (slide) {\n      slide.classList.remove(Carousel.Classes.PAST_SLIDE, Carousel.Classes.PREVIOUS_SLIDE, Carousel.Classes.ACTIVE_SLIDE, Carousel.Classes.NEXT_SLIDE, Carousel.Classes.FUTURE_SLIDE, Carousel.Classes.VISIBLE, Carousel.Classes.BEHIND);\n    });\n\n    // When the carousel is bidirectional, it has cloned the first two slides\n    // and added them to the carousel element. Remove the clones.\n    if (this._isBidirectional) {\n      this._carouselEl.removeChild(this._slides[2]);\n      this._carouselEl.removeChild(this._slides[3]);\n    }\n\n    // Null out DOM refs.\n    this.element = null;\n    this._slideContainerParentEl = null;\n    this._carouselEl = null;\n    this._paddlePrevious = null;\n    this._paddleNext = null;\n    this._paginationDots = null;\n    this.draggable = null;\n    this.pointer = null;\n    this._slides.length = 0;\n  };\n\n  /**\n   * Because Object.assign only does a shallow merge, merge the template option\n   * first and then overwrite the main Object.assign result.\n   * @param {Object} options Options object.\n   * @return {Object} Merged options object with defaults.\n   */\n\n\n  Carousel.getOptions = function getOptions(options) {\n    var templates = Object.assign({}, Carousel.Defaults.template, options.template);\n    var opts = Object.assign({}, Carousel.Defaults, options);\n    opts.template = templates;\n    return opts;\n  };\n\n  createClass(Carousel, [{\n    key: 'isEnabled',\n    get: function get$$1() {\n      return this._isEnabled;\n    }\n\n    /**\n     * Toggle the enabled/disabled state of the carousel. When it's disabled, it\n     * will not be able to navigate slides.\n     * @param {boolean} enabled Whether to enable or disable.\n     */\n    ,\n    set: function set$$1(enabled) {\n      this._isEnabled = enabled;\n      this._setDraggableEnabled(enabled);\n    }\n  }]);\n  return Carousel;\n}(tiny_emitter__WEBPACK_IMPORTED_MODULE_0___default.a);\n\nObject.assign(Carousel, settings);\n\nCarousel.template = template;\nCarousel.CarouselEvent = CarouselEvent;\n\n// Export for testing.\nCarousel._getTranslate = getTranslate;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Carousel);\n//# sourceMappingURL=odo-carousel.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG9kb3BvZC9vZG8tY2Fyb3VzZWwvZGlzdC9vZG8tY2Fyb3VzZWwuZXNtLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BvZG9wb2Qvb2RvLWNhcm91c2VsL2Rpc3Qvb2RvLWNhcm91c2VsLmVzbS5qcz82OWExIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBUaW55RW1pdHRlciBmcm9tICd0aW55LWVtaXR0ZXInO1xuaW1wb3J0IE9kb0RldmljZSBmcm9tICdAb2RvcG9kL29kby1kZXZpY2UnO1xuaW1wb3J0IE9kb1BvaW50ZXIgZnJvbSAnQG9kb3BvZC9vZG8tcG9pbnRlcic7XG5pbXBvcnQgT2RvRHJhZ2dhYmxlIGZyb20gJ0BvZG9wb2Qvb2RvLWRyYWdnYWJsZSc7XG5pbXBvcnQgeyBjYW5jZWxUcmFuc2l0aW9uRW5kLCBjYXBpdGFsaXplLCBjbGFtcCwgY2xvc2VzdCwgZ2V0RWxlbWVudHNTaXplLCBnZXROdGhTaWJsaW5nLCBnZXRTaXplLCBnaXZlSWQsIG9uVHJhbnNpdGlvbkVuZCwgc3dhcEVsZW1lbnRzLCBUaW1lciwgd3JhcEFyb3VuZExpc3QgfSBmcm9tICdAb2RvcG9kL29kby1oZWxwZXJzJztcblxudmFyIGNsYXNzQ2FsbENoZWNrID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cbnZhciBjcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTtcblxudmFyIGluaGVyaXRzID0gZnVuY3Rpb24gKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufTtcblxudmFyIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4gPSBmdW5jdGlvbiAoc2VsZiwgY2FsbCkge1xuICBpZiAoIXNlbGYpIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjtcbn07XG5cbnZhciBDYXJvdXNlbEV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogT2JqZWN0IHJlcHJlc2VudGluZyBhIGNhcm91c2VsIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlLlxuICAgKiBAcGFyYW0ge0Nhcm91c2VsfSBjYXJvdXNlbCBUaGUgY2Fyb3VzZWwgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0RnJvbSBUaGUgbG9naWNhbCBpbmRleCB0aGUgY2Fyb3VzZWwgaXMgY29taW5nIGZyb20uXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0VG8gVGhlIGxvZ2ljYWwgaW5kZXggdGhlIGNhcm91ZXNsIGlzIGdvaW5nIHRvLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIENhcm91c2VsRXZlbnQodHlwZSwgY2Fyb3VzZWwsIG9wdEZyb20sIG9wdFRvKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2Fyb3VzZWxFdmVudCk7XG5cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuXG4gICAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi9cbiAgICB0aGlzLnRhcmdldCA9IGNhcm91c2VsLmVsZW1lbnQ7XG5cbiAgICAvKiogQHR5cGUge251bWJlcn0gY2Fyb3VzZWwgc2xpZCBmcm9tIHRoaXMgaW5kZXguICovXG4gICAgdGhpcy5mcm9tID0gb3B0RnJvbTtcblxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSBjYXJvdXNlbCBzbGlkIHRvIHRoaXMgaW5kZXguICovXG4gICAgdGhpcy50byA9IG9wdFRvO1xuXG4gICAgLyoqIEB0eXBlIHtib29sZWFufSBXaGV0aGVyIHRoZSBjYXJvdXNlbCBhY3R1YWxseSBjaGFuZ2VkIHNsaWRlcy4gKi9cbiAgICB0aGlzLmhhc1NsaWRlQ2hhbmdlZCA9IG9wdEZyb20gIT09IG9wdFRvO1xuXG4gICAgLyoqIEB0eXBlIHtib29sZWFufSBXaGV0aGVyIGBwcmV2ZW50RGVmYXVsdGAgaGFzIGJlZW4gY2FsbGVkLiAqL1xuICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IGZhbHNlO1xuICB9XG5cbiAgQ2Fyb3VzZWxFdmVudC5wcm90b3R5cGUucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICB9O1xuXG4gIHJldHVybiBDYXJvdXNlbEV2ZW50O1xufSgpO1xuXG52YXIgc2V0dGluZ3MgPSB7XG5cbiAgLyoqXG4gICAqIEV2ZW50IHR5cGVzIGVtaXR0ZWQgYnkgdGhlIGNhcm91c2VsLlxuICAgKiBAZW51bSB7c3RyaW5nfVxuICAgKi9cbiAgRXZlbnRUeXBlOiB7XG4gICAgV0lMTF9OQVZJR0FURTogJ29kb2Nhcm91c2VsOndpbGxuYXZpZ2F0ZScsXG4gICAgU0xJREVfU1RBUlQ6ICdvZG9jYXJvdXNlbDpzbGlkZXN0YXJ0JyxcbiAgICBTTElERV9FTkQ6ICdvZG9jYXJvdXNlbDpzbGlkZWVuZCdcbiAgfSxcblxuICAvKiogQGVudW0ge3N0cmluZ30gKi9cbiAgQ2xhc3Nlczoge1xuICAgIEJBU0U6ICdvZG8tY2Fyb3VzZWwnLFxuICAgIEZBREU6ICdvZG8tY2Fyb3VzZWwtLWZhZGUnLFxuICAgIFZFUlRJQ0FMOiAnb2RvLWNhcm91c2VsLS12ZXJ0aWNhbCcsXG4gICAgV1JBUFBFUjogJ29kby1jYXJvdXNlbF9fd3JhcHBlcicsXG4gICAgQ0FST1VTRUxfRUxFTUVOVDogJ29kby1jYXJvdXNlbF9fZWxlbWVudCcsXG5cbiAgICBTTElERTogJ29kby1jYXJvdXNlbF9fc2xpZGUnLFxuICAgIEFDVElWRV9TTElERTogJ29kby1jYXJvdXNlbF9fc2xpZGUtLWFjdGl2ZScsXG4gICAgUFJFVklPVVNfU0xJREU6ICdvZG8tY2Fyb3VzZWxfX3NsaWRlLS1wcmV2aW91cycsXG4gICAgUEFTVF9TTElERTogJ29kby1jYXJvdXNlbF9fc2xpZGUtLXBhc3QnLFxuICAgIE5FWFRfU0xJREU6ICdvZG8tY2Fyb3VzZWxfX3NsaWRlLS1uZXh0JyxcbiAgICBGVVRVUkVfU0xJREU6ICdvZG8tY2Fyb3VzZWxfX3NsaWRlLS1mdXR1cmUnLFxuXG4gICAgVklTSUJMRTogJ29kby1jYXJvdXNlbF9fc2xpZGUtLXZpc2libGUnLFxuICAgIEJFSElORDogJ29kby1jYXJvdXNlbF9fc2xpZGUtLWJlaGluZCcsXG5cbiAgICBQQUdJTkFUSU9OOiAnb2RvLWNhcm91c2VsX19wYWdpbmF0aW9uJyxcbiAgICBQQUdJTkFUSU9OX0RPVDogJ29kby1jYXJvdXNlbF9fcGFnaW5hdGlvbi1kb3QnLFxuICAgIFBBR0lOQVRJT05fRE9UX1NFTEVDVEVEOiAnaXMtc2VsZWN0ZWQnLFxuXG4gICAgUEFERExFUzogJ29kby1jYXJvdXNlbF9fbmF2LXBhZGRsZXMnLFxuICAgIFBBRERMRTogJ29kby1jYXJvdXNlbF9fbmF2LXBhZGRsZScsXG4gICAgUEFERExFX05FWFQ6ICdvZG8tY2Fyb3VzZWxfX25hdi1uZXh0JyxcbiAgICBQQURETEVfUFJFVjogJ29kby1jYXJvdXNlbF9fbmF2LXByZXYnLFxuICAgIFBBRERMRV9ESVNBQkxFRDogJ2lzLWRpc2FibGVkJyxcblxuICAgIFNMSURFX0NISUxEOiAnb2RvLWNhcm91c2VsX19zbGlkZS1jaGlsZCdcbiAgfSxcblxuICBEZWZhdWx0czoge1xuICAgIHN0YXJ0SW5kZXg6IDAsXG4gICAgaXNWZXJ0aWNhbDogZmFsc2UsXG4gICAgaXNMb29wZWQ6IGZhbHNlLFxuICAgIGlzSnVtcGVkOiBmYWxzZSxcbiAgICBpc0ZhZGU6IGZhbHNlLFxuICAgIGlzQ2VudGVyZWQ6IGZhbHNlLFxuICAgIG5laWdoYm9yQ291bnQ6IDEsXG4gICAgc2xpZGVzaG93U3BlZWQ6IDEwMDAsXG4gICAgYW5pbWF0aW9uU3BlZWQ6IDQwMCxcbiAgICBjcm9zc2ZhZGVBbW91bnQ6IDAuODc1LFxuICAgIGVhc2luZzogJ2N1YmljLWJlemllcigwLjI1MCwgMC40NjAsIDAuNDUwLCAwLjk0MCknLFxuICAgIHBhZ2luYXRpb246IGZhbHNlLFxuICAgIGdldE5hdlBhZGRsZUh0bWw6IG51bGwsXG4gICAgZ2V0UGFnaW5hdGlvbkh0bWw6IG51bGwsXG4gICAgdGVtcGxhdGU6IHtcbiAgICAgIHBhZGRsZXM6ICc8bmF2IGNsYXNzPVwib2RvLWNhcm91c2VsX19uYXYtcGFkZGxlc1wiPnt7IHByZXYgfX17eyBuZXh0IH19PC9uYXY+JyxcbiAgICAgIHBhZGRsZU5leHQ6ICc8YSBocmVmPVwiamF2YXNjcmlwdDp2b2lkKDApXCIgcm9sZT1cImJ1dHRvblwiIGFyaWEtbGFiZWw9XCJuZXh0IHNsaWRlXCIgY2xhc3M9XCJvZG8tY2Fyb3VzZWxfX25hdi1wYWRkbGUgb2RvLWNhcm91c2VsX19uYXYtbmV4dFwiPnt7IHBhZGRsZUlubmVyIH19PC9hPicsXG4gICAgICBwYWRkbGVQcmV2OiAnPGEgaHJlZj1cImphdmFzY3JpcHQ6dm9pZCgwKVwiIHJvbGU9XCJidXR0b25cIiBhcmlhLWxhYmVsPVwicHJldmlvdXMgc2xpZGVcIiBjbGFzcz1cIm9kby1jYXJvdXNlbF9fbmF2LXBhZGRsZSBvZG8tY2Fyb3VzZWxfX25hdi1wcmV2XCI+e3sgcGFkZGxlSW5uZXIgfX08L2E+JyxcbiAgICAgIHBhZGRsZU5leHRJbm5lcjogJzxzdmcgdmlld0JveD1cIjc1LjQgMjcgNDYxLjIgNzM4XCI+PHBhdGggZD1cIk0xNjcuNyAyN2wzNjguOSAzNjktMzY4LjkgMzY5LTkyLjMtOTIuMyAyNzYuNy0yNzYuNy0yNzYuNy0yNzYuN3pcIi8+PC9zdmc+JyxcbiAgICAgIHBhZGRsZVByZXZJbm5lcjogJzxzdmcgdmlld0JveD1cIjc1LjM5NiAyNi45OTQgNDYxLjIwOCA3MzguMDEyXCI+PHBhdGggZD1cIk00NDQuMzM2IDc2NS4wMDZsLTM2OC45NC0zNjkuMDA2IDM2OC45NC0zNjkuMDA2IDkyLjI2OCA5Mi4yNjgtMjc2LjczOCAyNzYuNzM4IDI3Ni43MzggMjc2LjczOHpcIi8+PC9zdmc+JyxcbiAgICAgIHBhZ2luYXRpb246ICc8bmF2IGNsYXNzPVwib2RvLWNhcm91c2VsX19wYWdpbmF0aW9uXCIgcm9sZT1cInRhYmxpc3RcIj57eyBkb3RzIH19PC9uYXY+JyxcbiAgICAgIHBhZ2luYXRpb25Eb3Q6ICc8YSBocmVmPVwiamF2YXNjcmlwdDp2b2lkKDApXCIgcm9sZT1cInRhYlwiIGFyaWEtbGFiZWw9XCJHbyB0byBzbGlkZSB7eyBpbmRleDEgfX1cIiBhcmlhLWNvbnRyb2xzPVwie3sgc2xpZGVJZCB9fVwiIGFyaWEtc2VsZWN0ZWQ9XCJmYWxzZVwiIGNsYXNzPVwib2RvLWNhcm91c2VsX19wYWdpbmF0aW9uLWRvdFwiIGRhdGEtaW5kZXg9XCJ7eyBpbmRleCB9fVwiPjwvYT4nLFxuICAgICAgcGFnaW5hdGlvbkRvdFNlY29uZGFyeTogJzxhIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMClcIiByb2xlPVwidGFiXCIgYXJpYS1sYWJlbD1cIkdvIHRvIHNsaWRlIHt7IGluZGV4MSB9fVwiIGFyaWEtY29udHJvbHM9XCJ7eyBzbGlkZUlkIH19XCIgYXJpYS1zZWxlY3RlZD1cImZhbHNlXCIgY2xhc3M9XCJvZG8tY2Fyb3VzZWxfX3BhZ2luYXRpb24tZG90XCIgZGF0YS1pbmRleD1cInt7IGluZGV4IH19XCIgZGF0YS1zZWNvbmRhcnktaW5kZXg9XCJ7eyBzZWNvbmRhcnlJbmRleCB9fVwiIGFyaWEtaGlkZGVuPVwie3sgaGlkZGVuIH19XCI+PC9hPidcbiAgICB9XG4gIH0sXG5cbiAgVFJBTlNJVElPTl9FTkRfV0FJVDogMzJcbn07XG5cbi8qKlxuICogQSBzaW1wbGUgc3RyaW5nIHJlcGxhY2VtZW50IHRlbXBsYXRlIHdpdGggZG91YmxlIGN1cmx5IGJyYWNlcy4gWW91IGNhbiB1c2VcbiAqIG5lc3RlZCBvYmplY3RzIGFuZCBmdW5jdGlvbnMgdG9vLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBcIlRvZGF5IGlzIFRodXJzZGF5XCJcbiAqIHRlbXBsYXRlKFwiVG9kYXkgaXMge3sgZGF5IH19XCIsIHtcbiAqICAgZGF5OiAnVGh1cnNkYXknLFxuICogfSk7XG4gKlxuICogLy8gXCJUb2RheSBpcyBGcmlkYXlcIlxuICogdGVtcGxhdGUoXCJUb2RheSBpcyB7eyBtb250aC5kYXkgfX1cIiwge1xuICogICBtb250aDoge1xuICogICAgIGRheTogJ0ZyaWRheScsXG4gKiAgIH0sXG4gKiB9KTtcbiAqXG4gKiAvLyBcIlRvZGF5IGlzIFNhdHVyZGF5XCJcbiAqIHRlbXBsYXRlKFwiVG9kYXkgaXMge3sgZGF5IH19XCIsIHtcbiAqICAgdG9kYXk6ICdTYXR1cmRheScsXG4gKiAgIGRheSgpIHtcbiAqICAgICByZXR1cm4gdGhpcy50b2RheTtcbiAqICAgfSxcbiAqIH0pO1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGVtcGxhdGUuXG4gKiBAcGFyYW0ge29iamVjdH0gZGF0YSBEYXRhIG9iamVjdCB3aXRoIGtleXMgd2hpY2ggbWF0Y2ggeW91ciB0ZW1wbGF0ZS5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gdGVtcGxhdGUoc3RyLCBkYXRhKSB7XG4gIC8vIEEgbW9kaWZpZWQgdmVyc2lvbiBvZiBNYWxzdXAncyB0ZW1wbGF0ZSBtZXRob2QgZm9yIEN5Y2xlLlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWFsc3VwL2N5Y2xlMi9ibG9iL21hc3Rlci9zcmMvanF1ZXJ5LmN5Y2xlMi50bXBsLmpzXG5cbiAgLy8gUmVnZXggd2hpY2ggbWF0Y2hlcyB7e2Nvb2x9fSBvciB7eyBjb29sIH19IHdoZXJlIGBjb29sYCBpcyB3aGF0IHNob3VsZFxuICAvLyBiZSByZXBsYWNlZC5cbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC97e1xccz8oKC4pPy4qPylcXHM/fX0vZywgZnVuY3Rpb24gKG1hdGNoLCBzdHIpIHtcbiAgICB2YXIgbmFtZXMgPSBzdHIuc3BsaXQoJy4nKTtcbiAgICB2YXIgb2JqID0gZGF0YTtcbiAgICB2YXIgcHJvcGVydHkgPSB2b2lkIDA7XG5cbiAgICAvLyBJZiB0aGUgbmFtZSBoYXMgZG90cyBpbiBpdCwgXCJwZXJzb24ubmFtZVwiLCBsb29wIHRocm91Z2ggZWFjaCBvbmUuXG4gICAgaWYgKG5hbWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHByb3BlcnR5ID0gb2JqO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBvYmogPSBwcm9wZXJ0eTtcbiAgICAgICAgcHJvcGVydHkgPSBwcm9wZXJ0eVtuYW1lc1tpXV0gfHwgc3RyO1xuICAgICAgfVxuXG4gICAgICAvLyBPdGhlcndpc2UsIGl0J3MgYSBzaW1wbGUgYXNzaWdubWVudCBmcm9tIHRoZSBkYXRhIG9iamVjdC5cbiAgICB9IGVsc2Uge1xuICAgICAgcHJvcGVydHkgPSBvYmpbc3RyXTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGV5IHBhc3NlZCBhIGZ1bmN0aW9uLCB1c2UgdGhhdC5cbiAgICBpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gcHJvcGVydHkuY2FsbChvYmopO1xuICAgIH1cblxuICAgIC8vIFJldHVybiB0aGUgc3RyaW5nIGlmIGl0IGV4aXN0cy5cbiAgICBpZiAocHJvcGVydHkgIT09IHVuZGVmaW5lZCAmJiBwcm9wZXJ0eSAhPT0gbnVsbCAmJiBwcm9wZXJ0eSAhPT0gc3RyKSB7XG4gICAgICByZXR1cm4gcHJvcGVydHk7XG4gICAgfVxuXG4gICAgLy8gT3RoZXJ3aXNlLCByZXR1cm4gdGhlIG9yaWdpbmFsIHN0cmluZy5cbiAgICByZXR1cm4gc3RyO1xuICB9KTtcbn1cblxuLyoqXG4gKiBQYXJzZSB0aGUgdHJhbnNmb3JtIG1hdHJpeCBpbnRvIHggYW5kIHkgdHJhbnNsYXRpb24gdmFsdWVzLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUcmFuc2Zvcm0gbWF0cml4LCBvciBcIm5vbmVcIi5cbiAqIEByZXR1cm4ge3sgeDogbnVtYmVyLCB5OiBudW1iZXJ9fVxuICovXG5mdW5jdGlvbiBnZXRUcmFuc2xhdGUoc3RyKSB7XG4gIC8vIElmIG5vIHRyYW5zZm9ybSBpcyBzZXQsIHRoZSBjb21wdXRlZCB0cmFuc2Zvcm0gd2lsbCBiZSBcIm5vbmVcIi5cbiAgaWYgKHN0ciA9PT0gJ25vbmUnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgfVxuXG4gIHZhciBhcnJheSA9IHN0ci5tYXRjaCgvKC0/W1xcZC5dKykvZyk7XG4gIHJldHVybiB7XG4gICAgeDogcGFyc2VGbG9hdChhcnJheVs0XSksXG4gICAgeTogcGFyc2VGbG9hdChhcnJheVs1XSlcbiAgfTtcbn1cblxudmFyIGNvdW50ID0gMDtcbmZ1bmN0aW9uIHVuaXF1ZUlkKCkge1xuICBjb3VudCArPSAxO1xuICByZXR1cm4gJ29kby1jYXJvdXNlbCcgKyBjb3VudDtcbn1cblxuLyoqXG4gKiBGaW5kIGV2ZXJ5IGVsZW1lbnQgd2l0aGluIHRoZSBwYXJlbnQgd2hpY2ggaXMgZm9jdXNhYmxlIHZpYSB0YWJiaW5nIGFuZFxuICogZW5hYmxlL2Rpc2FibGUgaXQuIElkZWFsbHksIHNvbWUgcHJvcGVydHkgY291bGQgYmUgc2V0IG9uIHRoZSBwYXJlbnRcbiAqIGVsZW1lbnQgaXRzZWxmIHRvIHByZXZlbnQgdGFiYmluZyBpbnRvIGl0LiB2aXNpYmlsaXR5OmhpZGRlbiBhY2NvbXBsaXNoZXNcbiAqIHRoaXMsIGJ1dCB0aGVyZSBjYW4gYmUgc2xpZGVzIGluIHZpZXcgd2hpY2ggYXJlIG5vdCB0aGUgY3VycmVudCBzbGlkZS5cbiAqIEBwYXJhbSB7RWxlbWVudH0gcGFyZW50IEFuY2VzdG9yIGVsZW1lbnQgdG8gZGlzYWJsZSB0YWJiaW5nIGludG8uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNhbkZvY3VzIFdoZXRoZXIgdG8gZW5hYmxlIG9yIGRpc2FibGUgZm9jdXNhYmlsaXR5LlxuICovXG5mdW5jdGlvbiB0b2dnbGVGb2N1c2FiaWxpdHkocGFyZW50LCBjYW5Gb2N1cykge1xuICB2YXIgZm9jdXNhYmxlRWxlbWVudHMgPSAnYVtocmVmXSxidXR0b24sZGV0YWlscyxpZnJhbWUsaW5wdXQsdGV4dGFyZWEsc2VsZWN0LCpbdGFiaW5kZXhdJztcbiAgdmFyIGVsZW1lbnRzID0gQXJyYXkuZnJvbShwYXJlbnQucXVlcnlTZWxlY3RvckFsbChmb2N1c2FibGVFbGVtZW50cykpO1xuXG4gIC8vIFRlc3QgdGhlIHBhcmVudCBlbGVtZW50IGl0c2VsZi4gT2RvIEhlbHBlcnMgcG9seWZpbGxzIGBtYXRjaGVzYC5cbiAgaWYgKHBhcmVudC5tYXRjaGVzKGZvY3VzYWJsZUVsZW1lbnRzKSkge1xuICAgIGVsZW1lbnRzLnB1c2gocGFyZW50KTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSBlbGVtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChjYW5Gb2N1cykge1xuICAgICAgLy8gUHJlZmVyIHJlc2V0dGluZyB0aGUgdGFiSW5kZXggcHJvcGVydHkgYnkgdXNpbmcgcmVtb3ZlQXR0cmlidXRlIHRvIGxldHNcbiAgICAgIC8vIHRoZSBicm93c2VyIGRlY2lkZSBpZiBpdCBzaG91bGQgZ28gYmFjayB0byAwIChsaWtlIGlmIGl0IHdhcyBhIGJ1dHRvbilcbiAgICAgIC8vIG9yIHRvIC0xIGlmIGl0IHdhc24ndCBvcmlnaW5hbGx5IGZvY3VzYWJsZS5cbiAgICAgIGVsZW1lbnRzW2ldLnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudHNbaV0udGFiSW5kZXggPSAtMTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEEgVUkgQ29tcG9uZW50IGZvciBjcmVhdGluZyB2ZXJzYXRpbGUgY2Fyb3VzZWxzLiBUaGV5IGFyZVxuICogcGVmb3JtYW50LCBkcmFnZ2FibGUsIGFuZCBjYW4gaW5pbml0ZWx5IGxvb3AuXG4gKlxuICogQGF1dGhvciBHbGVuIENoZW5leSA8Z2xlbkBvZG9wb2QuY29tPlxuICovXG5cbnZhciBDYXJvdXNlbCA9IGZ1bmN0aW9uIChfVGlueUVtaXR0ZXIpIHtcbiAgaW5oZXJpdHMoQ2Fyb3VzZWwsIF9UaW55RW1pdHRlcik7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgVGhlIG91dGVybW9zdCBjYXJvdXNlbCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFuIG9wdGlvbnMgb2JqZWN0LlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBpZiBlbGVtZW50IGlzbid0IGFuIGVsZW1lbnQuXG4gICAqL1xuICBmdW5jdGlvbiBDYXJvdXNlbChlbGVtZW50KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENhcm91c2VsKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RpbnlFbWl0dGVyLmNhbGwodGhpcykpO1xuXG4gICAgaWYgKCEoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT2RvQ2Fyb3VzZWwgcmVxdWlyZXMgYW4gZWxlbWVudC4gR290OiBcIicgKyBlbGVtZW50ICsgJ1wiJyk7XG4gICAgfVxuXG4gICAgX3RoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBEZWVwIGNvcHkgZnJvbSB0aGUgZGVmYXVsdHMgYW5kIG92ZXJyaWRlIGRlZmF1bHRzIHdpdGggb3B0aW9ucyBwYXNzZWQgaW4uXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIF90aGlzLm9wdGlvbnMgPSBDYXJvdXNlbC5nZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgY2Fyb3VzZWwgaXMgdmVydGljYWwgb3IgaG9yaXpvbnRhbC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3RoaXMuaXNWZXJ0aWNhbCA9IF90aGlzLm9wdGlvbnMuaXNWZXJ0aWNhbDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBpcyBhIGxvb3BlZCBjYXJvdXNlbCB3aGljaCBpcyBub3QgYSBmYWRpbmcgY2Fyb3VzZWwuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgX3RoaXMuX2lzU2xpZGluZ0xvb3BlZCA9IF90aGlzLm9wdGlvbnMuaXNMb29wZWQgJiYgIV90aGlzLm9wdGlvbnMuaXNGYWRlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIERPTSBpbmRleCBvZiB0aGUgY3VycmVudCBzbGlkZSBlbGVtZW50IHdpdGhpbiB0aGUgc2xpZGVzJyBwYXJlbnQuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3RoaXMuZG9tSW5kZXggPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHByZXZpb3VzIGRvbUluZGV4IHZhbHVlLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF90aGlzLmxhc3REb21JbmRleCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGxvZ2ljYWwgaW5kZXguXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBfdGhpcy5fc2VsZWN0ZWRJbmRleCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2xpZGUgY29udGFpbmVyJ3MgcGFyZW50LlxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF90aGlzLl9zbGlkZUNvbnRhaW5lclBhcmVudEVsID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb250YWluZXIgZm9yIHRoZSBzbGlkZXMgYW5kIHRoZSBlbGVtZW50IHdoaWNoIGlzIG1vdmVkIGFyb3VuZCB3aXRoXG4gICAgICogdHJhbnNmb3JtcyBvciBhYnNvbHV0ZSBwb3NpdGlvbmluZy5cbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdGhpcy5fY2Fyb3VzZWxFbCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBzbGlkZXMgKGVsZW1lbnRzKSBpbiB0aGUgY2Fyb3VzZWwuXG4gICAgICogQHR5cGUge0FycmF5LjwhSFRNTEVsZW1lbnQ+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RoaXMuX3NsaWRlcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgY2Fyb3VzZWwgaXMgY3VycmVudGx5IHNraXBwaW5nIHNsaWRlcy4gRm9yIGV4YW1wbGUsIGdvaW5nIGZyb21cbiAgICAgKiBzbGlkZSAxIHRvIDMsIGEganVtcGluZyBjYXJvdXNlbCByZXBvc2l0aW9ucyB0aGUgc2xpZGVzIHNvIHRoYXQgMyBpcyBuZXh0XG4gICAgICogdG8gMSBhbmQgb25seSBoYXMgdG8gYW5pbWF0ZSBvbmUgc2xpZGUgbGVuZ3RoIHRvIGdldCB0byBpdC4gVGhpcyBmbGFnXG4gICAgICogaW5kaWNhdGVzIGEgc2xpZGUgaGFzIGJlZW4gcmVwb3NpdGlvbmVkLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RoaXMuX2lzSnVtcGVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBjYXJvdXNlbCBpcyBhYmxlIHRvIGJlIHVzZWQuIFRoaXMgY2FuIGJlIGNoYW5nZWQgd2l0aCB0aGVcbiAgICAgKiBgc2V0RW5hYmxlZGAgbWV0aG9kLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RoaXMuX2lzRW5hYmxlZCA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBUb3Agb3IgbGVmdC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RoaXMuX3Bvc0F0dHIgPSBfdGhpcy5pc1ZlcnRpY2FsID8gJ3RvcCcgOiAnbGVmdCc7XG5cbiAgICAvKipcbiAgICAgKiBvZmZzZXRUb3Agb3Igb2Zmc2V0TGVmdC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RoaXMuX29mZnNldFBvc2l0aW9uID0gJ29mZnNldCcgKyBjYXBpdGFsaXplKF90aGlzLl9wb3NBdHRyKTtcblxuICAgIC8qKlxuICAgICAqIEhlaWdodCBvciB3aWR0aC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RoaXMuX2RpbWVuc2lvbkF0dHIgPSBfdGhpcy5pc1ZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gICAgLyoqXG4gICAgICogVmFsdWUgdXNlZCBpbiBgdHJhbnNsYXRle1h8WX0oKWAuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBfdGhpcy5fdHJhbnNsYXRlQXhpcyA9IF90aGlzLmlzVmVydGljYWwgPyAnWScgOiAnWCc7XG5cbiAgICAvKipcbiAgICAgKiBBIGZsYWcgaW5kaWNhdGluZyB0aGF0IHRoZSBjYXJvdXNlbCBpcyBhbmltYXRpbmcuIEl0IGFsc28gd2lsbCBoYXZlXG4gICAgICogYSB0cmFuc2l0aW9uIGVuZCBldmVudCBsaXN0ZXIgYm91bmQgdG8gaXQgaWYgdGhlIGJyb3dzZXIgY2FuXG4gICAgICogdHJhbnNpdGlvbiB0cmFuc2Zvcm1zLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfdGhpcy5pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpZCByZXR1cm5lZCBmcm9tIG9uVHJhbnNpdGlvbkVuZCB3aGljaCBpcyB1c2VkIHRvIGNhbmNlbFxuICAgICAqIHRoZSB0cmFuc2l0aW9uZW5kIGxpc3RlbmVyLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgX3RoaXMuX3RyYW5zaXRpb25JZCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBJZiBhIHNlbGVjdG9yIGlzIHNwZWNpZmllZCwgZ290b1NsaWRlIHdpbGwgbG9vayBmb3IgdGhpcyBvbiB0aGUgbGFzdFxuICAgICAqIHNsaWRlIGFuZCBub3QgcmV2ZWFsIHVubmVjY2VzYXJ5IHdoaXRlc3BhY2UgdG8gdGhlIHJpZ2h0IG9mIHRoZSBsYXN0XG4gICAgICogbWF0Y2hlZCBlbGVtZW50LlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RoaXMuX2hhc1NsaWRlQ2hpbGRyZW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgdG8gdHJ1ZSBmb3IgYmVpbmcgYWJsZSB0byBkcmFnIHRoZSBjYXJvdXNlbCBiZXR3ZWVuIHNsaWRlcy5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF90aGlzLl9pc0RyYWdnYWJsZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBGbGFnIGluZGljYXRpbmcgZHJhZ2dpbmcgaGFzIGhhcHBlbmVkLiBJdCBpcyBzZXQgb24gZHJhZ21vdmUgYW5kIHJlc2V0XG4gICAgICogYWZ0ZXIgdGhlIGRyYWdnYWJsZWVuZCBldmVudCBoYXMgYmVlbiBkaXNwYXRjaGVkLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIF90aGlzLmhhc0RyYWdnZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGNhcm91c2VsIGlzIGF0IGEgcmVzdGluZyBwb3NpdGlvbiBvciBiZXR3ZWVuIHNsaWRlcy5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBfdGhpcy5faXNPZmZzZXQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEEgVGltZXIgdXNlZCB0byBtYWtlIHRoZSBjYXJvdXNlbCBhbiBhdXRvcGxheWluZyBzbGlkZXNob3cuXG4gICAgICogQHR5cGUge1RpbWVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RoaXMuX3RpbWVyID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRpbWUsIGluIG1pbGxpc2Vjb25kcywgdG8gd2FpdCBiZWZvcmUgYWRkaW5nIHplcm8gb3BhY2l0eSB0byB0aGUgc2xpZGUsXG4gICAgICogd2hpY2ggdHJpZ2dlcnMgdGhlIGNzcyB0cmFuc2l0aW9uLiB0aW1lb3V0ID0gc3BlZWQgLSAoc3BlZWQgKiAlKS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RoaXMuX2Nyb3NzZmFkZVRpbWVvdXQgPSBfdGhpcy5vcHRpb25zLmFuaW1hdGlvblNwZWVkIC0gX3RoaXMub3B0aW9ucy5hbmltYXRpb25TcGVlZCAqIF90aGlzLm9wdGlvbnMuY3Jvc3NmYWRlQW1vdW50O1xuXG4gICAgLyoqXG4gICAgICogV2hlbiBjYXJvdXNlbCBzbGlkZXMgYXJlIGNlbnRlcmVkLCB0aGV5IHdvbid0IGJlIGFsaWduZWQgd2l0aCB0aGUgc3RhcnRpbmdcbiAgICAgKiBlZGdlIG9mIHRoZSBjYXJvdXNlbCB3cmFwcGVyLiBUaGUgc3RhcnRpbmcgZWRnZSAocmVsYXRpdmUgemVybykgaXMgdXNlZFxuICAgICAqIHRvIGRldGVybWluZSB3aGljaCBzbGlkZSBpcyBjbG9zZXN0IHRvIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgX3RoaXMuX3N0YXJ0RWRnZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBEcmFnZ2FibGUgYXR0YWNoZWQgdG8gdGhlIGNhcm91c2VsIGVsZW1lbnQuIFVzZWQgZm9yIG5vbi1mYWRlIGNhcm91c2Vscy5cbiAgICAgKiBAdHlwZSB7T2RvRHJhZ2dhYmxlfVxuICAgICAqL1xuICAgIF90aGlzLmRyYWdnYWJsZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBQb2ludGVyIGF0dGFjaGVkIHRvIHRoZSBtYWluIGVsZW1lbnQuIFVzZWQgZm9yIGZhZGluZyBjYXJvdXNlbHMuXG4gICAgICogQHR5cGUge09kb1BvaW50ZXJ9XG4gICAgICovXG4gICAgX3RoaXMucG9pbnRlciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBDYXJvdXNlbHMgY29udGFpbmluZyBvbmx5IHR3byBzbGlkZXMgd2l0aCBsb29waW5nIGZ1bmN0aW9uYWxpdHkgYXJlIHNwZWNpYWxcbiAgICAgKiBjYXNlcy4gU2xpZGVzIG5lZWQgdG8gYmUgZHVwbGljYXRlZCBhbmQgcGFnaW5hdGlvbiBuZWVkcyB0byBiZSByZW5kZXJlZFxuICAgICAqIGRpZmZlcmVudGx5LiBUaGlzIGlzIGJlY2F1c2UgaW4gb3JkZXIgZm9yIHRoZSB1c2VyIHRvIG5hdmlnYXRlIGluIGVpdGhlclxuICAgICAqIGRpcmVjdGlvbiBmcm9tIHRoZSBhY3RpdmUgc2xpZGUsIHRoZSBzZWNvbmQgc2xpZGUgd291bGQgbmVlZCB0byBiZSBwcmVzZW50IGluXG4gICAgICogYm90aCB0aGUgJ3ByZXZpb3VzJyBhbmQgJ25leHQnIHBvc2l0aW9ucy4gJ0JpZGlyZWN0aW9uYWwnIHdpbGwgcmVmZXIgdG9cbiAgICAgKiBjYXJvdXNlbHMgd2l0aCBjb250ZW50IHRoYXQgdW5uYXR1cmFsbHkgZXhpc3RzIGZvciB0aGUgc2FrZSBvZiBuYXZpZ2F0aW9uYWxcbiAgICAgKiBwdXJwb3Nlcy5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBfdGhpcy5faXNCaWRpcmVjdGlvbmFsID0gZmFsc2U7XG5cbiAgICAvLyBEZXByZWNhdGVkIG1ldGhvZC5cbiAgICBfdGhpcy5yZXNldFN5bmMgPSBfdGhpcy5yZXNldDtcblxuICAgIC8vIEdvLlxuICAgIF90aGlzLmRlY29yYXRlKCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIGFuIGVsZW1lbnQgd2l0aGluIHRoaXMgY2xhc3MnIG1haW4gZWxlbWVudCBiYXNlZCBvbiBhIGNsYXNzIG5hbWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgQ2xhc3MgbmFtZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBbY29udGV4dF0gT3B0aW9uYWxseSBwcm92aWRlIHRoZSBjb250ZXh0IChzY29wZSlcbiAgICogICAgIGZvciB0aGUgcXVlcnkuIERlZmF1bHQgaXMgdGhlIG1haW4gZWxlbWVudCBvZiB0aGUgY2xhc3MuXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50W119IEFuIGFycmF5IHdoaWNoIG1heSBvciBtYXkgbm90IGNvbnRhaW4gdGhlIGVsZW1lbnRcbiAgICogICAgIHdoaWNoIHdhcyBzZWFyY2hlZCBmb3IuXG4gICAqL1xuXG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLmdldEVsZW1lbnRzQnlDbGFzcyA9IGZ1bmN0aW9uIGdldEVsZW1lbnRzQnlDbGFzcyhjbGFzc05hbWUpIHtcbiAgICB2YXIgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5lbGVtZW50O1xuXG4gICAgcmV0dXJuIEFycmF5LmZyb20oY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGNsYXNzTmFtZSkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBhbiBlbGVtZW50IGJ5IGl0cyBjbGFzcyBuYW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIENsYXNzIG5hbWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW2NvbnRleHRdIE9wdGluYWwgc2NvcGUgZm9yIHNlYXJjaC5cbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR8bnVsbH0gVGhlIGVsZW1lbnQgb3IgbnVsbCBpZiBpdCBpc24ndCBmb3VuZC5cbiAgICovXG5cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuZ2V0RWxlbWVudEJ5Q2xhc3MgPSBmdW5jdGlvbiBnZXRFbGVtZW50QnlDbGFzcyhjbGFzc05hbWUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRFbGVtZW50c0J5Q2xhc3MoY2xhc3NOYW1lLCBjb250ZXh0KVswXSB8fCBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNb2RpZnkgdGhlIERPTSB0byBiZSBhIGNhcm91c2VsLlxuICAgKi9cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5kZWNvcmF0ZSA9IGZ1bmN0aW9uIGRlY29yYXRlKCkge1xuICAgIHRoaXMuX3NhdmVEb21FbGVtZW50cygpO1xuXG4gICAgLy8gQWZ0ZXIgd2UgZGV0ZXJtaW5lIHRoZSBudW1iZXIgb2Ygc2xpZGVzLCB3ZSBoYXZlIGVub3VnaCBpbmZvcm1hdGlvbiB0byBkZWNpZGUgaWZcbiAgICAvLyB0aGlzIGNhcm91c2VsIHdpbGwgYmUgYSBzcGVjaWFsIGJpZGlyZWN0aW9uYWwgb25lLlxuICAgIGlmICh0aGlzLm9wdGlvbnMuaXNMb29wZWQgJiYgdGhpcy5fc2xpZGVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdGhpcy5fZGVjb3JhdGVCaWRpcmVjdGlvbmFsQ2Fyb3VzZWwoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zZXRBMTF5QXR0cmlidXRlcygpO1xuICAgIHRoaXMuX3JlbmRlclBhZGRsZXMoKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMucGFnaW5hdGlvbikge1xuICAgICAgdGhpcy5fcmVuZGVyUGFnaW5hdGlvbigpO1xuICAgIH1cblxuICAgIHRoaXMuX3NhdmVSZW5kZXJlZEVsZW1lbnRzKCk7XG5cbiAgICB0aGlzLl9zZXRTbGlkZUluZGljZXMoKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuaXNGYWRlKSB7XG4gICAgICB0aGlzLl9kZWNvcmF0ZUZhZGVDYXJvdXNlbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kZWNvcmF0ZVJlZ3VsYXJDYXJvdXNlbCgpO1xuICAgIH1cblxuICAgIHRoaXMuX29uQ2xpY2sgPSB0aGlzLl9oYW5kbGVDbGljay5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uQ2xpY2spO1xuXG4gICAgLy8gU2V0IHRoZSBzZWxlY3RlZCBpbmRleCB3aXRob3V0IGFuaW1hdGlvbi5cbiAgICB0aGlzLnNldFNlbGVjdGVkSW5kZXgodGhpcy5fZ2V0U2FmZUluZGV4KHRoaXMub3B0aW9ucy5zdGFydEluZGV4KSwgdHJ1ZSk7XG5cbiAgICAvLyBDaGFuZ2VzIHZpZXdwb3J0LCBzbyBpdCBuZWVkcyB0byBjb21lIGFmdGVyIHRoZSBnb3RvIHplcm8uXG4gICAgaWYgKHRoaXMuX2lzU2xpZGluZ0xvb3BlZCkge1xuICAgICAgdGhpcy5fc2V0TmVpZ2hib3JTbGlkZXMoKTtcbiAgICAgIHRoaXMuX3NuYXBUb0N1cnJlbnRTbGlkZSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2xpZGluZyAocmVndWxhcikgY2Fyb3VzZWxzIG5lZWRzIGEgZmV3IG1vcmUgc3R5bGVzIGFuZCBldmVudHMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLl9kZWNvcmF0ZVJlZ3VsYXJDYXJvdXNlbCA9IGZ1bmN0aW9uIF9kZWNvcmF0ZVJlZ3VsYXJDYXJvdXNlbCgpIHtcbiAgICAvLyBBZGQgZWFzaW5nIHRvIGNvbnRhaW5lclxuICAgIHRoaXMuX2Nhcm91c2VsRWwuc3R5bGVbT2RvRGV2aWNlLkRvbS5UUkFOU0lUSU9OX1BST1BFUlRZXSA9IE9kb0RldmljZS5Dc3MuVFJBTlNGT1JNO1xuICAgIHRoaXMuX2Nhcm91c2VsRWwuc3R5bGVbT2RvRGV2aWNlLkRvbS5UUkFOU0lUSU9OX1RJTUlOR19GVU5DVElPTl0gPSB0aGlzLm9wdGlvbnMuZWFzaW5nO1xuXG4gICAgdGhpcy5faGFzU2xpZGVDaGlsZHJlbiA9IHRoaXMuX2dldFNsaWRlQ2hpbGRyZW4oKS5sZW5ndGggPiAwO1xuXG4gICAgdGhpcy5iaW5kRHJhZ0V2ZW50cygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTbGlkaW5nIChyZWd1bGFyKSBjYXJvdXNlbHMgbmVlZHMgYSBmZXcgbW9yZSBzdHlsZXMgYW5kIGV2ZW50cy5cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuX2RlY29yYXRlRmFkZUNhcm91c2VsID0gZnVuY3Rpb24gX2RlY29yYXRlRmFkZUNhcm91c2VsKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSBmYWxzZTtcblxuICAgIC8vIEFkZCB0cmFuc2l0aW9ucyB0byBlYWNoIHNsaWRlLlxuICAgIHRoaXMuZ2V0U2xpZGVzKCkuZm9yRWFjaChmdW5jdGlvbiAoc2xpZGUsIGkpIHtcbiAgICAgIHNsaWRlLnN0eWxlW09kb0RldmljZS5Eb20uVFJBTlNJVElPTl0gPSAnb3BhY2l0eSAnICsgX3RoaXMyLm9wdGlvbnMuYW5pbWF0aW9uU3BlZWQgKyAnbXMgbGluZWFyJztcblxuICAgICAgLy8gVGhlIGZpcnN0IHNsaWRlIG5lZWRzIHRvIGhhdmUgdGhlIHZpc2libGUgY2xhc3MuXG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICBzbGlkZS5jbGFzc0xpc3QuYWRkKENhcm91c2VsLkNsYXNzZXMuVklTSUJMRSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmJpbmRTd2lwZUV2ZW50cygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIHVwIHRoZSBhZGRpdGlvbmFsIERPTSBtb2RpZmljYXRpb25zIHRoYXQgd2lsbCBiZSBuZWVkZWQgZm9yIGJpZGlyZWN0aW9uYWxcbiAgICogY2Fyb3VzZWxzLiBXZSB3aWxsIGVzc2VudGlhbGx5IGJlIGR1cGxpY2F0aW5nIGJvdGggY2Fyb3VzZWwgc2xpZGVzIHNvIHRoYXQgbm9cbiAgICogbWF0dGVyIHRoZSBjdXJyZW50IGluZGV4LCB0aGUgYWN0aXZlIHNsaWRlIHdpbGwgYWx3YXkgaGF2ZSBuZWlnaGJvcnMgb24gZWl0aGVyIHNpZGUuXG4gICAqIFRoZW4gbGF0ZXIgb24sIHdlIGhpZGUgdGhlIGFkZGl0aW9uYWwgcGFnaW5hdGlvbi5cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuX2RlY29yYXRlQmlkaXJlY3Rpb25hbENhcm91c2VsID0gZnVuY3Rpb24gX2RlY29yYXRlQmlkaXJlY3Rpb25hbENhcm91c2VsKCkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgLy8gQmlkaXJlY3Rpb25hbCBjYXJvdXNlbHMgYXV0b21hdGljYWxseSB3aWxsIG5lZWQgdG8gYmVjb21lIGEganVtcGVkIGNhcm91c2VscyxcbiAgICAvLyBzaW5jZSB3ZSB3aWxsIGJlIGFkZGluZyBhcnRpZmljaWFsIHNsaWRlcyB0aGF0IHJ1aW4gbmF0dXJhbCBuYXZpZ2F0aW9uLlxuICAgIHRoaXMuX2lzQmlkaXJlY3Rpb25hbCA9IHRydWU7XG4gICAgdGhpcy5faXNKdW1wZWQgPSB0cnVlO1xuXG4gICAgLy8gVHVybiAyIHNsaWRlcyBpbnRvIDQuXG4gICAgdGhpcy5fc2xpZGVzLmZvckVhY2goZnVuY3Rpb24gKHNsaWRlKSB7XG4gICAgICBfdGhpczMuZ2V0Q2Fyb3VzZWxFbGVtZW50KCkuYXBwZW5kQ2hpbGQoc2xpZGUuY2xvbmVOb2RlKHRydWUpKTtcbiAgICB9KTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgZ2xvYmFsIHNsaWRlcyB2YXJpYWJsZSB0byBpbmNsdWRlIHRoZSBuZXcgZWxlbWVudHMuXG4gICAgdGhpcy5fc2xpZGVzID0gdGhpcy5nZXRFbGVtZW50c0J5Q2xhc3MoQ2Fyb3VzZWwuQ2xhc3Nlcy5TTElERSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCBzdGF0aWMgYWNjZXNzaWJpbGl0eSBhdHRyaWJ1dGVzLlxuICAgKi9cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5fc2V0QTExeUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiBfc2V0QTExeUF0dHJpYnV0ZXMoKSB7XG4gICAgdGhpcy5nZXRXcmFwcGVyKCkuc2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnLCAncG9saXRlJyk7XG4gICAgdGhpcy5nZXRDYXJvdXNlbEVsZW1lbnQoKS5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnbGlzdCcpO1xuICAgIHRoaXMuZ2V0U2xpZGVzKCkuZm9yRWFjaChmdW5jdGlvbiAoc2xpZGUpIHtcbiAgICAgIGdpdmVJZChzbGlkZSwgdW5pcXVlSWQpO1xuICAgICAgc2xpZGUuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2xpc3RpdGVtJyk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBzdGF0aWMgYWNjZXNzaWJpbGl0eSBhdHRyaWJ1dGVzLlxuICAgKi9cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5fcmVtb3ZlQTExeUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiBfcmVtb3ZlQTExeUF0dHJpYnV0ZXMoKSB7XG4gICAgdGhpcy5nZXRXcmFwcGVyKCkucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWxpdmUnKTtcbiAgICB0aGlzLmdldENhcm91c2VsRWxlbWVudCgpLnJlbW92ZUF0dHJpYnV0ZSgncm9sZScpO1xuICAgIHRoaXMuZ2V0U2xpZGVzKCkuZm9yRWFjaChmdW5jdGlvbiAoc2xpZGUpIHtcbiAgICAgIHNsaWRlLnJlbW92ZUF0dHJpYnV0ZSgncm9sZScpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdG9yZSByZWZlcmVuY2VzIHRvIGNvbW1vbmx5IHVzZWQgRE9NIGVsZW1lbnRzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5fc2F2ZURvbUVsZW1lbnRzID0gZnVuY3Rpb24gX3NhdmVEb21FbGVtZW50cygpIHtcbiAgICAvLyBFbGVtZW50IHdoaWNoIHdyYXBzIHRoZSBlbGVtZW50IHdoaWNoIGNvbnRhaW5zIGFsbCB0aGUgc2xpZGVzLlxuICAgIHRoaXMuX3NsaWRlQ29udGFpbmVyUGFyZW50RWwgPSB0aGlzLmdldEVsZW1lbnRCeUNsYXNzKENhcm91c2VsLkNsYXNzZXMuV1JBUFBFUik7XG5cbiAgICAvLyBFbGVtZW50IHdoaWNoIGNvbnRhaW5zIGFsbCB0aGUgc2xpZGVzLlxuICAgIHRoaXMuX2Nhcm91c2VsRWwgPSB0aGlzLmdldEVsZW1lbnRCeUNsYXNzKENhcm91c2VsLkNsYXNzZXMuQ0FST1VTRUxfRUxFTUVOVCk7XG5cbiAgICAvLyBCZWNhdXNlIGNhcm91c2VscyBjYW4gaGF2ZSBjYXJvdXNlbHMgaW5zaWRlIHRoZW0sIGZpbmRpbmcgZWxlbWVudHMgYnlcbiAgICAvLyBjbGFzcyByZXRyaWV2ZXMgdG9vIG1hbnkgZWxlbWVudHMuXG4gICAgdGhpcy5fc2xpZGVzID0gdGhpcy5nZXRFbGVtZW50c0J5Q2xhc3MoQ2Fyb3VzZWwuQ2xhc3Nlcy5TTElERSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0b3JlIHJlZmVyZW5jZXMgdG8gZ2VuZXJhdGVkIGVsZW1lbnRzLiBUaGUgcGFnaW5hdGlvbiBkb3RzIGNhbm5vdCBiZSBzYXZlIGluXG4gICAqIGBfc2F2ZURvbUVsZW1lbnRzYCBiZWNhdXNlIHRoZSBudW1iZXIgb2Ygc2xpZGVzIGlzIG5vdCB5ZXQga25vd24uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLl9zYXZlUmVuZGVyZWRFbGVtZW50cyA9IGZ1bmN0aW9uIF9zYXZlUmVuZGVyZWRFbGVtZW50cygpIHtcbiAgICB0aGlzLl9wYWRkbGVQcmV2aW91cyA9IHRoaXMuZ2V0RWxlbWVudEJ5Q2xhc3MoQ2Fyb3VzZWwuQ2xhc3Nlcy5QQURETEVfUFJFVik7XG4gICAgdGhpcy5fcGFkZGxlTmV4dCA9IHRoaXMuZ2V0RWxlbWVudEJ5Q2xhc3MoQ2Fyb3VzZWwuQ2xhc3Nlcy5QQURETEVfTkVYVCk7XG4gICAgdGhpcy5fcGFnaW5hdGlvbkRvdHMgPSB0aGlzLmdldEVsZW1lbnRzQnlDbGFzcyhDYXJvdXNlbC5DbGFzc2VzLlBBR0lOQVRJT05fRE9UKS5tYXAoZnVuY3Rpb24gKGRvdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG90OiBkb3QsXG4gICAgICAgIGk6IHBhcnNlSW50KGRvdC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaW5kZXgnKSwgMTApLFxuICAgICAgICBpMjogcGFyc2VJbnQoZG90LmdldEF0dHJpYnV0ZSgnZGF0YS1zZWNvbmRhcnktaW5kZXgnKSwgMTApXG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgbmF2aWdhdGlvbiBwYWRkbGVzIChwcmV2aW91cyBhbmQgbmV4dCBidXR0b25zKSB0byB0aGUgY2Fyb3VzZWwuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLl9yZW5kZXJQYWRkbGVzID0gZnVuY3Rpb24gX3JlbmRlclBhZGRsZXMoKSB7XG4gICAgdGhpcy5lbGVtZW50Lmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgdGhpcy5fZ2V0TmF2UGFkZGxlSHRtbCgpKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIG5hdmlnYXRpb24gcGFkZGxlcyBmcm9tIHRoZSBjYXJvdXNlbCAoaWYgdGhleSBleGlzdCkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLl9yZW1vdmVQYWRkbGVzID0gZnVuY3Rpb24gX3JlbW92ZVBhZGRsZXMoKSB7XG4gICAgdGhpcy5fcmVtb3ZlQnlDbGFzcyhDYXJvdXNlbC5DbGFzc2VzLlBBRERMRVMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBjaGlsZCBlbGVtZW50IGJ5IGNsYXNzLCBpZiBpdCBleGlzdHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgQ2xhc3MgbmFtZSBvZiB0aGUgZWxlbWVudCB0byBmaW5kIGFuZCByZW1vdmUuXG4gICAqL1xuXG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLl9yZW1vdmVCeUNsYXNzID0gZnVuY3Rpb24gX3JlbW92ZUJ5Q2xhc3MoY2xhc3NOYW1lKSB7XG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLmdldEVsZW1lbnRCeUNsYXNzKGNsYXNzTmFtZSk7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgaHRtbCBzdHJpbmcgZm9yIHRoZSBuYXYgcGFkZGxlcyBmcm9tIHRoZSB0ZW1wbGF0ZXMuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gQSBzdHJpbmcgb2YgaHRtbC5cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuX2dldE5hdlBhZGRsZUh0bWwgPSBmdW5jdGlvbiBfZ2V0TmF2UGFkZGxlSHRtbCgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5nZXROYXZQYWRkbGVIdG1sID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmdldE5hdlBhZGRsZUh0bWwuY2FsbCh0aGlzLCB0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gQ2Fyb3VzZWwudGVtcGxhdGUodGhpcy5vcHRpb25zLnRlbXBsYXRlLnBhZGRsZXMsIHtcbiAgICAgIHByZXY6IENhcm91c2VsLnRlbXBsYXRlKHRoaXMub3B0aW9ucy50ZW1wbGF0ZS5wYWRkbGVQcmV2LCB7XG4gICAgICAgIHBhZGRsZUlubmVyOiB0aGlzLm9wdGlvbnMudGVtcGxhdGUucGFkZGxlUHJldklubmVyXG4gICAgICB9KSxcbiAgICAgIG5leHQ6IENhcm91c2VsLnRlbXBsYXRlKHRoaXMub3B0aW9ucy50ZW1wbGF0ZS5wYWRkbGVOZXh0LCB7XG4gICAgICAgIHBhZGRsZUlubmVyOiB0aGlzLm9wdGlvbnMudGVtcGxhdGUucGFkZGxlTmV4dElubmVyXG4gICAgICB9KVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgcGFnaW5hdGlvbiAodGhlIGRvdHMpIHRvIHRoZSBjYXJvdXNlbC5cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuX3JlbmRlclBhZ2luYXRpb24gPSBmdW5jdGlvbiBfcmVuZGVyUGFnaW5hdGlvbigpIHtcbiAgICB0aGlzLmVsZW1lbnQuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCB0aGlzLl9nZXRQYWdpbmF0aW9uSHRtbCgpKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHBhZ2luYXRpb24gZnJvbSB0aGUgY2Fyb3VzZWwgKGlmIHRoZXkgZXhpc3QpLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5fcmVtb3ZlUGFnaW5hdGlvbiA9IGZ1bmN0aW9uIF9yZW1vdmVQYWdpbmF0aW9uKCkge1xuICAgIHRoaXMuX3JlbW92ZUJ5Q2xhc3MoQ2Fyb3VzZWwuQ2xhc3Nlcy5QQUdJTkFUSU9OKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBodG1sIHN0cmluZyBmb3IgdGhlIHBhZ2luYXRpb24gZnJvbSB0aGUgdGVtcGxhdGVzLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEEgc3RyaW5nIG9mIGh0bWwuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLl9nZXRQYWdpbmF0aW9uSHRtbCA9IGZ1bmN0aW9uIF9nZXRQYWdpbmF0aW9uSHRtbCgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5nZXRQYWdpbmF0aW9uSHRtbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5nZXRQYWdpbmF0aW9uSHRtbC5jYWxsKHRoaXMsIHRoaXMpO1xuICAgIH1cblxuICAgIHZhciBkb3RzID0gdGhpcy5fYnVpbGRQYWdpbmF0aW9uSHRtbCgpO1xuXG4gICAgcmV0dXJuIENhcm91c2VsLnRlbXBsYXRlKHRoaXMub3B0aW9ucy50ZW1wbGF0ZS5wYWdpbmF0aW9uLCB7XG4gICAgICBkb3RzOiBkb3RzXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyBhbmQgcmV0dXJucyB0aGUgSFRNTCBzdHJpbmcgb2YgdGhlIHBhZ2luYXRpb24gZG90cy5cbiAgICogQmlkaXJlY3Rpb25hbCBjYXJvdXNlbHMgdXRpbGl6ZSBhIHNlcGFyYXRlIHRlbXBsYXRlIHRoYXQgaW5jbHVkZXNcbiAgICogc2Vjb25kYXJ5IGluZGljZXMuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuX2J1aWxkUGFnaW5hdGlvbkh0bWwgPSBmdW5jdGlvbiBfYnVpbGRQYWdpbmF0aW9uSHRtbCgpIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgIHZhciB0ZW1wbGF0ZSQkMSA9IHRoaXMuX2lzQmlkaXJlY3Rpb25hbCA/IHRoaXMub3B0aW9ucy50ZW1wbGF0ZS5wYWdpbmF0aW9uRG90U2Vjb25kYXJ5IDogdGhpcy5vcHRpb25zLnRlbXBsYXRlLnBhZ2luYXRpb25Eb3Q7XG5cbiAgICByZXR1cm4gdGhpcy5nZXRTbGlkZXMoKS5yZWR1Y2UoZnVuY3Rpb24gKGRvdHNIdG1sLCBzbGlkZSwgaSwgYXJyKSB7XG4gICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICAgIGluZGV4MTogaSArIDEsXG4gICAgICAgIHNsaWRlSWQ6IHNsaWRlLmlkXG4gICAgICB9O1xuXG4gICAgICBpZiAoX3RoaXM0Ll9pc0JpZGlyZWN0aW9uYWwpIHtcbiAgICAgICAgLy8gSWYgeW91IGFyZSByZW5kZXJpbmcgcGFnaW5hdGlvbiBmb3IgYSBiaWRpcmVjdGlvbmFsIGNhcm91c2VsLCB5b3Ugd2lsbCBuZWVkXG4gICAgICAgIC8vIHNlY29uZGFyeSBpbmRpY2VzIGNvbXB1dGVkLiBUaGlzIHJldHVybnMgdGhlIHNlY29uZGFyeSBpbmRleCBiYXNlZCBvbiB0aGUgcHJpbWFyeS5cbiAgICAgICAgLy8gaS5lLiBGb3IgNCBzbGlkZXMsIDEgcmV0dXJucyAzLCAyIHJldHVybnMgNCBhbmQgdGhlIGludmVyc2UuXG4gICAgICAgIGRhdGEuc2Vjb25kYXJ5SW5kZXggPSBpID4gMSA/IGkgJSAyIDogaSArIDI7XG4gICAgICAgIGRhdGEuaGlkZGVuID0gaSA+PSBhcnIubGVuZ3RoIC8gMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRvdHNIdG1sICsgQ2Fyb3VzZWwudGVtcGxhdGUodGVtcGxhdGUkJDEsIGRhdGEpO1xuICAgIH0sICcnKTtcbiAgfTtcblxuICAvKipcbiAgICogTGlzdGVuIGZvciBkcmFnZ2luZyBldmVudHMuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuYmluZERyYWdFdmVudHMgPSBmdW5jdGlvbiBiaW5kRHJhZ0V2ZW50cygpIHtcbiAgICB0aGlzLmRyYWdnYWJsZSA9IG5ldyBPZG9EcmFnZ2FibGUodGhpcy5fY2Fyb3VzZWxFbCwge1xuICAgICAgYXhpczogdGhpcy5pc1ZlcnRpY2FsID8gT2RvUG9pbnRlci5BeGlzLlkgOiBPZG9Qb2ludGVyLkF4aXMuWFxuICAgIH0pO1xuXG4gICAgdGhpcy5fb25EcmFnU3RhcnQgPSB0aGlzLl9oYW5kbGVEcmFnU3RhcnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkRyYWdNb3ZlID0gdGhpcy5faGFuZGxlRHJhZ01vdmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkRyYWdFbmQgPSB0aGlzLl9oYW5kbGVEcmFnRW5kLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLmRyYWdnYWJsZS5vbihPZG9EcmFnZ2FibGUuRXZlbnRUeXBlLlNUQVJULCB0aGlzLl9vbkRyYWdTdGFydCk7XG4gICAgdGhpcy5kcmFnZ2FibGUub24oT2RvRHJhZ2dhYmxlLkV2ZW50VHlwZS5NT1ZFLCB0aGlzLl9vbkRyYWdNb3ZlKTtcbiAgICB0aGlzLmRyYWdnYWJsZS5vbihPZG9EcmFnZ2FibGUuRXZlbnRUeXBlLkVORCwgdGhpcy5fb25EcmFnRW5kKTtcbiAgfTtcblxuICAvKipcbiAgICogTGlzdGVuIGZvciB0aGUgcG9pbnRlciB0byBjb21lIHVwIGZyb20gdGhlIHNjcmVlbiwgdGhlbiBleGVjdXRlIGEgY2FsbGJhY2suXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuYmluZFN3aXBlRXZlbnRzID0gZnVuY3Rpb24gYmluZFN3aXBlRXZlbnRzKCkge1xuICAgIHRoaXMucG9pbnRlciA9IG5ldyBPZG9Qb2ludGVyKHRoaXMuX2Nhcm91c2VsRWwsIHtcbiAgICAgIGF4aXM6IE9kb1BvaW50ZXIuQXhpcy5YLFxuICAgICAgcHJldmVudEV2ZW50RGVmYXVsdDogdHJ1ZVxuICAgIH0pO1xuXG4gICAgdGhpcy5fb25Qb2ludGVyRW5kID0gdGhpcy5faGFuZGxlUG9pbnRlckVuZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMucG9pbnRlci5vbihPZG9Qb2ludGVyLkV2ZW50VHlwZS5FTkQsIHRoaXMuX29uUG9pbnRlckVuZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIHNsaWRlIHRvIHRoZSBlbmQgb2YgdGhlIGNhcm91c2VsLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2xpZGVIdG1sIEh0bWwgc3RyaW5nIGZvciB0aGUgc2xpZGUuXG4gICAqL1xuXG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLmFkZFNsaWRlID0gZnVuY3Rpb24gYWRkU2xpZGUoc2xpZGVIdG1sKSB7XG4gICAgLy8gTWFrZSBzdXJlIGxvb3BlZCBjYXJvdXNlbHMgYXJlIGluIHRoZSByaWdodCBvcmRlciB3aXRob3V0IGFueSBuZWlnaGJvcnMuXG4gICAgdGhpcy5fc2V0U2xpZGVzVG9Mb2dpY2FsT3JkZXIoKTtcblxuICAgIC8vIEluc2VydCBuZXcgc2xpZGUgYXQgdGhlIGVuZC5cbiAgICB0aGlzLl9jYXJvdXNlbEVsLmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgc2xpZGVIdG1sKTtcblxuICAgIHRoaXMucmVzZXQoKTtcbiAgfTtcblxuICAvKipcbiAgICogU3luY2hyb25vdXNseSByZXNldCB0aGUgc2xpZGVzLiBVc2UgdGhpcyB3aGVuIHlvdSdyZSBzdXJlIHRoZSBlbGVtZW50c1xuICAgKiB3aXRoaW4gdGhlIGNhcm91c2VsIGFyZSBkb25lIGNoYW5naW5nLlxuICAgKi9cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIC8vIFVwZGF0ZSB0aGUgc2xpZGVzLlxuICAgIHRoaXMuX3NhdmVEb21FbGVtZW50cygpO1xuXG4gICAgLy8gUmVtb3ZlIG9sZCBwYWRkbGVzICsgcGFnaW5hdGlvbi5cbiAgICB0aGlzLl9yZW1vdmVQYWRkbGVzKCk7XG4gICAgdGhpcy5fcmVtb3ZlUGFnaW5hdGlvbigpO1xuXG4gICAgdGhpcy5fc2V0QTExeUF0dHJpYnV0ZXMoKTtcblxuICAgIC8vIFJlLXJlbmRlciBwYWRkbGVzIGFuZCBwYWdpbmF0aW9uLlxuICAgIHRoaXMuX3JlbmRlclBhZGRsZXMoKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnBhZ2luYXRpb24pIHtcbiAgICAgIHRoaXMuX3JlbmRlclBhZ2luYXRpb24oKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zYXZlUmVuZGVyZWRFbGVtZW50cygpO1xuXG4gICAgLy8gVXBkYXRlIHNsaWRlIGluZGljZXMgbm93IHRoYXQgdGhlcmUncyBhIG5ldyBzbGlkZS5cbiAgICB0aGlzLl9zZXRTbGlkZUluZGljZXMoKTtcblxuICAgIC8vIEdvIHRvIHRoZSBzbGlkZSBpdCB3YXMgYXQgYmVmb3JlLlxuICAgIHZhciBzZWxlY3RlZCA9IHRoaXMuZ2V0U2VsZWN0ZWRJbmRleCgpO1xuICAgIHRoaXMuc2V0U2VsZWN0ZWRJbmRleCgwLCB0cnVlKTtcblxuICAgIC8vIFRyeSBnb2luZyBiYWNrIHRvIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgdGhpcy5zZXRTZWxlY3RlZEluZGV4KHNlbGVjdGVkLCB0cnVlKTtcblxuICAgIC8vIFNldCBuZWlnaGJvcnMgc2xpZGVzIGZvciBsb29wZWQgY2Fyb3VzZWxzLlxuICAgIGlmICh0aGlzLl9pc1NsaWRpbmdMb29wZWQpIHtcbiAgICAgIHRoaXMuX3NldE5laWdoYm9yU2xpZGVzKCk7XG4gICAgICB0aGlzLl9zbmFwVG9DdXJyZW50U2xpZGUoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJlaXZlcyB0aGUgY2FjaGVkIGNhcm91c2VsIHdyYXBwZXIgZWxlbWVudC5cbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gICAqL1xuXG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLmdldFdyYXBwZXIgPSBmdW5jdGlvbiBnZXRXcmFwcGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9zbGlkZUNvbnRhaW5lclBhcmVudEVsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyZWl2ZXMgdGhlIGNhY2hlZCBjYXJvdXNlbCBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICovXG5cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuZ2V0Q2Fyb3VzZWxFbGVtZW50ID0gZnVuY3Rpb24gZ2V0Q2Fyb3VzZWxFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9jYXJvdXNlbEVsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcnJheSBvZiBzbGlkZXMgaW4gdGhlIGNhcm91c2VsLlxuICAgKiBAcmV0dXJuIHshQXJyYXkuPCFIVE1MRWxlbWVudD59IFRoZSBzbGlkZXMgYXJyYXkuXG4gICAqL1xuXG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLmdldFNsaWRlcyA9IGZ1bmN0aW9uIGdldFNsaWRlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2xpZGVzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNsaWRlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGxvZ2ljYWwgaW5kZXggb2YgdGhlIHNsaWRlIHlvdSB3YW50LlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gVGhlIHNsaWRlIGVsZW1lbnQuXG4gICAqL1xuXG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLmdldFNsaWRlID0gZnVuY3Rpb24gZ2V0U2xpZGUoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTbGlkZXMoKVtpbmRleF07XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaW5kZXggb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgc2xpZGUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gSW5kZXggb2YgdGhlIGN1cnJlbnQgc2xpZGUuXG4gICAqL1xuXG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLmdldFNlbGVjdGVkSW5kZXggPSBmdW5jdGlvbiBnZXRTZWxlY3RlZEluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZEluZGV4O1xuICB9O1xuXG4gIC8qKlxuICAgKiBUcmFuc2xhdGVzIHRoZSBvcmlnaW5hbCBpbmRleCB0byB0aGUgY3VycmVudCBET00gaW5kZXguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsb2dpY2FsSW5kZXggVGhlIG9yaWdpbmFsIGluZGV4IG9mIHRoZSBzbGlkZSB0byBnZXQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gSW5kZXggb2YgdGhlIHNsaWRlICh6ZXJvIGJhc2VkKS5cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuX2dldERvbUluZGV4ID0gZnVuY3Rpb24gX2dldERvbUluZGV4KGxvZ2ljYWxJbmRleCkge1xuICAgIHJldHVybiB0aGlzLmdldFNsaWRlSW5kaWNlcygpLmluZGV4T2YobG9naWNhbEluZGV4KTtcbiAgfTtcblxuICAvKipcbiAgICogVHJhbnNsYXRlcyB0aGUgRE9NIGluZGV4IHRvIHRoZSBvcmlnaW5hbCBsb2dpY2FsIGluZGV4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gZG9tSW5kZXggVGhlIG9yaWdpbmFsIGluZGV4IG9mIHRoZSBzbGlkZSB0byBnZXQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gSW5kZXggb2YgdGhlIHNsaWRlICh6ZXJvIGJhc2VkKS5cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuX2dldExvZ2ljYWxJbmRleCA9IGZ1bmN0aW9uIF9nZXRMb2dpY2FsSW5kZXgoZG9tSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTbGlkZUluZGljZXMoKVtkb21JbmRleF07XG4gIH07XG5cbiAgLyoqXG4gICAqIFRha2VzIGEgbG9naWNhbCBpbmRleCB3aGljaCBjb3VsZCBwb3RlbnRpYWxseSBiZSBvdXQgb2YgcmFuZ2UgYW5kIHJldHVybnNcbiAgICogdGhlIGxvZ2ljYWwgaW5kZXggd2l0aGluIHJhbmdlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbG9naWNhbEluZGV4IExvZ2ljYWwgaW5kZXggdG8gbWFrZSBzYWZlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFNhZmUgbG9naWNhbCBpbmRleC5cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuX2dldFNhZmVJbmRleCA9IGZ1bmN0aW9uIF9nZXRTYWZlSW5kZXgobG9naWNhbEluZGV4KSB7XG4gICAgaWYgKHRoaXMuaXNJbmRleE91dE9mUmFuZ2UobG9naWNhbEluZGV4KSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5pc0xvb3BlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UmVsYXRpdmVJbmRleChsb2dpY2FsSW5kZXgsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY2xhbXBJbmRleFRvU2xpZGVzKGxvZ2ljYWxJbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBsb2dpY2FsSW5kZXg7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIG9mZnNldCBpbmRleCBmb3IgYSBjaXJjdWxhciBsaXN0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggU3RhcnRpbmcgaW5kZXguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkaXNwbGFjZW1lbnQgT2Zmc2V0IGZyb20gdGhlIHN0YXJ0aW5nIGluZGV4LiBDYW4gYmUgbmVnYXRpdmVcbiAgICogICAgIG9yIHBvc2l0aXZlLiBGb3IgZXhhbXBsZSwgLTIgb3IgMi5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW5kZXggb2YgdGhlIHJlbGF0aXZlIGRpc3BsYWNlbWVudCwgd3JhcHBpbmcgYXJvdW5kXG4gICAqICAgICB0aGUgZW5kIG9mIHRoZSBsaXN0IHRvIHRoZSBzdGFydCB3aGVuIHRoZSBkaXNwbGFjZW1lbnQgaXMgbGFyZ2VyIHRoYW5cbiAgICogICAgIHdoYXQncyBsZWZ0IGluIHRoZSBsaXN0LlxuICAgKi9cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5fZ2V0UmVsYXRpdmVJbmRleCA9IGZ1bmN0aW9uIF9nZXRSZWxhdGl2ZUluZGV4KGluZGV4LCBkaXNwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gd3JhcEFyb3VuZExpc3QoaW5kZXgsIGRpc3BsYWNlbWVudCwgdGhpcy5fc2xpZGVzLmxlbmd0aCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIGEgZ2l2ZW4gaW5kZXggaXMgb3V0IG9mIHJhbmdlIG9mIHRoZSBjYXJvdXNlbC5cbiAgICovXG5cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuaXNJbmRleE91dE9mUmFuZ2UgPSBmdW5jdGlvbiBpc0luZGV4T3V0T2ZSYW5nZShpbmRleCkge1xuICAgIHJldHVybiBpbmRleCA8PSAtMSB8fCBpbmRleCA+PSB0aGlzLl9zbGlkZXMubGVuZ3RoO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb25zdHJhaW4gYW4gaW5kZXggd2l0aGluIGJvdW5kcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IHRvIGNsYW1wLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuXG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLmNsYW1wSW5kZXhUb1NsaWRlcyA9IGZ1bmN0aW9uIGNsYW1wSW5kZXhUb1NsaWRlcyhpbmRleCkge1xuICAgIHJldHVybiBjbGFtcChpbmRleCwgMCwgdGhpcy5fc2xpZGVzLmxlbmd0aCAtIDEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBjYXJvdXNlbCBpcyBjdXJyZW50bHkgb24gdGhlIGZpcnN0IHNsaWRlLlxuICAgKi9cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5pc0ZpcnN0U2xpZGUgPSBmdW5jdGlvbiBpc0ZpcnN0U2xpZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2VsZWN0ZWRJbmRleCgpID09PSAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBjYXJvdXNlbCBpcyBjdXJyZW50bHkgb24gdGhlIGxhc3Qgc2xpZGUuXG4gICAqL1xuXG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLmlzTGFzdFNsaWRlID0gZnVuY3Rpb24gaXNMYXN0U2xpZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2VsZWN0ZWRJbmRleCgpID09PSB0aGlzLl9zbGlkZXMubGVuZ3RoIC0gMTtcbiAgfTtcblxuICAvKipcbiAgICogR2VuZXJhdGVzIHRoZSBhcnJheSB3aGljaCB3aWxsIGZvbGxvdyB0aGUgRE9NIG9yZGVyIG9mIHRoZSBzbGlkZXMgaW4gdGhlaXJcbiAgICogY29udGFpbmVyIGFuZCBzYXZlcyBpdC5cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuX3NldFNsaWRlSW5kaWNlcyA9IGZ1bmN0aW9uIF9zZXRTbGlkZUluZGljZXMoKSB7XG4gICAgdGhpcy5fc2xpZGVJbmRpY2VzID0gbmV3IEFycmF5KHRoaXMuX3NsaWRlcy5sZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3NsaWRlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGhpcy5fc2xpZGVJbmRpY2VzW2ldID0gaTtcbiAgICB9XG4gIH07XG5cbiAgLyoqIEByZXR1cm4geyFBcnJheS48IW51bWJlcj59IFRoZSBzbGlkZSBpbmRpY2VzIGFycmF5LiAqL1xuXG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLmdldFNsaWRlSW5kaWNlcyA9IGZ1bmN0aW9uIGdldFNsaWRlSW5kaWNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2xpZGVJbmRpY2VzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIHNsaWRlIGNoaWxkcmVuLlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBbb3B0U2xpZGVdIFNsaWRlIHRvIGxvb2sgd2l0aGluLlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudFtdfSBOb2RlTGlzdCBvZiBzbGlkZSBjaGlsZHJlbi5cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuX2dldFNsaWRlQ2hpbGRyZW4gPSBmdW5jdGlvbiBfZ2V0U2xpZGVDaGlsZHJlbihvcHRTbGlkZSkge1xuICAgIHJldHVybiB0aGlzLmdldEVsZW1lbnRzQnlDbGFzcyhDYXJvdXNlbC5DbGFzc2VzLlNMSURFX0NISUxELCBvcHRTbGlkZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1vZGlmaWVkcyB0aGUgX3NsaWRlSW5kaWNlcyBhcnJheSB0byByZXByZXNlbnQgdGhlIERPTSBvcmRlciBvZiB0aGUgc2xpZGVzXG4gICAqIHdpdGhpbiB0aGVpciBjb250YWluZXIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50VmFsdWUgVGhlIHZhbHVlIHRvIGJlIG1vdmVkLiBUaGlzIGlzIHRoZSBzYW1lIGFzIHRoZVxuICAgKiAgICAgbG9naWNhbCBpbmRleC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggVGhlIGxvY2F0aW9uIHRvIG1vdmUgaXQgdG8gaW4gdGhlIGFycmF5LiBJdCB3aWxsIGJlXG4gICAqICAgICBjbGFtcGVkIGJldHdlZW4gemVybyBhbmQgb25lIGxlc3MgdGhhbiB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheS4gVGhpcyBpc1xuICAgKiAgICAgYWxzbyByZWZlcnJlZCB0byBhcyB0aGUgRE9NIGluZGV4LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5fbW92ZUluZGV4ID0gZnVuY3Rpb24gX21vdmVJbmRleChjdXJyZW50VmFsdWUsIHRvSW5kZXgpIHtcbiAgICB2YXIgY2xhbXBlZEluZGV4ID0gdGhpcy5jbGFtcEluZGV4VG9TbGlkZXModG9JbmRleCk7XG4gICAgdmFyIGZyb21JbmRleCA9IHRoaXMuX2dldERvbUluZGV4KGN1cnJlbnRWYWx1ZSk7XG4gICAgdmFyIGFyciA9IHRoaXMuX3NsaWRlSW5kaWNlcztcblxuICAgIC8vIEFycmF5IG1vdmVJbmRleC5cbiAgICBhcnIuc3BsaWNlKGNsYW1wZWRJbmRleCwgMCwgYXJyLnNwbGljZShmcm9tSW5kZXgsIDEpWzBdKTtcbiAgfTtcblxuICAvKipcbiAgICogU3dhcHMgcG9zaXRpb25zIG9mIHR3byBsb2dpY2FsIGluZGljZXMgaW4gdGhlIHNsaWRlIGluZGljZXMgYXJyYXkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsb2dJbmRleDEgRmlyc3QgbG9naWNhbCBpbmRleCB3aGljaCB3aWxsIGJlIHN3YXBwZWVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbG9nSW5kZXgyIFNlY29uZCBsb2dpY2FsIGluZGV4IHRvIGJlIHN3YXBwZWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLl9zd2FwSW5kZXhlcyA9IGZ1bmN0aW9uIF9zd2FwSW5kZXhlcyhsb2dJbmRleDEsIGxvZ0luZGV4Mikge1xuICAgIHZhciBkb21JbmRleE9mTG9naWNhbEluZGV4MSA9IHRoaXMuX2dldERvbUluZGV4KGxvZ0luZGV4MSk7XG4gICAgdGhpcy5fc2xpZGVJbmRpY2VzW2RvbUluZGV4T2ZMb2dpY2FsSW5kZXgxXSA9IC0xO1xuICAgIHRoaXMuX3NsaWRlSW5kaWNlc1t0aGlzLl9nZXREb21JbmRleChsb2dJbmRleDIpXSA9IGxvZ0luZGV4MTtcbiAgICB0aGlzLl9zbGlkZUluZGljZXNbZG9tSW5kZXhPZkxvZ2ljYWxJbmRleDFdID0gbG9nSW5kZXgyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzbGlkZSBwb3NpdGlvbnMgKG9mZnNldHMgZnJvbSB0aGUgbGVmdHx0b3ApIGFycmF5LlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50W119IHNsaWRlU2V0IHRoZSBzbGlkZXMgYXJyYXkuXG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBhcnJheSBvZiBzbGlkZSBwb3NpdGlvbnMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLl9nZXRQb3NpdGlvbnMgPSBmdW5jdGlvbiBfZ2V0UG9zaXRpb25zKHNsaWRlU2V0KSB7XG4gICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRXcmFwcGVyKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbdGhpcy5fcG9zQXR0cl07XG4gICAgcmV0dXJuIHNsaWRlU2V0Lm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICAgIHJldHVybiBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtfdGhpczUuX3Bvc0F0dHJdIC0gYm91bmRzO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbmFibGUgb3IgZGlzYWJsZSBkcmFnZ2luZy5cbiAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkIFdoZXRoZXIgaXQgc2hvdWxkIGJlIGRyYWdnYWJsZS5cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuX3NldERyYWdnYWJsZUVuYWJsZWQgPSBmdW5jdGlvbiBfc2V0RHJhZ2dhYmxlRW5hYmxlZChlbmFibGVkKSB7XG4gICAgaWYgKHRoaXMuZHJhZ2dhYmxlKSB7XG4gICAgICB0aGlzLmRyYWdnYWJsZS5pc0VuYWJsZWQgPSBlbmFibGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBvaW50ZXIuaXNFbmFibGVkID0gZW5hYmxlZDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEVuYWJsZSBvciBkaXNhYmxlIGRyYWdnaW5nIG9mIHRoZSBjYXJvdXNlbC5cbiAgICogQHBhcmFtIHtib29sZWFufSBpc0RyYWdnYWJsZSBXaGV0aGVyIGl0IHNob3VsZCBiZSBkcmFnZ2FibGUuXG4gICAqL1xuXG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLnNldERyYWdnYWJsZSA9IGZ1bmN0aW9uIHNldERyYWdnYWJsZShpc0RyYWdnYWJsZSkge1xuICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gaXNEcmFnZ2FibGU7XG4gICAgdGhpcy5fc2V0RHJhZ2dhYmxlRW5hYmxlZChpc0RyYWdnYWJsZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBtZXRob2Qgd2hpY2ggcmV0dXJucyB0aGUgZW5hYmxlZCBzdGF0ZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG5cblxuICAvKipcbiAgICogR2V0cyB0aGUgYWRqdXN0ZWQgcG9zaXRpb24uXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRlc3RpbmF0aW9uU2xpZGUgVGhlIHNsaWRlIHRoZSBjYXJvdXNlbCBpcyBoZWFkZWQgdG8uXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHBvc2l0aW9uIGl0IGlzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLl9nZXROZXdQb3NpdGlvbiA9IGZ1bmN0aW9uIF9nZXROZXdQb3NpdGlvbihkZXN0aW5hdGlvblNsaWRlKSB7XG4gICAgLy8gRGVzdGluYXRpb24gcG9zaXRpb24uXG4gICAgdmFyIGRlc3RpbmF0aW9uUG9zaXRpb24gPSBkZXN0aW5hdGlvblNsaWRlW3RoaXMuX29mZnNldFBvc2l0aW9uXTtcblxuICAgIC8vIFdpZHRoIG9yIGhlaWdodCBvZiB0aGUgY2Fyb3VzZWwgZWxlbWVudC5cbiAgICB2YXIgY2Fyb3VzZWxTaXplID0gZ2V0U2l6ZSh0aGlzLmdldENhcm91c2VsRWxlbWVudCgpKVt0aGlzLl9kaW1lbnNpb25BdHRyXTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuaXNDZW50ZXJlZCkge1xuICAgICAgdmFyIGRlc3RpbmF0aW9uU2l6ZSA9IGdldFNpemUoZGVzdGluYXRpb25TbGlkZSlbdGhpcy5fZGltZW5zaW9uQXR0cl07XG4gICAgICB2YXIgd3JhcHBlclNpemUgPSBnZXRTaXplKHRoaXMuZ2V0V3JhcHBlcigpKVt0aGlzLl9kaW1lbnNpb25BdHRyXTtcbiAgICAgIHRoaXMuX3N0YXJ0RWRnZSA9ICh3cmFwcGVyU2l6ZSAtIGRlc3RpbmF0aW9uU2l6ZSkgLyAyO1xuICAgICAgZGVzdGluYXRpb25Qb3NpdGlvbiAtPSB0aGlzLl9zdGFydEVkZ2U7XG4gICAgfVxuXG4gICAgdmFyIHBvc2l0aW9uID0gZGVzdGluYXRpb25Qb3NpdGlvbiAvIGNhcm91c2VsU2l6ZTtcblxuICAgIGlmICh0aGlzLl9oYXNTbGlkZUNoaWxkcmVuICYmIHRoaXMuaXNMYXN0U2xpZGUoKSkge1xuICAgICAgLy8gQWRqdXN0IHRoZSBwb3NpdGlvbiBhZ2FpbiBpZiB0aGVyZSBhcmUgc2xpZGUgY2hpbGRyZW4gaW4gdGhlIGxhc3Qgc2xpZGUuXG4gICAgICBwb3NpdGlvbiA9IHRoaXMuX2dldFBvc2l0aW9uRm9yU2xpZGVDaGlsZHJlbihkZXN0aW5hdGlvblNsaWRlLCBkZXN0aW5hdGlvblBvc2l0aW9uLCBjYXJvdXNlbFNpemUpO1xuICAgIH1cblxuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgfTtcblxuICAvKipcbiAgICogQWRqdXN0IHRoZSBkZXN0aW5hdGlvbiBwb3NpdGlvbiBhZ2FpbiBpZiB0aGVyZSBhcmUgc2xpZGUgY2hpbGRyZW4uXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRlc3RpbmF0aW9uU2xpZGUgU2xpZGUgZWxlbWVudC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlc3RpbmF0aW9uUG9zaXRpb24gV2hlcmUgdGhlIHNsaWRlIHdvdWxkIGluaXRpYWxseSBnby5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGNhcm91c2VsU2l6ZSBXaWR0aCBvciBoZWlnaHQgb2YgdGhlIGNhcm91c2VsIGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gTmV3IGRlc3RpbmF0aW9uIHBvc2l0aW9uLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5fZ2V0UG9zaXRpb25Gb3JTbGlkZUNoaWxkcmVuID0gZnVuY3Rpb24gX2dldFBvc2l0aW9uRm9yU2xpZGVDaGlsZHJlbihkZXN0aW5hdGlvblNsaWRlLCBkZXN0aW5hdGlvblBvc2l0aW9uLCBjYXJvdXNlbFNpemUpIHtcbiAgICAvLyBTaXplIG9mIHRoZSBjb21iaW5lZCB3aWR0aC9oZWlnaHQgKyBtYXJnaW5zIG9mIHRoZSBzbGlkZSBjaGlsZHJlblxuICAgIC8vIHdpdGhpbiB0aGUgZGVzdGluYXRpb24gc2xpZGUuXG4gICAgdmFyIGNoaWxkcmVuU3VtID0gZ2V0RWxlbWVudHNTaXplKHRoaXMuX2dldFNsaWRlQ2hpbGRyZW4oZGVzdGluYXRpb25TbGlkZSksIHRoaXMuX2RpbWVuc2lvbkF0dHIpO1xuXG4gICAgLy8gd2lkdGh8aGVpZ2h0IG9mIHRoZSBjYXJvdXNlbCBzbGlkZS5cbiAgICB2YXIgc2xpZGVTaXplID0gZ2V0U2l6ZShkZXN0aW5hdGlvblNsaWRlKVt0aGlzLl9kaW1lbnNpb25BdHRyXTtcblxuICAgIC8vIFRoZSBkZXN0aW5hdGlvbiBwb3NpdGlvbiBtaW51cyB0aGUgZW1wdHkgc3BhY2UgaW4gdGhlIG5leHQgc2xpZGUgaW4gcHguXG4gICAgdmFyIG5ld1Bvc2l0aW9uID0gZGVzdGluYXRpb25Qb3NpdGlvbiAtIChzbGlkZVNpemUgLSBjaGlsZHJlblN1bSk7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIHBlcmNlbnRhZ2UgZnJvbSB0aGUgcGl4ZWwgdmFsdWUuXG4gICAgcmV0dXJuIG5ld1Bvc2l0aW9uIC8gY2Fyb3VzZWxTaXplO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0cmFuc2xhdGVkIHBvc2l0aW9uIGJhc2VkIG9uIGNhcm91c2VsIGRpcmVjdGlvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBvcyBUaGUgcG9zaXRpb24gKGVnIFwiMjUlXCIpLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBjc3MgdmFsdWUgZm9yIHRyYW5zZm9ybS5cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuX2dldENzc1Bvc2l0aW9uID0gZnVuY3Rpb24gX2dldENzc1Bvc2l0aW9uKHBvcykge1xuICAgIHJldHVybiAndHJhbnNsYXRlJyArIHRoaXMuX3RyYW5zbGF0ZUF4aXMgKyAnKCcgKyBwb3MgKyAnKSc7XG4gIH07XG5cbiAgLyoqIEBwcml2YXRlICovXG5cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuX3NldFNsaWRlc1RvTG9naWNhbE9yZGVyID0gZnVuY3Rpb24gX3NldFNsaWRlc1RvTG9naWNhbE9yZGVyKCkge1xuICAgIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gICAgdGhpcy5fc2xpZGVzLmZvckVhY2goZnJhZy5hcHBlbmRDaGlsZCwgZnJhZyk7XG5cbiAgICB0aGlzLl9jYXJvdXNlbEVsLmFwcGVuZENoaWxkKGZyYWcpO1xuXG4gICAgLy8gUmVzZXQgdGhlIHNsaWRlIGluZGljZXMgYXJyYXkuXG4gICAgdGhpcy5fc2V0U2xpZGVJbmRpY2VzKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIElmIHRoaXMgaXMgYSBqdW1wZWQgY2Fyb3VzZWwsIHByZXBhcmUgdGhlIHNsaWRlcyBmb3IgdGhlIGp1bXAgYnkgc3dhcHBpbmdcbiAgICogZWxlbWVudHMgb3V0IGFuZCBzZXR0aW5nIHRoZSBgaXNKdW1wZWRgIG9wdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHRvRG9tSW5kZXggSW5kZXggb2YgdGhlIHNsaWRlIHRoZSBjYXJvdXNlbCBpcyBqdW1waW5nIHRvLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IElmIHRoaXMgZnVuY3Rpb24gY2hhbmdlZCB0aGUgb3JkZXIgdGhlIHNsaWRlcywgaXQgcmV0dXJuc1xuICAgKiAgICAgdGhlIG5ldyBET00gaW5kZXggdGhlIGNhcm91c2VsIGlzIGdvaW5nIHRvLiBPdGhlcndpc2UgaXQgcmV0dXJucyB0aGVcbiAgICogICAgIERPTSBpbmRleCBwYXJhbWV0ZXIgaXQgd2FzIGdpdmVuLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5fc2V0TmVpZ2hib3JTbGlkZXNGb3JKdW1wID0gZnVuY3Rpb24gX3NldE5laWdoYm9yU2xpZGVzRm9ySnVtcCh0b0RvbUluZGV4KSB7XG4gICAgdmFyIHRvTG9naWNhbEluZGV4ID0gdGhpcy5fZ2V0TG9naWNhbEluZGV4KHRvRG9tSW5kZXgpO1xuICAgIHZhciBjdXJyZW50TG9naWNhbEluZGV4ID0gdGhpcy5fZ2V0TG9naWNhbEluZGV4KHRoaXMuZG9tSW5kZXgpO1xuXG4gICAgdGhpcy5faXNKdW1wZWQgPSB0cnVlO1xuXG4gICAgLy8gV2hlcmUgdG8gbW92ZSB0aGUgc2xpZGUgdG8uIE5leHQgdG8gdGhlIGN1cnJlbnQgaW5kZXguXG4gICAgdmFyIGRlc3RpbmF0aW9uRG9tSW5kZXggPSB0b0xvZ2ljYWxJbmRleCA+IGN1cnJlbnRMb2dpY2FsSW5kZXggPyB0aGlzLmRvbUluZGV4ICsgMSA6IHRoaXMuZG9tSW5kZXggLSAxO1xuXG4gICAgLy8gU3dhcCBpbmRpY2VzLlxuICAgIC8vIFN3YXAgZGVzdGluYXRpb24gc2xpZGUgd2l0aCBjdXJyZW50IHNsaWRlIGF0IHRoZSBkZXN0aW5hdGlvbi5cbiAgICB0aGlzLl9zd2FwU2xpZGVzKHRvTG9naWNhbEluZGV4LCB0aGlzLl9nZXRMb2dpY2FsSW5kZXgoZGVzdGluYXRpb25Eb21JbmRleCkpO1xuXG4gICAgLy8gUmV0dXJuIHRoZSBkb20gaW5kZXggdGhlIGNhcm91c2VsIGlzIGFjdHVhbGx5IGdvaW5nIHRvLlxuICAgIHJldHVybiBkZXN0aW5hdGlvbkRvbUluZGV4O1xuICB9O1xuXG4gIC8qKlxuICAgKiBTd2FwIGluZGljZXMgYW5kIERPTSBlbGVtZW50cy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4MSBMb2dpY2FsIGluZGV4IDEuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleDIgTG9naWNhbCBpbmRleCAyLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5fc3dhcFNsaWRlcyA9IGZ1bmN0aW9uIF9zd2FwU2xpZGVzKGluZGV4MSwgaW5kZXgyKSB7XG4gICAgdGhpcy5fc3dhcEluZGV4ZXMoaW5kZXgxLCBpbmRleDIpO1xuICAgIHN3YXBFbGVtZW50cyh0aGlzLmdldFNsaWRlKGluZGV4MSksIHRoaXMuZ2V0U2xpZGUoaW5kZXgyKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaW5pdGlhbGl6ZXMgdGhlIHNsaWRlc2hvdyBmdW5jdGlvbmFsaXR5IGZvciB0aGVcbiAgICogY2Fyb3VzZWwuIEl0IHNldHMgYW4gaW50ZXJ2YWwgZm9yIHRoZSBzbGlkZXNob3cgdG8gY29udGludWUgYW5pbWF0ZVxuICAgKiBiYXNlZCBvbiB0aGUgb3B0aW9uIHNsaWRlc2hvd1NwZWVkLlxuICAgKi9cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5zdGFydFNsaWRlc2hvdyA9IGZ1bmN0aW9uIHN0YXJ0U2xpZGVzaG93KCkge1xuICAgIC8vIENyZWF0ZSB0aGUgdGltZXIgaWYgaXQgZG9lc24ndCBhbHJlYWR5IGV4aXN0LlxuICAgIGlmICghdGhpcy5fdGltZXIpIHtcbiAgICAgIHRoaXMuX3RpbWVyID0gbmV3IFRpbWVyKHRoaXMuX3NsaWRlc2hvd1RpbWVyRXhwaXJlZC5iaW5kKHRoaXMpLCB0aGlzLm9wdGlvbnMuc2xpZGVzaG93U3BlZWQsIHRydWUpO1xuICAgIH1cblxuICAgIHRoaXMuX3RpbWVyLnN0YXJ0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgc2ltcGxlIG1ldGhvZCB3aGljaCBwYXVzZXMgdGhlIF90aW1lclxuICAgKiBvbmNlIHRoYXRzIHBhdXNlZCB0aGUgc2xpZGVzaG93IHdpbGwgc3RvcCB0aWNraW5nLlxuICAgKiBDYW4gYmUgcmUtaW5pdGlhbHplZCBieSBydW5uaW5nIGBzdGFydFNsaWRlc2hvdygpYFxuICAgKi9cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5wYXVzZVNsaWRlc2hvdyA9IGZ1bmN0aW9uIHBhdXNlU2xpZGVzaG93KCkge1xuICAgIGlmICh0aGlzLl9pc1NsaWRlc2hvd1BsYXlpbmcoKSkge1xuICAgICAgdGhpcy5fdGltZXIuc3RvcCgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgc2xpZGVzaG93IHRpbWVyIGV4aXN0cyBhbmQgaXMgY3VycmVudGx5IHRpY2tpbmcuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLl9pc1NsaWRlc2hvd1BsYXlpbmcgPSBmdW5jdGlvbiBfaXNTbGlkZXNob3dQbGF5aW5nKCkge1xuICAgIHJldHVybiAhIXRoaXMuX3RpbWVyICYmIHRoaXMuX3RpbWVyLmlzVGlja2luZztcbiAgfTtcblxuICAvLyBnZXROdGhTaWJsaW5nIHJldHVybnMgbnVsbCBpZiBpdCBjYW5ub3QgZmluZCB0aGUgbnRoIHNpYmxpbmcsXG4gIC8vIGJ1dCBpZiBgbnVsbGAgaXMgdXNlZCBpbiBgaW5zZXJ0QmVmb3JlYCwgaXQgd2lsbCBhcHBlbmQgdGhlIGVsZW1lbnRcbiAgLy8gdG8gdGhlIGVuZC5cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5nZXRJbm5vY2VudE5laWdoYm9yID0gZnVuY3Rpb24gZ2V0SW5ub2NlbnROZWlnaGJvcihpdGVyYXRvciwgaXNOZXh0KSB7XG4gICAgdmFyIGN1cnJlbnRTbGlkZUVsID0gdGhpcy5nZXRTbGlkZSh0aGlzLmdldFNlbGVjdGVkSW5kZXgoKSk7XG4gICAgcmV0dXJuIGlzTmV4dCA/IGdldE50aFNpYmxpbmcoY3VycmVudFNsaWRlRWwsIGl0ZXJhdG9yICsgMSkgOiBnZXROdGhTaWJsaW5nKGN1cnJlbnRTbGlkZUVsLCBpdGVyYXRvciwgZmFsc2UpIHx8IHRoaXMuX2Nhcm91c2VsRWwuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gIH07XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5nZXROZWlnaGJvckluc2VydGlvbkluZGV4ID0gZnVuY3Rpb24gZ2V0TmVpZ2hib3JJbnNlcnRpb25JbmRleChpdGVyYXRvciwgaXNOZXh0LCBjdXJyZW50RG9tSW5kZXgpIHtcbiAgICByZXR1cm4gaXNOZXh0ID8gY3VycmVudERvbUluZGV4ICsgaXRlcmF0b3IgKyAxIDogY3VycmVudERvbUluZGV4IC0gaXRlcmF0b3I7XG4gIH07XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpdGVyYXRvciBOZWlnaGJvciBpbmRleC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJlbGF0aXZlUG9zIE5laWdoYm9yIGluZGV4IHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IGluZGV4LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTmV4dCBXaGV0aGVyIHRvIG1vdmUgdGhlIHNsaWRlIG5leHQgb3IgcHJldmlvdXMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLl9zZXROZWlnaGJvclNsaWRlID0gZnVuY3Rpb24gX3NldE5laWdoYm9yU2xpZGUoaXRlcmF0b3IsIHJlbGF0aXZlUG9zLCBpc05leHQpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmdldFNlbGVjdGVkSW5kZXgoKTtcbiAgICB2YXIgaW5kaWNlcyA9IHRoaXMuZ2V0U2xpZGVJbmRpY2VzKCk7XG5cbiAgICAvLyBQcmV2aW91cyBjYWxscyB0byBzZXQgbmVpZ2hib3Igc2xpZGUgbWF5IGhhdmUgY2hhbmdlZCB0aGUgRE9NLCBzb1xuICAgIC8vIGRvbid0IHJlbHkgb24gc3RvcmVkIHZhcmlhYmxlcy5cbiAgICB2YXIgY3VycmVudERvbUluZGV4ID0gdGhpcy5fZ2V0RG9tSW5kZXgoaW5kZXgpO1xuXG4gICAgLy8gSW5kZXggb2YgdGhlIGZ1dHVyZSBuZWlnaGJvciByZWxhdGl2ZSB0byB0aGUgb3JpZ2luYWwgRE9NIG9yZGVyLlxuICAgIHZhciBsb2dpY2FsTmVpZ2hib3JJbmRleCA9IHRoaXMuX2dldFJlbGF0aXZlSW5kZXgoaW5kZXgsIHJlbGF0aXZlUG9zKTtcblxuICAgIC8vIERvIHRoZSBzbGlkZXMgbmVlZCB0byBiZSByZWFycmFuZ2VkPyBDaGVjayB0aGUgY3VycmVudCBpbmRpY2VzIHRvIHNlZVxuICAgIC8vIGlmIHRoZSBuZXcgbmVpZ2hib3JzIGFyZSBhbHJlYWR5IHRoZXJlLlxuICAgIGlmIChpbmRpY2VzW2N1cnJlbnREb21JbmRleCArIHJlbGF0aXZlUG9zXSAhPT0gbG9naWNhbE5laWdoYm9ySW5kZXgpIHtcbiAgICAgIC8vIFRoZSBzbGlkZSB0byBpbnNlcnQgdGhlIG5ldyBuZWlnaGJvciBiZWZvcmUuXG4gICAgICB2YXIgaW5ub2NlbnROZWlnaGJvciA9IHRoaXMuZ2V0SW5ub2NlbnROZWlnaGJvcihpdGVyYXRvciwgaXNOZXh0KTtcbiAgICAgIHZhciBpbnNlcnRpb25JbmRleCA9IHRoaXMuZ2V0TmVpZ2hib3JJbnNlcnRpb25JbmRleChpdGVyYXRvciwgaXNOZXh0LCBjdXJyZW50RG9tSW5kZXgpO1xuICAgICAgdmFyIG5laWdoYm9yRWwgPSB0aGlzLmdldFNsaWRlKGxvZ2ljYWxOZWlnaGJvckluZGV4KTtcblxuICAgICAgLy8gTW92ZSB0aGUgbmVpZ2hib3IncyBpbmRleCB0byBiZSBhIG5laWdoYm9yIHRvIHRoZSBjdXJyZW50IGRvbSBpbmRleC5cbiAgICAgIHRoaXMuX21vdmVJbmRleChsb2dpY2FsTmVpZ2hib3JJbmRleCwgaW5zZXJ0aW9uSW5kZXgpO1xuICAgICAgdGhpcy5fY2Fyb3VzZWxFbC5pbnNlcnRCZWZvcmUobmVpZ2hib3JFbCwgaW5ub2NlbnROZWlnaGJvcik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIG1ha2VzIHN1cmUgdGhhdCBsb29wZWQgY2Fyb3VzZWxzIGFsd2F5cyBoYXZlIGEgbmVpZ2hib3IgdG9cbiAgICogZ28gdG8uIEl0IHJlcG9zaXRpb25zIHRoZSB2aWV3cG9ydCBpZiBpdCBoYXMgdG8gbW92ZSBzbGlkZXMgYXJvdW5kLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5fc2V0TmVpZ2hib3JTbGlkZXMgPSBmdW5jdGlvbiBfc2V0TmVpZ2hib3JTbGlkZXMoKSB7XG4gICAgdmFyIGkgPSB2b2lkIDA7XG5cbiAgICAvLyBTZXQgdGhlIGxlZnQgbmVpZ2hib3IocykuXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMub3B0aW9ucy5uZWlnaGJvckNvdW50OyBpKyspIHtcbiAgICAgIHRoaXMuX3NldE5laWdoYm9yU2xpZGUoaSwgLShpICsgMSksIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvLyBTZXQgdGhlIHJpZ2h0IG5laWdoYm9yKHMpLlxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLm9wdGlvbnMubmVpZ2hib3JDb3VudDsgaSsrKSB7XG4gICAgICB0aGlzLl9zZXROZWlnaGJvclNsaWRlKGksIGkgKyAxLCB0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlc2V0IHRoZSBjYXJvdXNlbCBiYWNrIHRvIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgc2xpZGUgd2l0aG91dCBhbmltYXRpb24uXG4gICAqL1xuXG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLl9zbmFwVG9DdXJyZW50U2xpZGUgPSBmdW5jdGlvbiBfc25hcFRvQ3VycmVudFNsaWRlKCkge1xuICAgIHRoaXMuZ29Ub1NsaWRlKHRoaXMuX2dldERvbUluZGV4KHRoaXMuZ2V0U2VsZWN0ZWRJbmRleCgpKSwgdHJ1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERldGVybWluZSBpZiB0aGUgZGlzdGFuY2UgYmV0d2VlbiBjdXJyZW50IGFuZCBkZXN0aW5hdGlvbiBzbGlkZXMgaXMgbW9yZVxuICAgKiB0aGFuIG9uZSBzbGlkZS4gSWYgaXQncyBub3QsIHRoZXJlIGlzIG5vIG5lZWQgdG8gXCJqdW1wXCIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkb21JbmRleCBET00gaW5kZXggb2YgdGhlIHNsaWRlIHRvIGdvIHRvLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG5vQW5pbWF0aW9uIFdoZXRoZXIgb3Igbm90IHRoZSBzbGlkZSB3aWxsIGJlIGFuaW1hdGluZy5cbiAgICogQHJldHVybiB7bnVtYmVyfSBET00gaW5kZXggb2YgdGhlIHNsaWRlIHRvIGdvIHRvIGJlY2F1c2UgbW92aW5nIHNsaWRlc1xuICAgKiAgICAgYXJvdW5kIHRvIFwianVtcFwiIHRoZW0gd2lsbCBjYXVzZXMgaW5kaWNlcyB0byBjaGFuZ2UuXG4gICAqL1xuXG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLl9tYXliZVNldEp1bXBlZFNsaWRlcyA9IGZ1bmN0aW9uIF9tYXliZVNldEp1bXBlZFNsaWRlcyhkb21JbmRleCwgbm9BbmltYXRpb24pIHtcbiAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIGRpc3RhbmNlIGJldHdlZW4gY3VycmVudCBhbmQgZGVzdGluYXRpb24gc2xpZGVzXG4gICAgLy8gaXMgbW9yZSB0aGFuIG9uZSBzbGlkZS4gSWYgaXQncyBub3QsIHRoZXJlJ3Mgbm8gbmVlZCB0byBcImp1bXBcIi5cbiAgICBpZiAodGhpcy5vcHRpb25zLmlzSnVtcGVkICYmICFub0FuaW1hdGlvbiAmJiBNYXRoLmFicyh0aGlzLmRvbUluZGV4IC0gZG9tSW5kZXgpID4gMSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NldE5laWdoYm9yU2xpZGVzRm9ySnVtcChkb21JbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBkb21JbmRleDtcbiAgfTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHRoZSBjYXJvdXNlbCBjYW4gbmF2aWdhdGUgaW4gaXRzIGN1cnJlbnQgY29uZGl0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZG9tSW5kZXggRG9tIGluZGV4IG9mIHRoZSBzbGlkZSB0byBnbyB0by5cbiAgICogQHBhcmFtIHtib29sZWFufSBub0FuaW1hdGlvbiBXaGV0aGVyIG9yIG5vdCB0aGUgc2xpZGUgd2lsbCBiZSBhbmltYXRpbmcgdGhlcmUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuXG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLl9jYW5OYXZpZ2F0ZSA9IGZ1bmN0aW9uIF9jYW5OYXZpZ2F0ZShkb21JbmRleCwgbm9BbmltYXRpb24pIHtcbiAgICB2YXIgaXNTYW1lU2xpZGVXaXRoQW5pbWF0aW9uID0gZG9tSW5kZXggPT09IHRoaXMuZG9tSW5kZXggJiYgIW5vQW5pbWF0aW9uO1xuXG4gICAgLy8gV2hldGhlciB0aGUgY2Fyb3VzZWwgd291bGQgYmUgYWJsZSB0byBtb3ZlLlxuICAgIHZhciBpc09mZnNldCA9IHRoaXMuaGFzRHJhZ2dlZCB8fCB0aGlzLl9pc09mZnNldDtcblxuICAgIC8vIDEpIFdoZXRoZXIgdGhlIGNhcm91c2VsIGlzIGVuYWJsZWQuXG4gICAgLy8gMikgVGhlIGluZGV4IGlzIG91dCBvZiByYW5nZSBhbmQgdGhlIGNhcm91c2VsIGlzbid0IHNldCB0byBsb29wLiBTaWxlbnRseVxuICAgIC8vIGV4aXQgaGVyZSBpbnN0ZWFkIG9mIHRocm93aW5nIGVycm9ycyBldmVyeXdoZXJlLlxuICAgIC8vIDMpIFRyeWluZyB0byBnbyB0byB0aGUgc2xpZGUgaXQncyBhbHJlYWR5IG9uIHdpdGggYSB0cmFuc2l0aW9uIGFuZCBub1xuICAgIC8vIGRyYWdnaW5nIGhhcyBvY2N1cmVkIG9yIHRoZSBjYXJvdXNlbCBpcyBub3Qgb2Zmc2V0LlxuICAgIHJldHVybiAhKCF0aGlzLl9pc0VuYWJsZWQgfHwgIXRoaXMub3B0aW9ucy5pc0xvb3BlZCAmJiB0aGlzLmlzSW5kZXhPdXRPZlJhbmdlKGRvbUluZGV4KSB8fCBpc1NhbWVTbGlkZVdpdGhBbmltYXRpb24gJiYgIWlzT2Zmc2V0KTtcbiAgfTtcblxuICBDYXJvdXNlbC5wcm90b3R5cGUuX3RvTmV3U2xpZGUgPSBmdW5jdGlvbiBfdG9OZXdTbGlkZSgpIHtcbiAgICAvLyBTZXQgZmxhZyBtZWFuaW5nIHRoZSBjYXJvdXNlbCBpcyB3YWl0aW5nIGZvciBhIHRyYW5zaXRpb24gZW5kLlxuICAgIHRoaXMuaXNUcmFuc2l0aW9uaW5nID0gdHJ1ZTtcblxuICAgIC8vIEZpcmUgZXZlbnQgc2F5aW5nIHRoZSBzbGlkZSBzdGFydGVkIHRvIHRyYW5zaXRpb24uXG4gICAgdGhpcy5fZW1pdEV2ZW50KG5ldyBDYXJvdXNlbEV2ZW50KENhcm91c2VsLkV2ZW50VHlwZS5TTElERV9TVEFSVCwgdGhpcywgdGhpcy5fZ2V0TG9naWNhbEluZGV4KHRoaXMubGFzdERvbUluZGV4KSwgdGhpcy5fZ2V0TG9naWNhbEluZGV4KHRoaXMuZG9tSW5kZXgpKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVzZXMgQ3NzIHRyYW5zZm9ybXMgdG8gbW92ZSB0aGUgY2Fyb3VzZWwgdG8gYSBuZXcgcG9zaXRpb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwb3NpdGlvbiBUaGUgcGVyY2VudGFnZSB2YWx1ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBub0FuaW1hdGlvbiBXaGV0aGVyIHRvIG1vdmUgd2l0aCBhbmltYXRpb24gb3Igbm90LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5fbW92ZVRvUG9zaXRpb24gPSBmdW5jdGlvbiBfbW92ZVRvUG9zaXRpb24ocG9zaXRpb24sIG5vQW5pbWF0aW9uKSB7XG4gICAgLy8gU2V0IHRyYW5zZm9ybS5cbiAgICB0aGlzLl9jYXJvdXNlbEVsLnN0eWxlW09kb0RldmljZS5Eb20uVFJBTlNGT1JNXSA9IHRoaXMuX2dldENzc1Bvc2l0aW9uKHBvc2l0aW9uKTtcblxuICAgIC8vIFNldCB0cmFuc2l0aW9uIHNwZWVkIHRvIHplcm8gc28gdGhhdCBpdCBoYXBwZW5zIGluc3RhbnRseS5cbiAgICBpZiAobm9BbmltYXRpb24pIHtcbiAgICAgIHRoaXMuX2Nhcm91c2VsRWwuc3R5bGVbT2RvRGV2aWNlLkRvbS5UUkFOU0lUSU9OX0RVUkFUSU9OXSA9ICcwbXMnO1xuXG4gICAgICAvLyBMaXN0ZW4gZm9yIHRyYW5zaXRpb25lbmQgaWYgaXQgd2lsbCBhbmltYXRlLlxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXQgdHJhbnNpdGlvbiBzcGVlZC5cbiAgICAgIHRoaXMuX2Nhcm91c2VsRWwuc3R5bGVbT2RvRGV2aWNlLkRvbS5UUkFOU0lUSU9OX0RVUkFUSU9OXSA9IHRoaXMub3B0aW9ucy5hbmltYXRpb25TcGVlZCArICdtcyc7XG5cbiAgICAgIC8vIFRoaXMgaXMgdXNlZCBhcyBhIGJhY2t1cCB0byB0aGUgdHJhbnNpdGlvbmVuZCBldmVudCwgd2hpY2ggc29tZXRpbWVzXG4gICAgICAvLyBkb2Vzbid0IGZpcmUgb24gaU9TIDcgU2FmYXJpIHdoZW4gdGhlIGNhcm91c2VsIGhhcyBvbmx5IGJlZW4gZHJhZ2dlZCBhXG4gICAgICAvLyBmZXcgcGl4ZWxzLiBJdCdzIHNldCB0byBnbyBvZmYgfjIgZnJhbWVzIGFmdGVyIHRoZSB0cmFuc2l0aW9uIGVuZCBldmVudFxuICAgICAgLy8gc2hvdWxkIGhhdmUgb2NjdXJyZWQuXG4gICAgICB0aGlzLl90cmFuc2l0aW9uSWQgPSBvblRyYW5zaXRpb25FbmQodGhpcy5fY2Fyb3VzZWxFbCwgdGhpcy5fdHJhbnNpdGlvbkRvbmUsIHRoaXMsIE9kb0RldmljZS5Eb20uVFJBTlNGT1JNLCB0aGlzLm9wdGlvbnMuYW5pbWF0aW9uU3BlZWQgKyBDYXJvdXNlbC5UUkFOU0lUSU9OX0VORF9XQUlUKTtcblxuICAgICAgdGhpcy5fdG9OZXdTbGlkZSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgb2Zmc2V0IG9mIHRoZSBjYXJvdXNlbCByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBzbGlkZS5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5fZ2V0Q2Fyb3VzZWxPZmZzZXQgPSBmdW5jdGlvbiBfZ2V0Q2Fyb3VzZWxPZmZzZXQoKSB7XG4gICAgdmFyIG1hdHJpeCA9IGdldENvbXB1dGVkU3R5bGUodGhpcy5fY2Fyb3VzZWxFbClbT2RvRGV2aWNlLkRvbS5UUkFOU0ZPUk1dO1xuXG4gICAgLy8gUm91bmQgdG8gMSBkZWNpbWFsIHBsYWNlIGJlY2F1c2UgdGhlIGBfc3RhcnRFZGdlYCBjYW4gYmUgYSBkZWNpbWFsLlxuICAgIHZhciB0cmFuc2xhdGUgPSBNYXRoLnJvdW5kKGdldFRyYW5zbGF0ZShtYXRyaXgpW3RoaXMuX3RyYW5zbGF0ZUF4aXMudG9Mb3dlckNhc2UoKV0gKiAxMCkgLyAxMDtcblxuICAgIHZhciBzbGlkZU9mZnNldCA9IHRoaXMuZ2V0U2xpZGUodGhpcy5nZXRTZWxlY3RlZEluZGV4KCkpW3RoaXMuX29mZnNldFBvc2l0aW9uXTtcbiAgICByZXR1cm4gc2xpZGVPZmZzZXQgKyB0cmFuc2xhdGU7XG4gIH07XG5cbiAgLyoqXG4gICAqIElmIHRoZSBjYXJvdXNlbCBpcyB3YWl0aW5nIGZvciBhIHRyYW5zaXRpb24gdG8gZmluaXNoIChnb2luZyB0byBhIHNsaWRlKSxcbiAgICogYnV0IHRoZSB1c2VyIHRlbGxzIGl0IHRvIG5hdmlnYXRlIGFnYWluLCB0aGUgcHJldmlvdXMgbGlzdGVuZXIgZm9yIHRoZVxuICAgKiB0cmFuc2l0aW9uIGVuZCBldmVudCBuZWVkcyB0byBiZSBjYW5jZWxlZC4gVGhpcyBhbGxvd3MgdGhlIHVzZXIgdG8gcXVpY2tseVxuICAgKiBjbGljayB0aHJvdWdoIHRoZSBjYXJvdXNlbCB3aXRob3V0IHdhaXRpbmcgZm9yIGVhY2ggbmF2aWdhdGlvbiB0byBmaW5pc2guXG4gICAqXG4gICAqIEZvciBqdW1wZWQgYW5kIGxvb3BlZCBjYXJvdXNlbHMsIHRoZSBjYXJvdXNlbCBlbGVtZW50IG5lZWRzIHRvIGJlXG4gICAqIHJlcG9zaXRpb25lZCBiZWNhdXNlIHNldHRpbmcgbmVpZ2hib3Igc2xpZGVzIHdpbGwgY2F1c2UgdGhlIGVsZW1lbnRzIHRvXG4gICAqIHNoaWZ0IHdpdGhpbiB0aGUgbWFpbiBjYXJvdXNlbCBlbGVtZW50LiBUaGUgY3VycmVudCBvZmZzZXQgcmVsYXRpdmUgdG9cbiAgICogdGhlIGN1cnJlbnQgc2xpZGUgaXMgc2F2ZWQgYmVmb3JlIG1vdmluZyBhbnkgc2xpZGUgZWxlbWVudHMsIHRoZW4gdGhlIHNsaWRlXG4gICAqIGVsZW1lbnRzIGFyZSBtb3ZlZCwgYW5kIGZpbmFsbHkgdGhlIGNhcm91c2VsIGlzIHNldCB0byBhcHBlYXIgYXMgaWYgdGhlXG4gICAqIGVsZW1lbnRzIG5ldmVyIG1vdmVkLlxuICAgKi9cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5fY2FuY2VsTW92ZW1lbnQgPSBmdW5jdGlvbiBfY2FuY2VsTW92ZW1lbnQoKSB7XG4gICAgaWYgKCF0aGlzLmlzVHJhbnNpdGlvbmluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuaXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgY2FuY2VsVHJhbnNpdGlvbkVuZCh0aGlzLl90cmFuc2l0aW9uSWQpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5pc0ZhZGUpIHtcbiAgICAgIC8vIFJlbW92ZSB0aGUgXCJiZWhpbmRcIiBjbGFzcyB3aGljaCBpcyB1c3VhbGx5IHJlbW92ZWQgYWZ0ZXIgdGhlIG9uXG4gICAgICAvLyB0cmFuc2l0aW9uIGVuZC5cbiAgICAgIHRoaXMuZ2V0U2xpZGUodGhpcy5fZ2V0TG9naWNhbEluZGV4KHRoaXMubGFzdERvbUluZGV4KSkuY2xhc3NMaXN0LnJlbW92ZShDYXJvdXNlbC5DbGFzc2VzLkJFSElORCk7XG4gICAgICAvLyBGYWRpbmcgY2Fyb3VzZWxzIGRvIG5vdCBuZWVkIHRvIHJlcG9zaXRpb24gdGhlbXNlbHZlcywgZW5kIGhlcmUuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU2F2ZSB0aGUgb2Zmc2V0IHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHNsaWRlIGJlZm9yZSBzbGlkZXMgYXJlIG1vdmVkLlxuICAgIHZhciBjYXJvdXNlbFNpemUgPSBnZXRTaXplKHRoaXMuZ2V0Q2Fyb3VzZWxFbGVtZW50KCkpW3RoaXMuX2RpbWVuc2lvbkF0dHJdO1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLl9nZXRDYXJvdXNlbE9mZnNldCgpO1xuXG4gICAgaWYgKHRoaXMuX2lzSnVtcGVkKSB7XG4gICAgICB0aGlzLl9zZXRTbGlkZXNUb0xvZ2ljYWxPcmRlcigpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9pc1NsaWRpbmdMb29wZWQpIHtcbiAgICAgIHRoaXMuX3NldE5laWdoYm9yU2xpZGVzKCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHRoYXQgdGhlIGN1cnJlbnQgc2xpZGUgaGFzIHBvdGVudGlhbGx5IG1vdmVkIGluIHRoZSBET00sIHVwZGF0ZSB0aGVcbiAgICAvLyBjYXJvdXNlbCdzIG9mZnNldC5cbiAgICB2YXIgY3VycmVudFNsaWRlRWwgPSB0aGlzLmdldFNsaWRlKHRoaXMuZ2V0U2VsZWN0ZWRJbmRleCgpKTtcbiAgICB2YXIgbmV3U2xpZGVPZmZzZXQgPSBjdXJyZW50U2xpZGVFbFt0aGlzLl9vZmZzZXRQb3NpdGlvbl07XG4gICAgdmFyIHBvc2l0aW9uID0gKG5ld1NsaWRlT2Zmc2V0IC0gb2Zmc2V0KSAvIGNhcm91c2VsU2l6ZTtcblxuICAgIC8vIFNldHRpbmcgdGhlIHBvc2l0aW9uIGhlcmUgc3RvcHMgdGhlIGJyb3dzZXIgZnJvbSB0cmFuc2l0aW9uaW5nIHRvIHRoZVxuICAgIC8vIHByZXZpb3VzIHBvc2l0aW9uLCBhbGxvd2luZyB0aGUgdXNlciB0byBcImNhdGNoXCIgdGhlIGNhcm91c2VsIG1pZC1uYXYuXG4gICAgdGhpcy5fbW92ZVRvUG9zaXRpb24ocG9zaXRpb24gKiAtMTAwICsgJyUnLCB0cnVlKTtcbiAgICB0aGlzLmRyYWdnYWJsZS51cGRhdGUoKTtcbiAgfTtcblxuICAvKipcbiAgICogR29lcyB0byBhIGdpdmVuIHNsaWRlLlxuICAgKiBAcGFyYW0geyFudW1iZXJ9IGRvbUluZGV4IFRoZSBzbGlkZSBpbmRleCByZWxhdGl2ZSB0byBET00gb3JkZXIuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW25vQW5pbWF0aW9uXSBXaGV0aGVyIGdvaW5nIHRvIHRoZSBzbGlkZSBzaG91bGQgYW5pbWF0ZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5mYWRlVG9TbGlkZSA9IGZ1bmN0aW9uIGZhZGVUb1NsaWRlKGRvbUluZGV4LCBub0FuaW1hdGlvbikge1xuICAgIC8vIEdldCBuZXh0IGFuZCBwcmV2aW91cyBzbGlkZXMuXG4gICAgdmFyIG5leHRTbGlkZSA9IHRoaXMuZ2V0U2xpZGUoZG9tSW5kZXgpO1xuICAgIHZhciBwcmV2aW91c1NsaWRlID0gdGhpcy5nZXRTbGlkZSh0aGlzLmRvbUluZGV4KTtcblxuICAgIC8vIExpc3RlbiBmb3IgdHJhbnNpdGlvbmVuZCBpZiBpdCB3aWxsIGFuaW1hdGUuXG4gICAgaWYgKCFub0FuaW1hdGlvbikge1xuICAgICAgLy8gR29pbmcgdG8gYSBuZXcgc2xpZGUsIHdhaXQgZm9yIGNhbGxiYWNrLlxuICAgICAgdGhpcy5fdHJhbnNpdGlvbklkID0gb25UcmFuc2l0aW9uRW5kKG5leHRTbGlkZSwgdGhpcy5fdHJhbnNpdGlvbkRvbmUsIHRoaXMpO1xuICAgIH1cblxuICAgIC8vIFNob3cgbmV4dCBzbGlkZS4gUHV0IHRoZSBwcmV2aW91cyBiZWhpbmQgdGhlIG5leHQuXG4gICAgbmV4dFNsaWRlLmNsYXNzTGlzdC5hZGQoQ2Fyb3VzZWwuQ2xhc3Nlcy5WSVNJQkxFKTtcblxuICAgIGlmIChwcmV2aW91c1NsaWRlICE9PSBuZXh0U2xpZGUpIHtcbiAgICAgIHByZXZpb3VzU2xpZGUuY2xhc3NMaXN0LmFkZChDYXJvdXNlbC5DbGFzc2VzLkJFSElORCk7XG5cbiAgICAgIC8vIERlbGF5IHRoZSBwcmV2aW91cyBzbGlkZSBmYWRpbmcgb3V0IGJ5IHRoZSBzcGVjaWZpZWQgcGVyY2VudGFnZS5cbiAgICAgIC8vIFRoZSBjcm9zc2ZhZGUgYW1vdW50IGlzIGJldHdlZW4gMCBhbmQgMS4gQSB2YWx1ZSBvZiAxIG1lYW5zIHRoYXQgYm90aCBzbGlkZXNcbiAgICAgIC8vIHdpbGwgZmFkZSBhdCB0aGUgc2FtZSB0aW1lLiBBIGNyb3NzZmFkZSBvZiB6ZXJvIG1lYW5zIHRoZSBwcmV2aW91cyBzbGlkZVxuICAgICAgLy8gd2lsbCB3YWl0IHVudGlsIHRoZSBuZXh0IHNsaWRlIGhhcyBjb21wbGV0ZWx5IGZhZGVkIGluIGJlZm9yZSBpdCBmYWRlcyBvdXQuXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcHJldmlvdXNTbGlkZS5jbGFzc0xpc3QucmVtb3ZlKENhcm91c2VsLkNsYXNzZXMuVklTSUJMRSk7XG4gICAgICB9LCB0aGlzLl9jcm9zc2ZhZGVUaW1lb3V0KTtcbiAgICB9XG5cbiAgICAvLyBTYXZlIHRoZSBsYXN0IHNsaWRlIGluZGV4LlxuICAgIHRoaXMubGFzdERvbUluZGV4ID0gdGhpcy5kb21JbmRleDtcbiAgICB0aGlzLmRvbUluZGV4ID0gZG9tSW5kZXg7XG5cbiAgICAvLyBFbWl0IGV2ZW50IGZvciBzbGlkZSBzdGFydC5cbiAgICBpZiAoIW5vQW5pbWF0aW9uKSB7XG4gICAgICB0aGlzLl90b05ld1NsaWRlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHb2VzIHRvIGEgZ2l2ZW4gc2xpZGUuXG4gICAqIEBwYXJhbSB7IW51bWJlcn0gZG9tSW5kZXggVGhlIHNsaWRlIGluZGV4IHJlbGF0aXZlIHRvIERPTSBvcmRlci5cbiAgICogQHBhcmFtIHtib29sZWFufSBbbm9BbmltYXRpb25dIFdoZXRoZXIgZ29pbmcgdG8gdGhlIHNsaWRlIHNob3VsZCBhbmltYXRlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLmdvVG9TbGlkZSA9IGZ1bmN0aW9uIGdvVG9TbGlkZShkb21JbmRleCwgbm9BbmltYXRpb24pIHtcbiAgICAvLyBHZXQgdGhlIGRlc3Rpb24gc2xpZGUgZWxlbWVudCBmcm9tIHRoZSBjdXJyZW50IERPTSBvcmRlci5cbiAgICB2YXIgZGVzdGluYXRpb25TbGlkZSA9IHRoaXMuZ2V0U2xpZGUodGhpcy5fZ2V0TG9naWNhbEluZGV4KGRvbUluZGV4KSk7XG5cbiAgICAvLyBJZiB0aGUgY2Fyb3VzZWwgc2tpcHMgaW5iZXR3ZWVuIHNsaWRlcywgcmVwb3NpdGlvbiB0aGVtLlxuICAgIC8vIERPTSBpbmRleCBpcyByZWFzc2luZ2VkIGhlcmUgYmVjYXVzZSBpZiB0aGUgc2xpZGVzIGFyZSByZXBvc2l0aW9uZWQsXG4gICAgLy8gdGhlIERPTSBpbmRleCBvZiB0aGUgY2Fyb3VzZWwgY2hhbmdlcy5cbiAgICB2YXIgdXBkYXRlZERvbUluZGV4ID0gdGhpcy5fbWF5YmVTZXRKdW1wZWRTbGlkZXMoZG9tSW5kZXgsIG5vQW5pbWF0aW9uKTtcblxuICAgIC8vIFRoZSBwb3NpdGlvbiB0aGUgY29udGFpbmVyIHdpbGwgZ28gdG8uXG4gICAgdmFyIGFkanVzdGVkUG9zaXRpb24gPSB0aGlzLl9nZXROZXdQb3NpdGlvbihkZXN0aW5hdGlvblNsaWRlKSAqIC0xMDAgKyAnJSc7XG5cbiAgICAvLyBTYXZlIHRoZSBsYXN0IHNsaWRlIGluZGV4LlxuICAgIHRoaXMubGFzdERvbUluZGV4ID0gdGhpcy5kb21JbmRleDtcbiAgICB0aGlzLmRvbUluZGV4ID0gdXBkYXRlZERvbUluZGV4O1xuXG4gICAgLy8gU2V0IHRoZSBjc3Mgc3R5bGVzIHRvIG1vdmUgdGhlIGNhcm91c2VsIGVsZW1lbnQuIFRoaXMgYWxzbyBkaXNwYXRjaGVzXG4gICAgLy8gdGhlIHNsaWRlIHN0YXJ0IGV2ZW50IGlmIHRoZSBjYXJvdXNlbCBlbGVtZW50IHdpbGwgbW92ZSB3aXRoIGFuaW1hdGlvbi5cbiAgICB0aGlzLl9tb3ZlVG9Qb3NpdGlvbihhZGp1c3RlZFBvc2l0aW9uLCBub0FuaW1hdGlvbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiBmb3IgZ29pbmcgdG8gYSBnaXZlbiBpbmRleC4gVGhpcyBtZXRob2Qgc2hvdWxkIGJlIHVzZWRcbiAgICogaW5zdGVhZCBvZiB0aGUgcHJpdmF0ZSBvbmUgdG8gYWJzdHJhY3QgdGhlIERPTSBvcmRlciBzdHVmZi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBsb2dpY2FsLCB6ZXJvIGJhc2VkIGluZGV4IG9mIHRoZSBzbGlkZSB5b3Ugd2lzaFxuICAgKiAgICAgdGhlIGNhcm91c2VsIHRvIGdvIHRvLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtub0FuaW1hdGlvbl0gT3B0aW9uYWwgc2tpcCB0aGUgYW5pbWF0aW9uIGluIGdvVG9TbGlkZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgY2Fyb3VzZWwgd2lsbCBnbyB0byB0aGUgc3BlY2lmaWVkIHNsaWRlLlxuICAgKi9cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5zZXRTZWxlY3RlZEluZGV4ID0gZnVuY3Rpb24gc2V0U2VsZWN0ZWRJbmRleChpbmRleCwgbm9BbmltYXRpb24pIHtcbiAgICB2YXIgZG9tSW5kZXggPSB0aGlzLl9nZXREb21JbmRleChpbmRleCk7XG4gICAgdmFyIGNhbk5hdmlnYXRlID0gdGhpcy5fY2FuTmF2aWdhdGUoZG9tSW5kZXgsIG5vQW5pbWF0aW9uKTtcblxuICAgIC8vIFdpbGwgZ28gdGhlIHRoZSBnaXZlIHNsaWRlLlxuICAgIGlmIChjYW5OYXZpZ2F0ZSkge1xuICAgICAgLy8gSWYgdGhlIGV2ZW50J3MgZGVmYXVsdCBhY3Rpb24gd2FzIHByZXZlbnRlZCwgcmV0dXJuIGZhbHNlLlxuICAgICAgaWYgKHRoaXMuX2VtaXRFdmVudChuZXcgQ2Fyb3VzZWxFdmVudChDYXJvdXNlbC5FdmVudFR5cGUuV0lMTF9OQVZJR0FURSwgdGhpcykpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2FuY2VsTW92ZW1lbnQoKTtcblxuICAgICAgdGhpcy5fc2VsZWN0ZWRJbmRleCA9IHRoaXMuX2dldFNhZmVJbmRleChpbmRleCk7XG5cbiAgICAgIC8vIENvbnZlcnQgbmV3IHNhZmUgbG9naWNhbCBpbmRleCB0byBhIERPTSBpbmRleC5cbiAgICAgIGRvbUluZGV4ID0gdGhpcy5fZ2V0RG9tSW5kZXgodGhpcy5fc2VsZWN0ZWRJbmRleCk7XG5cbiAgICAgIC8vIFNldCBuZXcgY2xhc3NlcyBvbiB0aGUgc2xpZGUgZWxlbWVudHMuIFRoaXMgaXMgYWxzbyB3aGVyZSB0b2dnbGluZ1xuICAgICAgLy8gcGFkZGxlcyBhbmQgcGFnaW5hdGlvbiBzaG91bGQgZ28uXG4gICAgICB0aGlzLl9zZXRTbGlkZXNTdGF0ZSgpO1xuICAgICAgdGhpcy5fc2V0UGFkZGxlU3RhdGUoKTtcbiAgICAgIHRoaXMuX3NldFBhZ2luYXRpb25TdGF0ZSgpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5pc0ZhZGUpIHtcbiAgICAgICAgdGhpcy5mYWRlVG9TbGlkZShkb21JbmRleCwgbm9BbmltYXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5nb1RvU2xpZGUoZG9tSW5kZXgsIG5vQW5pbWF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIGl0IHdpbGwgbm90IGdvIHRvIHRoZSBnaXZlIHNsaWRlIGR1ZSB0byB1bm1ldCBjb25kaXRpb25zLlxuICAgIHJldHVybiBjYW5OYXZpZ2F0ZTtcbiAgfTtcblxuICAvKipcbiAgICogRmluZCB0aGUgbmVhcmVzdCBzbGlkZSwgYW5kIG1vdmUgdGhlIGNhcm91c2VsIHRvIHRoYXQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzTmV4dF0gV2hldGhlciBpdCBzaG91bGQgZ28gdG8gdGhlIG5lYXJlc3Qgc2xpZGUsIGJ1dFxuICAgKiAgICAgb25seSBpbiB0aGUgbmV4dCBkaXJlY3Rpb24uIEZhbHNlIG1lYW5zIGl0IHNob3VsZCBnbyBwcmV2aW91cyBhbmRcbiAgICogICAgIGFueXRoaW5nIG5vdCB0cnVlIG9yIGZhbHNlIHdpbGwgZ28gdG8gdGhlIG5lYXJlc3Qgc2xpZGUgcmVnYXJkbGVzc1xuICAgKiAgICAgb2YgZGlyZWN0aW9uLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBjYXJvdXNlbCB3aWxsIGdvIHRvIHRoZSBzcGVjaWZpZWQgc2xpZGUuXG4gICAqL1xuXG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLmdvVG9OZWFyZXN0U2xpZGUgPSBmdW5jdGlvbiBnb1RvTmVhcmVzdFNsaWRlKGlzTmV4dCkge1xuICAgIC8vIEdldHMgcG9zaXRpb25zIHJlbGF0aXZlIHRvIHRoZSB3cmFwcGVyIGVsZW1lbnQgb2YgZWFjaCBzbGlkZS5cbiAgICB2YXIgcG9zaXRpb25zID0gdGhpcy5fZ2V0UG9zaXRpb25zKHRoaXMuZ2V0U2xpZGVzKCkpO1xuXG4gICAgLy8gQ3VycmVudCBwb3NpdGlvbiAodGhlIGxlZnQgc2lkZSBvZiB0aGUgY2Fyb3VzZWwgd3JhcHBlcilcbiAgICAvLyBHZXRzIHRoZSBjbG9zZXN0IHZhbHVlIGluIHRoZSBhcnJheSB0byB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAgLy8gSW5kZXggb2YgdGhlIGNsb3Nlc3QgdmFsdWUuXG4gICAgdmFyIGxvZ2ljYWxJbmRleCA9IHBvc2l0aW9ucy5pbmRleE9mKGNsb3Nlc3QocG9zaXRpb25zLCB0aGlzLl9zdGFydEVkZ2UpKTtcblxuICAgIC8vIFdoZW4gZ29pbmcgdG8gYSBuZXh0IG9yIHByZXZpb3VzIHNsaWRlLCB0aGUgY2xvc2VzdCBpbmRleCBjb3VsZFxuICAgIC8vIHN0aWxsIGJlIHRoZSBvbmUgdGhhdCdzIGN1cnJlbnRseSBzZWxlY3RlZCwgYnV0IHRoZSBjYXJvdXNlbCBzaG91bGRcbiAgICAvLyBzdGlsbCBtb3ZlIG5leHQvcHJldmlvdXMgYmVjYXVzZSBpdCBoYXMgZW5vdWdoIHZlbG9jaXR5LlxuICAgIGlmIChsb2dpY2FsSW5kZXggPT09IHRoaXMuZ2V0U2VsZWN0ZWRJbmRleCgpKSB7XG4gICAgICBpZiAoaXNOZXh0ID09PSB0cnVlKSB7XG4gICAgICAgIGxvZ2ljYWxJbmRleCA9IHRoaXMuX2dldFNhZmVJbmRleChsb2dpY2FsSW5kZXggKyAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNOZXh0ID09PSBmYWxzZSkge1xuICAgICAgICBsb2dpY2FsSW5kZXggPSB0aGlzLl9nZXRTYWZlSW5kZXgobG9naWNhbEluZGV4IC0gMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2V0U2VsZWN0ZWRJbmRleChsb2dpY2FsSW5kZXgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHbyB0byB0aGUgbmV4dCBzbGlkZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgY2Fyb3VzZWwgd2lsbCBnbyB0byB0aGUgc3BlY2lmaWVkIHNsaWRlLlxuICAgKi9cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5nb1RvTmV4dFNsaWRlID0gZnVuY3Rpb24gZ29Ub05leHRTbGlkZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRTZWxlY3RlZEluZGV4KHRoaXMuZ2V0U2VsZWN0ZWRJbmRleCgpICsgMSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdvIHRvIHRoZSBwcmV2aW91cyBzbGlkZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgY2Fyb3VzZWwgd2lsbCBnbyB0byB0aGUgc3BlY2lmaWVkIHNsaWRlLlxuICAgKi9cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5nb1RvUHJldmlvdXNTbGlkZSA9IGZ1bmN0aW9uIGdvVG9QcmV2aW91c1NsaWRlKCkge1xuICAgIHJldHVybiB0aGlzLnNldFNlbGVjdGVkSW5kZXgodGhpcy5nZXRTZWxlY3RlZEluZGV4KCkgLSAxKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB0aGUgcGFzdCwgcHJldmlvdXMsIGFjdGl2ZSwgbmV4dCwgYW5kIGZ1dHVyZSBjbGFzc2VzIHRvIHRoZSBhcHByb3ByaWF0ZVxuICAgKiBzbGlkZXMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLl9zZXRTbGlkZXNTdGF0ZSA9IGZ1bmN0aW9uIF9zZXRTbGlkZXNTdGF0ZSgpIHtcbiAgICB2YXIgc2VsZWN0ZWRJbmRleCA9IHRoaXMuZ2V0U2VsZWN0ZWRJbmRleCgpO1xuICAgIHZhciBwYXN0ID0gdGhpcy5fZ2V0U2FmZUluZGV4KHNlbGVjdGVkSW5kZXggLSAyKTtcbiAgICB2YXIgcHJldmlvdXMgPSB0aGlzLl9nZXRTYWZlSW5kZXgoc2VsZWN0ZWRJbmRleCAtIDEpO1xuICAgIHZhciBuZXh0ID0gdGhpcy5fZ2V0U2FmZUluZGV4KHNlbGVjdGVkSW5kZXggKyAxKTtcbiAgICB2YXIgZnV0dXJlID0gdGhpcy5fZ2V0U2FmZUluZGV4KHNlbGVjdGVkSW5kZXggKyAyKTtcblxuICAgIC8vIFRoaXMgd29ya3MgYmVjYXVzZSB0aGUgX3NsaWRlcyBhcnJheSBkb2VzIG5vdCBtaW1pYyB0aGUgRE9NIG9yZGVyLlxuICAgIHRoaXMuZ2V0U2xpZGVzKCkuZm9yRWFjaChmdW5jdGlvbiAoc2xpZGUsIGkpIHtcbiAgICAgIHZhciBpc0FjdGl2ZSA9IGkgPT09IHNlbGVjdGVkSW5kZXg7XG5cbiAgICAgIHRvZ2dsZUZvY3VzYWJpbGl0eShzbGlkZSwgaXNBY3RpdmUpO1xuXG4gICAgICBzbGlkZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgIWlzQWN0aXZlKTtcblxuICAgICAgLy8gQWN0aXZlIHNsaWRlLlxuICAgICAgc2xpZGUuY2xhc3NMaXN0LnRvZ2dsZShDYXJvdXNlbC5DbGFzc2VzLkFDVElWRV9TTElERSwgaXNBY3RpdmUpO1xuXG4gICAgICAvLyBQcmV2aW91cyBwcmV2aW91cyBzbGlkZS5cbiAgICAgIHNsaWRlLmNsYXNzTGlzdC50b2dnbGUoQ2Fyb3VzZWwuQ2xhc3Nlcy5QQVNUX1NMSURFLCBpID09PSBwYXN0ICYmIHNlbGVjdGVkSW5kZXggIT09IHBhc3QgJiYgcHJldmlvdXMgIT09IHBhc3QpO1xuXG4gICAgICAvLyBQcmV2aW91cyBzbGlkZS5cbiAgICAgIHNsaWRlLmNsYXNzTGlzdC50b2dnbGUoQ2Fyb3VzZWwuQ2xhc3Nlcy5QUkVWSU9VU19TTElERSwgaSA9PT0gcHJldmlvdXMgJiYgc2VsZWN0ZWRJbmRleCAhPT0gcHJldmlvdXMpO1xuXG4gICAgICAvLyBOZXh0IHNsaWRlLlxuICAgICAgc2xpZGUuY2xhc3NMaXN0LnRvZ2dsZShDYXJvdXNlbC5DbGFzc2VzLk5FWFRfU0xJREUsIGkgPT09IG5leHQgJiYgc2VsZWN0ZWRJbmRleCAhPT0gbmV4dCk7XG5cbiAgICAgIC8vIE5leHQgbmV4dCBzbGlkZS5cbiAgICAgIHNsaWRlLmNsYXNzTGlzdC50b2dnbGUoQ2Fyb3VzZWwuQ2xhc3Nlcy5GVVRVUkVfU0xJREUsIGkgPT09IGZ1dHVyZSAmJiBzZWxlY3RlZEluZGV4ICE9PSBmdXR1cmUgJiYgbmV4dCAhPT0gZnV0dXJlKTtcbiAgICB9KTtcbiAgfTtcblxuICBDYXJvdXNlbC5wcm90b3R5cGUuX3NldFBhZ2luYXRpb25TdGF0ZSA9IGZ1bmN0aW9uIF9zZXRQYWdpbmF0aW9uU3RhdGUoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5wYWdpbmF0aW9uKSB7XG4gICAgICB2YXIgc2VsZWN0ZWRJbmRleCA9IHRoaXMuZ2V0U2VsZWN0ZWRJbmRleCgpO1xuICAgICAgdGhpcy5fcGFnaW5hdGlvbkRvdHMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgZG90ID0gX3JlZi5kb3QsXG4gICAgICAgICAgICBpID0gX3JlZi5pLFxuICAgICAgICAgICAgaTIgPSBfcmVmLmkyO1xuXG4gICAgICAgIHZhciBzZWxlY3RlZCA9IHNlbGVjdGVkSW5kZXggPT09IGkgfHwgc2VsZWN0ZWRJbmRleCA9PT0gaTI7XG4gICAgICAgIGRvdC5jbGFzc0xpc3QudG9nZ2xlKENhcm91c2VsLkNsYXNzZXMuUEFHSU5BVElPTl9ET1RfU0VMRUNURUQsIHNlbGVjdGVkKTtcbiAgICAgICAgZG90LnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsIHNlbGVjdGVkKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBDYXJvdXNlbC5wcm90b3R5cGUuX3NldFBhZGRsZVN0YXRlID0gZnVuY3Rpb24gX3NldFBhZGRsZVN0YXRlKCkge1xuICAgIHZhciBub3RMb29wZWQgPSAhdGhpcy5vcHRpb25zLmlzTG9vcGVkO1xuICAgIGlmIChub3RMb29wZWQgJiYgdGhpcy5fcGFkZGxlUHJldmlvdXMpIHtcbiAgICAgIHZhciBmaXJzdCA9IHRoaXMuaXNGaXJzdFNsaWRlKCk7XG4gICAgICB0aGlzLl9wYWRkbGVQcmV2aW91cy5jbGFzc0xpc3QudG9nZ2xlKENhcm91c2VsLkNsYXNzZXMuUEFERExFX0RJU0FCTEVELCBmaXJzdCk7XG4gICAgICB0aGlzLl9wYWRkbGVQcmV2aW91cy5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCBmaXJzdCk7XG4gICAgfVxuXG4gICAgaWYgKG5vdExvb3BlZCAmJiB0aGlzLl9wYWRkbGVOZXh0KSB7XG4gICAgICB2YXIgbGFzdCA9IHRoaXMuaXNMYXN0U2xpZGUoKTtcbiAgICAgIHRoaXMuX3BhZGRsZU5leHQuY2xhc3NMaXN0LnRvZ2dsZShDYXJvdXNlbC5DbGFzc2VzLlBBRERMRV9ESVNBQkxFRCwgbGFzdCk7XG4gICAgICB0aGlzLl9wYWRkbGVOZXh0LnNldEF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcsIGxhc3QpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZm9yIHdoZW4gdGhlIHNsaWRlc2hvdyB0aW1lciBleHBpcmVzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5fc2xpZGVzaG93VGltZXJFeHBpcmVkID0gZnVuY3Rpb24gX3NsaWRlc2hvd1RpbWVyRXhwaXJlZCgpIHtcbiAgICAvLyBQYXVzZSB0aGUgdGltZXIgaWYgaXQncyBhdCB0aGUgZW5kLlxuICAgIGlmICghdGhpcy5vcHRpb25zLmlzTG9vcGVkICYmIHRoaXMuaXNMYXN0U2xpZGUoKSkge1xuICAgICAgdGhpcy5wYXVzZVNsaWRlc2hvdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmdvVG9OZXh0U2xpZGUoKTtcbiAgICB9XG4gIH07XG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLl90cmFuc2l0aW9uRG9uZSA9IGZ1bmN0aW9uIF90cmFuc2l0aW9uRG9uZSgpIHtcbiAgICB2YXIgZnJvbSA9IHRoaXMuX2dldExvZ2ljYWxJbmRleCh0aGlzLmxhc3REb21JbmRleCk7XG4gICAgdmFyIHRvID0gdGhpcy5fZ2V0TG9naWNhbEluZGV4KHRoaXMuZG9tSW5kZXgpO1xuXG4gICAgLy8gTmVlZHMgdG8gY29tZSBiZWZvcmUgc2V0dGluZyBuZWlnaGJvciBzbGlkZXMuXG4gICAgdGhpcy5pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLl9pc0p1bXBlZCkge1xuICAgICAgdGhpcy5fc2V0U2xpZGVzVG9Mb2dpY2FsT3JkZXIoKTtcbiAgICB9XG5cbiAgICAvLyBOZWlnaGJvcmluZyBzbGlkZXMgbXVzdCBiZSBzZXQgYWZ0ZXIgZWFjaCB0cmFuc2l0aW9uIGZvciBsb29wZWQgY2Fyb3VzZWxzLlxuICAgIGlmICh0aGlzLl9pc1NsaWRpbmdMb29wZWQpIHtcbiAgICAgIHRoaXMuX3NldE5laWdoYm9yU2xpZGVzKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2lzSnVtcGVkIHx8IHRoaXMuX2lzU2xpZGluZ0xvb3BlZCkge1xuICAgICAgdGhpcy5fc25hcFRvQ3VycmVudFNsaWRlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5pc0ZhZGUpIHtcbiAgICAgIHRoaXMuZ2V0U2xpZGUoZnJvbSkuY2xhc3NMaXN0LnJlbW92ZShDYXJvdXNlbC5DbGFzc2VzLkJFSElORCk7XG4gICAgfVxuXG4gICAgLy8gTm8gbG9uZ2VyIGp1bXBlZC5cbiAgICB0aGlzLl9pc0p1bXBlZCA9IGZhbHNlO1xuXG4gICAgLy8gRGlzcGF0Y2ggc2xpZGUgZW5kIGV2ZW50LlxuICAgIHRoaXMuX2VtaXRFdmVudChuZXcgQ2Fyb3VzZWxFdmVudChDYXJvdXNlbC5FdmVudFR5cGUuU0xJREVfRU5ELCB0aGlzLCBmcm9tLCB0bykpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWNlaXZlZCB0aGUgcG9pbnRlciBlbmQgZXZlbnQuXG4gICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBwb2ludGVyRXZlbnQgUG9pbnRlciBldmVudCBvYmplY3QuXG4gICAqL1xuXG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLl9oYW5kbGVQb2ludGVyRW5kID0gZnVuY3Rpb24gX2hhbmRsZVBvaW50ZXJFbmQocG9pbnRlckV2ZW50KSB7XG4gICAgaWYgKHRoaXMucG9pbnRlci5oYXNWZWxvY2l0eShwb2ludGVyRXZlbnQudmVsb2NpdHkpKSB7XG4gICAgICBpZiAocG9pbnRlckV2ZW50LmRpcmVjdGlvbiA9PT0gT2RvUG9pbnRlci5EaXJlY3Rpb24uUklHSFQpIHtcbiAgICAgICAgdGhpcy5nb1RvUHJldmlvdXNTbGlkZSgpO1xuICAgICAgfSBlbHNlIGlmIChwb2ludGVyRXZlbnQuZGlyZWN0aW9uID09PSBPZG9Qb2ludGVyLkRpcmVjdGlvbi5MRUZUKSB7XG4gICAgICAgIHRoaXMuZ29Ub05leHRTbGlkZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVGhlIGNsaWNrIGxpc3RlbmVyIGlzIGJvdW5kIHRvIHRoZSBtYWluIGVsZW1lbnQuIEluc2lkZSB0aGUgaGFuZGxlciwgdGhlIHRhcmdldFxuICAgKiBvZiB0aGUgY2xpY2sgaXMgdGVzdGVkIGFuZCBpZiBpdCBpcyBhIHBhZ2luYXRpb24gZG90IG9yIHBhZGRsZSwgbmF2aWdhdGlvblxuICAgKiB3aWxsIGJlIHN0YXJ0ZWQuXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2dCBFdmVudCBvYmplY3QuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLl9oYW5kbGVDbGljayA9IGZ1bmN0aW9uIF9oYW5kbGVDbGljayhldnQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZXZ0LnRhcmdldDtcblxuICAgIHZhciB3aWxsTmF2aWdhdGUgPSBmYWxzZTtcblxuICAgIC8vIERldGVybWluZSB3aGF0IHdhcyBjbGlja2VkLlxuICAgIHZhciBkb3QgPSB0YXJnZXQuY2xvc2VzdCgnLicgKyBDYXJvdXNlbC5DbGFzc2VzLlBBR0lOQVRJT05fRE9UKTtcbiAgICB2YXIgcHJldiA9IHRhcmdldC5jbG9zZXN0KCcuJyArIENhcm91c2VsLkNsYXNzZXMuUEFERExFX1BSRVYpO1xuICAgIHZhciBuZXh0ID0gdGFyZ2V0LmNsb3Nlc3QoJy4nICsgQ2Fyb3VzZWwuQ2xhc3Nlcy5QQURETEVfTkVYVCk7XG5cbiAgICAvLyBOYXZpZ2F0aW9uIGRvdC5cbiAgICBpZiAoZG90KSB7XG4gICAgICB3aWxsTmF2aWdhdGUgPSB0cnVlO1xuICAgICAgdGhpcy5zZXRTZWxlY3RlZEluZGV4KHBhcnNlSW50KGRvdC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaW5kZXgnKSwgMTApKTtcblxuICAgICAgLy8gTGVmdCBwYWRkbGUgb3IgY2hpbGQgb2YgbGVmdCBwYWRkbGUuXG4gICAgfSBlbHNlIGlmIChwcmV2KSB7XG4gICAgICB3aWxsTmF2aWdhdGUgPSB0cnVlO1xuICAgICAgdGhpcy5nb1RvUHJldmlvdXNTbGlkZSgpO1xuXG4gICAgICAvLyBSaWdodCBwYWRkbGUgb3IgY2hpbGQgb2YgcmlnaHQgcGFkZGxlLlxuICAgIH0gZWxzZSBpZiAobmV4dCkge1xuICAgICAgd2lsbE5hdmlnYXRlID0gdHJ1ZTtcbiAgICAgIHRoaXMuZ29Ub05leHRTbGlkZSgpO1xuXG4gICAgICAvLyBJZiB0aGUgY2Fyb3VzZWwgc2xpZGVzIGhhdmUgbGlua3MgaW4gdGhlbSwgc29tZSBicm93c2VycyAoRmlyZWZveCksIHdpbGxcbiAgICAgIC8vIGVtaXQgdGhlIGNsaWNrIGV2ZW50IGV2ZW4gYWZ0ZXIgYSBkcmFnIGlmIHRoZSBtb3VzZSBpcyBzdGlsbCBvbiB0aGVcbiAgICAgIC8vIGNsaWNrYWJsZSBlbGVtZW50LlxuICAgIH0gZWxzZSBpZiAodGhpcy5pc1RyYW5zaXRpb25pbmcpIHtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIGlmICh3aWxsTmF2aWdhdGUpIHtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAvLyBQYXVzZSBzbGlkZXNob3cgaWYgaXQncyBwbGF5aW5nLlxuICAgICAgdGhpcy5wYXVzZVNsaWRlc2hvdygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU3RvcCBhbmltYXRpb25zIHRoYXQgd2VyZSBvbmdvaW5nIHdoZW4geW91IHN0YXJ0ZWQgdG8gZHJhZy5cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuX2hhbmRsZURyYWdTdGFydCA9IGZ1bmN0aW9uIF9oYW5kbGVEcmFnU3RhcnQoKSB7XG4gICAgdGhpcy5wYXVzZVNsaWRlc2hvdygpO1xuICAgIHRoaXMuX2NhbmNlbE1vdmVtZW50KCk7XG5cbiAgICAvLyBSZW1vdmUgdHJhbnNpdGlvbiB3aGlsZSBkcmFnZ2luZy5cbiAgICB0aGlzLl9jYXJvdXNlbEVsLnN0eWxlW09kb0RldmljZS5Eb20uVFJBTlNJVElPTl9EVVJBVElPTl0gPSAnMG1zJztcbiAgfTtcblxuICAvKipcbiAgICogUG9pbnRlciBtb3ZlIGV2ZW50LiBTZXQgYSBmcmljdGlvbiB2YWx1ZSBpZiBvbiB0aGUgZmlyc3QvbGFzdCBzbGlkZSBhbmRcbiAgICogZ29pbmcgdG93YXJkcyB0aGUgZWRnZS5cbiAgICogQHBhcmFtIHtQb2ludGVyRXZlbnR9IGV2dCBQb2ludGVyIGV2ZW50IGVtaXR0ZWQgYnkgZHJhZ2dhYmxlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5faGFuZGxlRHJhZ01vdmUgPSBmdW5jdGlvbiBfaGFuZGxlRHJhZ01vdmUoX3JlZjIpIHtcbiAgICB2YXIgZGVsdGEgPSBfcmVmMi5kZWx0YTtcblxuICAgIHRoaXMuaGFzRHJhZ2dlZCA9IHRoaXMuaXNWZXJ0aWNhbCA/IE1hdGguYWJzKGRlbHRhLnkpID4gMCA6IE1hdGguYWJzKGRlbHRhLngpID4gMDtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5pc0xvb3BlZCkge1xuICAgICAgdmFyIGZyaWN0aW9uID0gdGhpcy5faXNNb3ZpbmdUb3dhcmRzRWRnZShkZWx0YS54LCBkZWx0YS55KSA/IDAuNCA6IDE7XG4gICAgICB0aGlzLmRyYWdnYWJsZS5mcmljdGlvbiA9IGZyaWN0aW9uO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRGVwZW5kaW5nIG9uIGhvdyBmYXN0IHlvdSB3ZXJlIGRyYWdnaW5nLCBlaXRoZXIgcHJvY2VlZCB0byBhbiBhZGphY2VudFxuICAgKiBzbGlkZSBvciByZXNldCBwb3NpdGlvbiB0byB0aGUgbmVhcmVzdCBvbmUuXG4gICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBldnQgUG9pbnRlciBldmVudCBlbWl0dGVkIGJ5IGRyYWdnYWJsZS5cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuX2hhbmRsZURyYWdFbmQgPSBmdW5jdGlvbiBfaGFuZGxlRHJhZ0VuZChldnQpIHtcbiAgICB0aGlzLmRyYWdnYWJsZS5mcmljdGlvbiA9IDE7XG4gICAgdGhpcy5uYXZpZ2F0ZUFmdGVyRHJhZyhldnQudmVsb2NpdHksIGV2dC5heGlzRGlyZWN0aW9uLCBldnQuZGlkTW92ZU9uQXhpcyk7XG4gICAgdGhpcy5oYXNEcmFnZ2VkID0gZmFsc2U7XG4gICAgdGhpcy5faXNPZmZzZXQgPSBmYWxzZTtcbiAgfTtcblxuICBDYXJvdXNlbC5wcm90b3R5cGUuX3Nob3VsZEdvVG9QcmV2aW91cyA9IGZ1bmN0aW9uIF9zaG91bGRHb1RvUHJldmlvdXMoaGFzVmVsb2NpdHksIGRpcmVjdGlvbikge1xuICAgIHJldHVybiBoYXNWZWxvY2l0eSAmJiAodGhpcy5vcHRpb25zLmlzTG9vcGVkIHx8ICF0aGlzLmlzRmlyc3RTbGlkZSgpKSAmJiAoZGlyZWN0aW9uID09PSBPZG9Qb2ludGVyLkRpcmVjdGlvbi5SSUdIVCB8fCBkaXJlY3Rpb24gPT09IE9kb1BvaW50ZXIuRGlyZWN0aW9uLkRPV04pO1xuICB9O1xuXG4gIENhcm91c2VsLnByb3RvdHlwZS5fc2hvdWxkR29Ub05leHQgPSBmdW5jdGlvbiBfc2hvdWxkR29Ub05leHQoaGFzVmVsb2NpdHksIGRpcmVjdGlvbikge1xuICAgIHJldHVybiBoYXNWZWxvY2l0eSAmJiAodGhpcy5vcHRpb25zLmlzTG9vcGVkIHx8ICF0aGlzLmlzTGFzdFNsaWRlKCkpICYmIChkaXJlY3Rpb24gPT09IE9kb1BvaW50ZXIuRGlyZWN0aW9uLkxFRlQgfHwgZGlyZWN0aW9uID09PSBPZG9Qb2ludGVyLkRpcmVjdGlvbi5VUCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlY2lkZSB3aGF0IHRvIGRvIGFmdGVyIHRoZSB1c2VyIGRyYWdzIHRoZSBjYXJvdXNlbC5cbiAgICogQHBhcmFtIHtDb29yZGluYXRlfSB2ZWxvY2l0eSBWZWxvY2l0eSBmb3IgeCBhbmQgeSBkaXJlY3Rpb25zLlxuICAgKiBAcGFyYW0ge09kb1BvaW50ZXIuRGlyZWN0aW9ufSBkaXJlY3Rpb24gRHJhZyBkaXJlY3Rpb24uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZGlkTW92ZU9uQXhpcyBXaGV0aGVyIHRoZSBkcmFnIGRpcmVjdGlvbiB3YXMgb24gdGhlIGRlZmluZWQgYXhpcy5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5uYXZpZ2F0ZUFmdGVyRHJhZyA9IGZ1bmN0aW9uIG5hdmlnYXRlQWZ0ZXJEcmFnKHZlbG9jaXR5LCBkaXJlY3Rpb24sIGRpZE1vdmVPbkF4aXMpIHtcbiAgICB2YXIgaGFzVmVsb2NpdHkgPSB0aGlzLmhhc0RyYWdnZWQgJiYgdGhpcy5kcmFnZ2FibGUucG9pbnRlci5oYXNWZWxvY2l0eSh2ZWxvY2l0eSk7XG5cbiAgICAvLyBJZiBkcmFnZ2luZyBoYXMgbm90IG9jY3VycmVkLCB0aGUgdXNlciBzaW1wbHkgY2xpY2tlZCBvbiB0aGUgY2Fyb3VzZWwuXG4gICAgLy8gSWYgdGhlIHVzZXIgaXMgcXVpY2tseSBuYXZpZ2F0aW5nIHRocm91Z2ggdGhlIGNhcm91c2VsLCB0aGVuIGNsaWNrcyBvblxuICAgIC8vIGl0LCB0aGUgbW92ZW1lbnQgd2lsbCBiZSBjYW5jZWxlZCwgYnV0IGl0IHdvdWxkbid0IGdvIGFueXdoZXJlIGJlY2F1c2UgaXRcbiAgICAvLyBhcHBlYXJzIHRvIGJlIGdvaW5nIHRvIHRoZSBzYW1lIHNsaWRlLiBEZXRlcm1pbmUgaWYgdGhlIGNhcm91c2VsIGlzIHN0aWxsXG4gICAgLy8gYmV0d2VlbiBzbGlkZXMgKG9mZnNldCkuIElmIGl0IGlzLCBpdCBuZWVkcyB0byBnbyB0byB0aGUgbmVhcmVzdCBzbGlkZS5cbiAgICBpZiAoIXRoaXMuaGFzRHJhZ2dlZCkge1xuICAgICAgdGhpcy5faXNPZmZzZXQgPSBNYXRoLmFicyhNYXRoLnJvdW5kKHRoaXMuX2dldENhcm91c2VsT2Zmc2V0KCkpKSA+IE1hdGgucm91bmQodGhpcy5fc3RhcnRFZGdlKTtcbiAgICB9XG5cbiAgICAvLyBQcmV2aW91cy5cbiAgICBpZiAodGhpcy5fc2hvdWxkR29Ub1ByZXZpb3VzKGhhc1ZlbG9jaXR5LCBkaXJlY3Rpb24pKSB7XG4gICAgICB0aGlzLmdvVG9OZWFyZXN0U2xpZGUoZmFsc2UpO1xuXG4gICAgICAvLyBOZXh0LlxuICAgIH0gZWxzZSBpZiAodGhpcy5fc2hvdWxkR29Ub05leHQoaGFzVmVsb2NpdHksIGRpcmVjdGlvbikpIHtcbiAgICAgIHRoaXMuZ29Ub05lYXJlc3RTbGlkZSh0cnVlKTtcblxuICAgICAgLy8gTm90IGVub3VnaCB2ZWxvY2l0eSwgZ28gdG8gdGhlIG5lYXJlc3Qgc2xpZGUuXG4gICAgICAvLyBUaGUgZGlzdGFuY2UgbXVzdCBhdCBsZWFzdCBiZSAxLCBvdGhlcndpc2UgZ290b1NsaWRlIGNyZWF0ZXMgYW4gZXZlbnRcbiAgICAgIC8vIGxpc3RlbmVyIGZvciBtb3ZpbmcgdGhlIGVsZW1lbnQgYnkgemVybyBwaXhlbHMgYW5kIHRoZSB0cmFuc2l0aW9uIGVuZFxuICAgICAgLy8gZXZlbnQgZG9lc24ndCBmaXJlLlxuICAgIH0gZWxzZSBpZiAoZGlkTW92ZU9uQXhpcyB8fCB0aGlzLl9pc09mZnNldCkge1xuICAgICAgdGhpcy5nb1RvTmVhcmVzdFNsaWRlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBFbWl0cyBhIGV2ZW50IG9uIHRoaXMgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7Q2Fyb3VzZWxFdmVudH0gZXZlbnQgRXZlbnQgb2JqZWN0IHdpdGggZGF0YS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBwcmV2ZW50RGVmYXVsdCB3YXMgY2FsbGVkIG9uIHRoZSBldmVudC5cbiAgICovXG5cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuX2VtaXRFdmVudCA9IGZ1bmN0aW9uIF9lbWl0RXZlbnQoZXZlbnQpIHtcbiAgICB0aGlzLmVtaXQoZXZlbnQudHlwZSwgZXZlbnQpO1xuICAgIHJldHVybiBldmVudC5kZWZhdWx0UHJldmVudGVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBjYXJvdXNlbCBpcyBiZWluZyBkcmFnZ2VkIHRvd2FyZHMgYW4gZWRnZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhWCBDaGFuZ2UgaW4geCBkdXJpbmcgZHJhZy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhWSBDaGFuZ2UgaW4geSBkdXJpbmcgZHJhZy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBDYXJvdXNlbC5wcm90b3R5cGUuX2lzTW92aW5nVG93YXJkc0VkZ2UgPSBmdW5jdGlvbiBfaXNNb3ZpbmdUb3dhcmRzRWRnZShkZWx0YVgsIGRlbHRhWSkge1xuICAgIHZhciB0b1N0YXJ0RWRnZSA9IHRoaXMuaXNWZXJ0aWNhbCA/IGRlbHRhWSA+IDAgOiBkZWx0YVggPiAwO1xuICAgIHZhciB0b0VuZEVkZ2UgPSB0aGlzLmlzVmVydGljYWwgPyBkZWx0YVkgPCAwIDogZGVsdGFYIDwgMDtcblxuICAgIHJldHVybiB0aGlzLmlzRmlyc3RTbGlkZSgpICYmIHRvU3RhcnRFZGdlIHx8IHRoaXMuaXNMYXN0U2xpZGUoKSAmJiB0b0VuZEVkZ2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBldmVudCBsaXN0ZW5lcnMsIERPTSByZWZlcmVuY2VzLCBpbmxpbmUgc3R5bGVzLCBjbGFzcyBuYW1lcywgcGFkZGxlcyxcbiAgICogYW5kIHBhZ2luYXRpb24gYWRkZWQgYnkgQ2Fyb3VzZWwuXG4gICAqL1xuXG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIGlmICh0aGlzLl90aW1lcikge1xuICAgICAgdGhpcy5fdGltZXIuZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX3JlbW92ZUExMXlBdHRyaWJ1dGVzKCk7XG4gICAgdGhpcy5fcmVtb3ZlUGFkZGxlcygpO1xuICAgIHRoaXMuX3JlbW92ZVBhZ2luYXRpb24oKTtcblxuICAgIC8vIFJlc2V0IGNvbnRhaW5lciBzdHlsZXMuXG4gICAgdGhpcy5fY2Fyb3VzZWxFbC5zdHlsZVtPZG9EZXZpY2UuRG9tLlRSQU5TRk9STV0gPSAnJztcbiAgICB0aGlzLl9jYXJvdXNlbEVsLnN0eWxlW09kb0RldmljZS5Eb20uVFJBTlNJVElPTl0gPSAnJztcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuaXNGYWRlKSB7XG4gICAgICB0aGlzLnBvaW50ZXIub2ZmKE9kb1BvaW50ZXIuRXZlbnRUeXBlLkVORCwgdGhpcy5fb25Qb2ludGVyRW5kKTtcbiAgICAgIHRoaXMucG9pbnRlci5kaXNwb3NlKCk7XG5cbiAgICAgIHRoaXMuZ2V0U2xpZGVzKCkuZm9yRWFjaChmdW5jdGlvbiAoc2xpZGUpIHtcbiAgICAgICAgc2xpZGUuc3R5bGVbT2RvRGV2aWNlLkRvbS5UUkFOU0lUSU9OXSA9ICcnO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZHJhZ2dhYmxlLm9mZihPZG9EcmFnZ2FibGUuRXZlbnRUeXBlLlNUQVJULCB0aGlzLl9vbkRyYWdTdGFydCk7XG4gICAgICB0aGlzLmRyYWdnYWJsZS5vZmYoT2RvRHJhZ2dhYmxlLkV2ZW50VHlwZS5NT1ZFLCB0aGlzLl9vbkRyYWdNb3ZlKTtcbiAgICAgIHRoaXMuZHJhZ2dhYmxlLm9mZihPZG9EcmFnZ2FibGUuRXZlbnRUeXBlLkVORCwgdGhpcy5fb25EcmFnRW5kKTtcblxuICAgICAgdGhpcy5kcmFnZ2FibGUuZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uQ2xpY2spO1xuXG4gICAgdGhpcy5fc2xpZGVzLmZvckVhY2goZnVuY3Rpb24gKHNsaWRlKSB7XG4gICAgICBzbGlkZS5jbGFzc0xpc3QucmVtb3ZlKENhcm91c2VsLkNsYXNzZXMuUEFTVF9TTElERSwgQ2Fyb3VzZWwuQ2xhc3Nlcy5QUkVWSU9VU19TTElERSwgQ2Fyb3VzZWwuQ2xhc3Nlcy5BQ1RJVkVfU0xJREUsIENhcm91c2VsLkNsYXNzZXMuTkVYVF9TTElERSwgQ2Fyb3VzZWwuQ2xhc3Nlcy5GVVRVUkVfU0xJREUsIENhcm91c2VsLkNsYXNzZXMuVklTSUJMRSwgQ2Fyb3VzZWwuQ2xhc3Nlcy5CRUhJTkQpO1xuICAgIH0pO1xuXG4gICAgLy8gV2hlbiB0aGUgY2Fyb3VzZWwgaXMgYmlkaXJlY3Rpb25hbCwgaXQgaGFzIGNsb25lZCB0aGUgZmlyc3QgdHdvIHNsaWRlc1xuICAgIC8vIGFuZCBhZGRlZCB0aGVtIHRvIHRoZSBjYXJvdXNlbCBlbGVtZW50LiBSZW1vdmUgdGhlIGNsb25lcy5cbiAgICBpZiAodGhpcy5faXNCaWRpcmVjdGlvbmFsKSB7XG4gICAgICB0aGlzLl9jYXJvdXNlbEVsLnJlbW92ZUNoaWxkKHRoaXMuX3NsaWRlc1syXSk7XG4gICAgICB0aGlzLl9jYXJvdXNlbEVsLnJlbW92ZUNoaWxkKHRoaXMuX3NsaWRlc1szXSk7XG4gICAgfVxuXG4gICAgLy8gTnVsbCBvdXQgRE9NIHJlZnMuXG4gICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLl9zbGlkZUNvbnRhaW5lclBhcmVudEVsID0gbnVsbDtcbiAgICB0aGlzLl9jYXJvdXNlbEVsID0gbnVsbDtcbiAgICB0aGlzLl9wYWRkbGVQcmV2aW91cyA9IG51bGw7XG4gICAgdGhpcy5fcGFkZGxlTmV4dCA9IG51bGw7XG4gICAgdGhpcy5fcGFnaW5hdGlvbkRvdHMgPSBudWxsO1xuICAgIHRoaXMuZHJhZ2dhYmxlID0gbnVsbDtcbiAgICB0aGlzLnBvaW50ZXIgPSBudWxsO1xuICAgIHRoaXMuX3NsaWRlcy5sZW5ndGggPSAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBCZWNhdXNlIE9iamVjdC5hc3NpZ24gb25seSBkb2VzIGEgc2hhbGxvdyBtZXJnZSwgbWVyZ2UgdGhlIHRlbXBsYXRlIG9wdGlvblxuICAgKiBmaXJzdCBhbmQgdGhlbiBvdmVyd3JpdGUgdGhlIG1haW4gT2JqZWN0LmFzc2lnbiByZXN1bHQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IE1lcmdlZCBvcHRpb25zIG9iamVjdCB3aXRoIGRlZmF1bHRzLlxuICAgKi9cblxuXG4gIENhcm91c2VsLmdldE9wdGlvbnMgPSBmdW5jdGlvbiBnZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICB2YXIgdGVtcGxhdGVzID0gT2JqZWN0LmFzc2lnbih7fSwgQ2Fyb3VzZWwuRGVmYXVsdHMudGVtcGxhdGUsIG9wdGlvbnMudGVtcGxhdGUpO1xuICAgIHZhciBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgQ2Fyb3VzZWwuRGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgIG9wdHMudGVtcGxhdGUgPSB0ZW1wbGF0ZXM7XG4gICAgcmV0dXJuIG9wdHM7XG4gIH07XG5cbiAgY3JlYXRlQ2xhc3MoQ2Fyb3VzZWwsIFt7XG4gICAga2V5OiAnaXNFbmFibGVkJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pc0VuYWJsZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlIHRoZSBlbmFibGVkL2Rpc2FibGVkIHN0YXRlIG9mIHRoZSBjYXJvdXNlbC4gV2hlbiBpdCdzIGRpc2FibGVkLCBpdFxuICAgICAqIHdpbGwgbm90IGJlIGFibGUgdG8gbmF2aWdhdGUgc2xpZGVzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZCBXaGV0aGVyIHRvIGVuYWJsZSBvciBkaXNhYmxlLlxuICAgICAqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMShlbmFibGVkKSB7XG4gICAgICB0aGlzLl9pc0VuYWJsZWQgPSBlbmFibGVkO1xuICAgICAgdGhpcy5fc2V0RHJhZ2dhYmxlRW5hYmxlZChlbmFibGVkKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENhcm91c2VsO1xufShUaW55RW1pdHRlcik7XG5cbk9iamVjdC5hc3NpZ24oQ2Fyb3VzZWwsIHNldHRpbmdzKTtcblxuQ2Fyb3VzZWwudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbkNhcm91c2VsLkNhcm91c2VsRXZlbnQgPSBDYXJvdXNlbEV2ZW50O1xuXG4vLyBFeHBvcnQgZm9yIHRlc3RpbmcuXG5DYXJvdXNlbC5fZ2V0VHJhbnNsYXRlID0gZ2V0VHJhbnNsYXRlO1xuXG5leHBvcnQgZGVmYXVsdCBDYXJvdXNlbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9kby1jYXJvdXNlbC5lc20uanMubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@odopod/odo-carousel/dist/odo-carousel.esm.js\n");

/***/ }),

/***/ "./node_modules/@odopod/odo-device/dist/odo-device.esm.js":
/*!****************************************************************!*\
  !*** ./node_modules/@odopod/odo-device/dist/odo-device.esm.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n * Object Model prefixes.\n * @type {Array.<string>}\n * @private\n */\nvar prefixes = ['Webkit', 'Moz', 'O', 'ms'];\n\n/**\n * Prefix lookup cache.\n * @type {Object}\n * @private\n */\nvar prefixCache = {};\n\nfunction isDefined(thing) {\n  return typeof thing !== 'undefined';\n}\n\nfunction getCacheName(property, value, isValueDefined) {\n  if (isValueDefined) {\n    return property + value;\n  }\n\n  return property;\n}\n\nvar element = document.createElement('div');\n\n/**\n * Returns the prefixed style property if it exists.\n * {@link http://perfectionkills.com/feature-testing-css-properties/}\n *\n * @param {string} property The property name.\n * @param {string} [value] Value to set and test. If undefined, this test will\n *     only check that the property exists, not whether it supports the value.\n * @return {string|false} The style property or false.\n */\nfunction prefixed(property, value) {\n  var shouldTestValue = isDefined(value);\n  var cacheName = getCacheName(property, value, shouldTestValue);\n\n  // Check cache.\n  if (isDefined(prefixCache[cacheName])) {\n    return prefixCache[cacheName];\n  }\n\n  var ucProp = property.charAt(0).toUpperCase() + property.slice(1);\n\n  // Create an array of prefixed properties. ['transform', 'WebkitTransform'].\n  var props = (property + ' ' + prefixes.join(ucProp + ' ') + ucProp).split(' ');\n  var style = element.style;\n\n\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    var before = style[prop];\n\n    // Check the existence of the property.\n    if (isDefined(before)) {\n      // Test if the value sticks after setting it.\n      if (shouldTestValue) {\n        style[prop] = value;\n\n        // If the property value has changed, assume the value used is supported.\n        if (style[prop] !== before) {\n          prefixCache[cacheName] = prop;\n          return prop;\n        }\n      } else {\n        prefixCache[cacheName] = prop;\n        return prop;\n      }\n    }\n  }\n\n  prefixCache[cacheName] = false;\n  return false;\n}\n\n/**\n * Hyphenates a javascript style string to a css one. For example:\n * MozBoxSizing -> -moz-box-sizing.\n *\n * @param {string|false} str The string to hyphenate.\n * @return {string} The hyphenated string.\n */\nfunction hyphenate(str) {\n  // Catch booleans.\n  if (!str) {\n    return '';\n  }\n\n  // Turn MozBoxSizing into -moz-box-sizing.\n  return str.replace(/([A-Z])/g, function (str, m1) {\n    return '-' + m1.toLowerCase();\n  }).replace(/^ms-/, '-ms-');\n}\n\n/**\n * Prefixed style properties.\n * @type {{[key: string]: string|false}}\n */\nvar Dom = {\n  ANIMATION: prefixed('animation'),\n  ANIMATION_DURATION: prefixed('animationDuration'),\n  TRANSFORM: prefixed('transform'),\n  TRANSITION: prefixed('transition'),\n  TRANSITION_PROPERTY: prefixed('transitionProperty'),\n  TRANSITION_DURATION: prefixed('transitionDuration'),\n  TRANSITION_TIMING_FUNCTION: prefixed('transitionTimingFunction'),\n  TRANSITION_DELAY: prefixed('transitionDelay')\n};\n\n/**\n * Prefixed css properties.\n * @type {{[key: string]: string}}\n */\nvar Css = {\n  ANIMATION: hyphenate(Dom.ANIMATION),\n  ANIMATION_DURATION: hyphenate(Dom.ANIMATION_DURATION),\n  TRANSFORM: hyphenate(Dom.TRANSFORM),\n  TRANSITION: hyphenate(Dom.TRANSITION),\n  TRANSITION_PROPERTY: hyphenate(Dom.TRANSITION_PROPERTY),\n  TRANSITION_DURATION: hyphenate(Dom.TRANSITION_DURATION),\n  TRANSITION_TIMING_FUNCTION: hyphenate(Dom.TRANSITION_TIMING_FUNCTION),\n  TRANSITION_DELAY: hyphenate(Dom.TRANSITION_DELAY)\n};\n\n/**\n * Whether the browser has css transitions.\n * @type {boolean}\n */\nvar HAS_TRANSITIONS = Dom.TRANSITION !== false;\n\n/**\n * Whether the browser has css animations.\n * @type {boolean}\n */\nvar HAS_CSS_ANIMATIONS = Dom.ANIMATION !== false;\n\n/**\n * Whether the browser has css transitions.\n * @type {boolean}\n */\nvar HAS_TRANSFORMS = Dom.TRANSFORM !== false;\n\n/**\n * The browser can use css transitions and transforms.\n * @type {boolean}\n */\nvar CAN_TRANSITION_TRANSFORMS = HAS_TRANSITIONS && HAS_TRANSFORMS;\n\n/* istanbul ignore next */\n/**\n * Whether the browser supports touch events.\n * @type {boolean}\n */\nvar HAS_TOUCH_EVENTS = 'ontouchstart' in window || !!window.DocumentTouch && document instanceof window.DocumentTouch;\n\n/**\n * Whether the browser supports pointer events.\n * @type {boolean}\n */\nvar HAS_POINTER_EVENTS = !!window.PointerEvent;\n\n/**\n * Whether the browser supports `localStorage`. Safari in private browsing\n * throws an error when calling `setItem`.\n * @type {boolean}\n */\nvar HAS_LOCAL_STORAGE = function () {\n  try {\n    var testKey = 'test';\n    localStorage.setItem(testKey, '1');\n    localStorage.removeItem(testKey);\n    return true;\n  } catch (error) {\n    /* istanbul ignore next */\n    return false;\n  }\n}();\n\n/**\n * Whether the browser supports the `passive` property in `EventListenerOptions`.\n * @type {boolean}\n */\nvar HAS_PASSIVE_LISTENERS = function () {\n  var supportsPassiveOption = false;\n  try {\n    var options = {\n      get passive /* istanbul ignore next */() {\n        // eslint-disable-line getter-return\n        supportsPassiveOption = true;\n      }\n    };\n\n    window.addEventListener('test', null, options);\n    return supportsPassiveOption;\n  } catch (e) {\n    /* istanbul ignore next */\n    return false;\n  }\n}();\n\n// Export everything as an object otherwise other components are unable to stub\n// properties because webpack writes them as getters and non-configurable.\nvar device = {\n  prefixed: prefixed,\n  hyphenate: hyphenate,\n  Dom: Dom,\n  Css: Css,\n  HAS_TRANSITIONS: HAS_TRANSITIONS,\n  HAS_CSS_ANIMATIONS: HAS_CSS_ANIMATIONS,\n  HAS_TRANSFORMS: HAS_TRANSFORMS,\n  CAN_TRANSITION_TRANSFORMS: CAN_TRANSITION_TRANSFORMS,\n  HAS_TOUCH_EVENTS: HAS_TOUCH_EVENTS,\n  HAS_POINTER_EVENTS: HAS_POINTER_EVENTS,\n  HAS_LOCAL_STORAGE: HAS_LOCAL_STORAGE,\n  HAS_PASSIVE_LISTENERS: HAS_PASSIVE_LISTENERS\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (device);\n//# sourceMappingURL=odo-device.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG9kb3BvZC9vZG8tZGV2aWNlL2Rpc3Qvb2RvLWRldmljZS5lc20uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG9kb3BvZC9vZG8tZGV2aWNlL2Rpc3Qvb2RvLWRldmljZS5lc20uanM/YTVjZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE9iamVjdCBNb2RlbCBwcmVmaXhlcy5cbiAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ01veicsICdPJywgJ21zJ107XG5cbi8qKlxuICogUHJlZml4IGxvb2t1cCBjYWNoZS5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgcHJlZml4Q2FjaGUgPSB7fTtcblxuZnVuY3Rpb24gaXNEZWZpbmVkKHRoaW5nKSB7XG4gIHJldHVybiB0eXBlb2YgdGhpbmcgIT09ICd1bmRlZmluZWQnO1xufVxuXG5mdW5jdGlvbiBnZXRDYWNoZU5hbWUocHJvcGVydHksIHZhbHVlLCBpc1ZhbHVlRGVmaW5lZCkge1xuICBpZiAoaXNWYWx1ZURlZmluZWQpIHtcbiAgICByZXR1cm4gcHJvcGVydHkgKyB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBwcm9wZXJ0eTtcbn1cblxudmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwcmVmaXhlZCBzdHlsZSBwcm9wZXJ0eSBpZiBpdCBleGlzdHMuXG4gKiB7QGxpbmsgaHR0cDovL3BlcmZlY3Rpb25raWxscy5jb20vZmVhdHVyZS10ZXN0aW5nLWNzcy1wcm9wZXJ0aWVzL31cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIHByb3BlcnR5IG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3ZhbHVlXSBWYWx1ZSB0byBzZXQgYW5kIHRlc3QuIElmIHVuZGVmaW5lZCwgdGhpcyB0ZXN0IHdpbGxcbiAqICAgICBvbmx5IGNoZWNrIHRoYXQgdGhlIHByb3BlcnR5IGV4aXN0cywgbm90IHdoZXRoZXIgaXQgc3VwcG9ydHMgdGhlIHZhbHVlLlxuICogQHJldHVybiB7c3RyaW5nfGZhbHNlfSBUaGUgc3R5bGUgcHJvcGVydHkgb3IgZmFsc2UuXG4gKi9cbmZ1bmN0aW9uIHByZWZpeGVkKHByb3BlcnR5LCB2YWx1ZSkge1xuICB2YXIgc2hvdWxkVGVzdFZhbHVlID0gaXNEZWZpbmVkKHZhbHVlKTtcbiAgdmFyIGNhY2hlTmFtZSA9IGdldENhY2hlTmFtZShwcm9wZXJ0eSwgdmFsdWUsIHNob3VsZFRlc3RWYWx1ZSk7XG5cbiAgLy8gQ2hlY2sgY2FjaGUuXG4gIGlmIChpc0RlZmluZWQocHJlZml4Q2FjaGVbY2FjaGVOYW1lXSkpIHtcbiAgICByZXR1cm4gcHJlZml4Q2FjaGVbY2FjaGVOYW1lXTtcbiAgfVxuXG4gIHZhciB1Y1Byb3AgPSBwcm9wZXJ0eS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnNsaWNlKDEpO1xuXG4gIC8vIENyZWF0ZSBhbiBhcnJheSBvZiBwcmVmaXhlZCBwcm9wZXJ0aWVzLiBbJ3RyYW5zZm9ybScsICdXZWJraXRUcmFuc2Zvcm0nXS5cbiAgdmFyIHByb3BzID0gKHByb3BlcnR5ICsgJyAnICsgcHJlZml4ZXMuam9pbih1Y1Byb3AgKyAnICcpICsgdWNQcm9wKS5zcGxpdCgnICcpO1xuICB2YXIgc3R5bGUgPSBlbGVtZW50LnN0eWxlO1xuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgdmFyIGJlZm9yZSA9IHN0eWxlW3Byb3BdO1xuXG4gICAgLy8gQ2hlY2sgdGhlIGV4aXN0ZW5jZSBvZiB0aGUgcHJvcGVydHkuXG4gICAgaWYgKGlzRGVmaW5lZChiZWZvcmUpKSB7XG4gICAgICAvLyBUZXN0IGlmIHRoZSB2YWx1ZSBzdGlja3MgYWZ0ZXIgc2V0dGluZyBpdC5cbiAgICAgIGlmIChzaG91bGRUZXN0VmFsdWUpIHtcbiAgICAgICAgc3R5bGVbcHJvcF0gPSB2YWx1ZTtcblxuICAgICAgICAvLyBJZiB0aGUgcHJvcGVydHkgdmFsdWUgaGFzIGNoYW5nZWQsIGFzc3VtZSB0aGUgdmFsdWUgdXNlZCBpcyBzdXBwb3J0ZWQuXG4gICAgICAgIGlmIChzdHlsZVtwcm9wXSAhPT0gYmVmb3JlKSB7XG4gICAgICAgICAgcHJlZml4Q2FjaGVbY2FjaGVOYW1lXSA9IHByb3A7XG4gICAgICAgICAgcmV0dXJuIHByb3A7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZWZpeENhY2hlW2NhY2hlTmFtZV0gPSBwcm9wO1xuICAgICAgICByZXR1cm4gcHJvcDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcmVmaXhDYWNoZVtjYWNoZU5hbWVdID0gZmFsc2U7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgamF2YXNjcmlwdCBzdHlsZSBzdHJpbmcgdG8gYSBjc3Mgb25lLiBGb3IgZXhhbXBsZTpcbiAqIE1vekJveFNpemluZyAtPiAtbW96LWJveC1zaXppbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8ZmFsc2V9IHN0ciBUaGUgc3RyaW5nIHRvIGh5cGhlbmF0ZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGh5cGhlbmF0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBoeXBoZW5hdGUoc3RyKSB7XG4gIC8vIENhdGNoIGJvb2xlYW5zLlxuICBpZiAoIXN0cikge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIC8vIFR1cm4gTW96Qm94U2l6aW5nIGludG8gLW1vei1ib3gtc2l6aW5nLlxuICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbQS1aXSkvZywgZnVuY3Rpb24gKHN0ciwgbTEpIHtcbiAgICByZXR1cm4gJy0nICsgbTEudG9Mb3dlckNhc2UoKTtcbiAgfSkucmVwbGFjZSgvXm1zLS8sICctbXMtJyk7XG59XG5cbi8qKlxuICogUHJlZml4ZWQgc3R5bGUgcHJvcGVydGllcy5cbiAqIEB0eXBlIHt7W2tleTogc3RyaW5nXTogc3RyaW5nfGZhbHNlfX1cbiAqL1xudmFyIERvbSA9IHtcbiAgQU5JTUFUSU9OOiBwcmVmaXhlZCgnYW5pbWF0aW9uJyksXG4gIEFOSU1BVElPTl9EVVJBVElPTjogcHJlZml4ZWQoJ2FuaW1hdGlvbkR1cmF0aW9uJyksXG4gIFRSQU5TRk9STTogcHJlZml4ZWQoJ3RyYW5zZm9ybScpLFxuICBUUkFOU0lUSU9OOiBwcmVmaXhlZCgndHJhbnNpdGlvbicpLFxuICBUUkFOU0lUSU9OX1BST1BFUlRZOiBwcmVmaXhlZCgndHJhbnNpdGlvblByb3BlcnR5JyksXG4gIFRSQU5TSVRJT05fRFVSQVRJT046IHByZWZpeGVkKCd0cmFuc2l0aW9uRHVyYXRpb24nKSxcbiAgVFJBTlNJVElPTl9USU1JTkdfRlVOQ1RJT046IHByZWZpeGVkKCd0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24nKSxcbiAgVFJBTlNJVElPTl9ERUxBWTogcHJlZml4ZWQoJ3RyYW5zaXRpb25EZWxheScpXG59O1xuXG4vKipcbiAqIFByZWZpeGVkIGNzcyBwcm9wZXJ0aWVzLlxuICogQHR5cGUge3tba2V5OiBzdHJpbmddOiBzdHJpbmd9fVxuICovXG52YXIgQ3NzID0ge1xuICBBTklNQVRJT046IGh5cGhlbmF0ZShEb20uQU5JTUFUSU9OKSxcbiAgQU5JTUFUSU9OX0RVUkFUSU9OOiBoeXBoZW5hdGUoRG9tLkFOSU1BVElPTl9EVVJBVElPTiksXG4gIFRSQU5TRk9STTogaHlwaGVuYXRlKERvbS5UUkFOU0ZPUk0pLFxuICBUUkFOU0lUSU9OOiBoeXBoZW5hdGUoRG9tLlRSQU5TSVRJT04pLFxuICBUUkFOU0lUSU9OX1BST1BFUlRZOiBoeXBoZW5hdGUoRG9tLlRSQU5TSVRJT05fUFJPUEVSVFkpLFxuICBUUkFOU0lUSU9OX0RVUkFUSU9OOiBoeXBoZW5hdGUoRG9tLlRSQU5TSVRJT05fRFVSQVRJT04pLFxuICBUUkFOU0lUSU9OX1RJTUlOR19GVU5DVElPTjogaHlwaGVuYXRlKERvbS5UUkFOU0lUSU9OX1RJTUlOR19GVU5DVElPTiksXG4gIFRSQU5TSVRJT05fREVMQVk6IGh5cGhlbmF0ZShEb20uVFJBTlNJVElPTl9ERUxBWSlcbn07XG5cbi8qKlxuICogV2hldGhlciB0aGUgYnJvd3NlciBoYXMgY3NzIHRyYW5zaXRpb25zLlxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbnZhciBIQVNfVFJBTlNJVElPTlMgPSBEb20uVFJBTlNJVElPTiAhPT0gZmFsc2U7XG5cbi8qKlxuICogV2hldGhlciB0aGUgYnJvd3NlciBoYXMgY3NzIGFuaW1hdGlvbnMuXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xudmFyIEhBU19DU1NfQU5JTUFUSU9OUyA9IERvbS5BTklNQVRJT04gIT09IGZhbHNlO1xuXG4vKipcbiAqIFdoZXRoZXIgdGhlIGJyb3dzZXIgaGFzIGNzcyB0cmFuc2l0aW9ucy5cbiAqIEB0eXBlIHtib29sZWFufVxuICovXG52YXIgSEFTX1RSQU5TRk9STVMgPSBEb20uVFJBTlNGT1JNICE9PSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYnJvd3NlciBjYW4gdXNlIGNzcyB0cmFuc2l0aW9ucyBhbmQgdHJhbnNmb3Jtcy5cbiAqIEB0eXBlIHtib29sZWFufVxuICovXG52YXIgQ0FOX1RSQU5TSVRJT05fVFJBTlNGT1JNUyA9IEhBU19UUkFOU0lUSU9OUyAmJiBIQVNfVFJBTlNGT1JNUztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8qKlxuICogV2hldGhlciB0aGUgYnJvd3NlciBzdXBwb3J0cyB0b3VjaCBldmVudHMuXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xudmFyIEhBU19UT1VDSF9FVkVOVFMgPSAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgfHwgISF3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIHdpbmRvdy5Eb2N1bWVudFRvdWNoO1xuXG4vKipcbiAqIFdoZXRoZXIgdGhlIGJyb3dzZXIgc3VwcG9ydHMgcG9pbnRlciBldmVudHMuXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xudmFyIEhBU19QT0lOVEVSX0VWRU5UUyA9ICEhd2luZG93LlBvaW50ZXJFdmVudDtcblxuLyoqXG4gKiBXaGV0aGVyIHRoZSBicm93c2VyIHN1cHBvcnRzIGBsb2NhbFN0b3JhZ2VgLiBTYWZhcmkgaW4gcHJpdmF0ZSBicm93c2luZ1xuICogdGhyb3dzIGFuIGVycm9yIHdoZW4gY2FsbGluZyBgc2V0SXRlbWAuXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xudmFyIEhBU19MT0NBTF9TVE9SQUdFID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHZhciB0ZXN0S2V5ID0gJ3Rlc3QnO1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHRlc3RLZXksICcxJyk7XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0odGVzdEtleSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0oKTtcblxuLyoqXG4gKiBXaGV0aGVyIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBgcGFzc2l2ZWAgcHJvcGVydHkgaW4gYEV2ZW50TGlzdGVuZXJPcHRpb25zYC5cbiAqIEB0eXBlIHtib29sZWFufVxuICovXG52YXIgSEFTX1BBU1NJVkVfTElTVEVORVJTID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3VwcG9ydHNQYXNzaXZlT3B0aW9uID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBnZXQgcGFzc2l2ZSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLygpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBnZXR0ZXItcmV0dXJuXG4gICAgICAgIHN1cHBvcnRzUGFzc2l2ZU9wdGlvbiA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHN1cHBvcnRzUGFzc2l2ZU9wdGlvbjtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KCk7XG5cbi8vIEV4cG9ydCBldmVyeXRoaW5nIGFzIGFuIG9iamVjdCBvdGhlcndpc2Ugb3RoZXIgY29tcG9uZW50cyBhcmUgdW5hYmxlIHRvIHN0dWJcbi8vIHByb3BlcnRpZXMgYmVjYXVzZSB3ZWJwYWNrIHdyaXRlcyB0aGVtIGFzIGdldHRlcnMgYW5kIG5vbi1jb25maWd1cmFibGUuXG52YXIgZGV2aWNlID0ge1xuICBwcmVmaXhlZDogcHJlZml4ZWQsXG4gIGh5cGhlbmF0ZTogaHlwaGVuYXRlLFxuICBEb206IERvbSxcbiAgQ3NzOiBDc3MsXG4gIEhBU19UUkFOU0lUSU9OUzogSEFTX1RSQU5TSVRJT05TLFxuICBIQVNfQ1NTX0FOSU1BVElPTlM6IEhBU19DU1NfQU5JTUFUSU9OUyxcbiAgSEFTX1RSQU5TRk9STVM6IEhBU19UUkFOU0ZPUk1TLFxuICBDQU5fVFJBTlNJVElPTl9UUkFOU0ZPUk1TOiBDQU5fVFJBTlNJVElPTl9UUkFOU0ZPUk1TLFxuICBIQVNfVE9VQ0hfRVZFTlRTOiBIQVNfVE9VQ0hfRVZFTlRTLFxuICBIQVNfUE9JTlRFUl9FVkVOVFM6IEhBU19QT0lOVEVSX0VWRU5UUyxcbiAgSEFTX0xPQ0FMX1NUT1JBR0U6IEhBU19MT0NBTF9TVE9SQUdFLFxuICBIQVNfUEFTU0lWRV9MSVNURU5FUlM6IEhBU19QQVNTSVZFX0xJU1RFTkVSU1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZGV2aWNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2RvLWRldmljZS5lc20uanMubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@odopod/odo-device/dist/odo-device.esm.js\n");

/***/ }),

/***/ "./node_modules/@odopod/odo-dialog/dist/odo-dialog.esm.js":
/*!****************************************************************!*\
  !*** ./node_modules/@odopod/odo-dialog/dist/odo-dialog.esm.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @odopod/odo-helpers */ \"./node_modules/@odopod/odo-helpers/dist/odo-helpers.esm.js\");\n/* harmony import */ var _odopod_odo_device__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @odopod/odo-device */ \"./node_modules/@odopod/odo-device/dist/odo-device.esm.js\");\n/* harmony import */ var tiny_emitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tiny-emitter */ \"./node_modules/tiny-emitter/index.js\");\n/* harmony import */ var tiny_emitter__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(tiny_emitter__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n/**\n * @fileoverview Makes an overflowing element scrollable and handles preventing\n * default events and stopping event propagation when the scrollable element is\n * at the top or bottom of the scrollable area.\n *\n * @author Glen Cheney <glen@odopod.com>\n */\n\n/* istanbul ignore next */\nvar listenerOptions = _odopod_odo_device__WEBPACK_IMPORTED_MODULE_1__[\"default\"].HAS_PASSIVE_LISTENERS ? { passive: false } : false;\n\n/**\n * Makes the element scrollable with some smart listeners because iOS\n * behaves unsatisfactory.\n * @param {Element} element Element to use.\n * @param {string} id Unique id.\n * @constructor\n */\n\nvar ScrollFix = function () {\n  function ScrollFix(element, id) {\n    classCallCheck(this, ScrollFix);\n\n    this.element = element;\n    this.id = id;\n    this.startY = null;\n    this.scrollY = null;\n    this._createBoundEvents();\n    this._registerEvents();\n  }\n\n  ScrollFix.prototype._createBoundEvents = function _createBoundEvents() {\n    this._touchStartBound = this._onTouchStart.bind(this);\n    this._touchMoveBound = this._onTouchMove.bind(this);\n    this._preventDefaultBound = this._preventDefault.bind(this);\n  };\n\n  /**\n   * Add event listeners.\n   * @private\n   */\n\n\n  ScrollFix.prototype._registerEvents = function _registerEvents() {\n    document.body.addEventListener('touchstart', this._touchStartBound, listenerOptions);\n    document.body.addEventListener('touchmove', this._touchMoveBound, listenerOptions);\n    document.addEventListener('touchmove', this._preventDefaultBound, listenerOptions);\n  };\n\n  /**\n   * Save positions when the touch starts.\n   * @param {TouchEvent} evt Event object.\n   * @private\n   */\n\n\n  ScrollFix.prototype._onTouchStart = function _onTouchStart(evt) {\n    this.startY = evt.changedTouches[0].pageY;\n    this.scrollY = this.element.scrollTop;\n  };\n\n  /**\n   * When the touch move and touch start events get to the scrollable element,\n   * prevent them from bubbling further.\n   * @param {TouchEvent} evt Event object.\n   * @private\n   */\n\n\n  ScrollFix.prototype._onTouchMove = function _onTouchMove(evt) {\n    var deltaY = this.startY - evt.changedTouches[0].pageY;\n    var scrollTop = this.scrollY + deltaY;\n\n    // Prevent default stops all further touches...\n    // the user must lift their finger and swipe again before drags in the\n    // opposite direction register.\n    // However, without this, the same thing occurs, but instead of no\n    // scrolling, the page behind the dialog scrolls.\n    if (scrollTop < 0 || scrollTop + this.element.offsetHeight > this.element.scrollHeight) {\n      evt.preventDefault();\n    } else {\n      evt.stopPropagation();\n    }\n  };\n\n  /**\n   * Simply prevent the event's default action.\n   * @param {TouchEvent} evt Event object.\n   * @private\n   */\n\n\n  ScrollFix.prototype._preventDefault = function _preventDefault(evt) {\n    evt.preventDefault();\n  };\n\n  /**\n   * Dispose of this instance by removing handlers and DOM references.\n   */\n\n\n  ScrollFix.prototype.dispose = function dispose() {\n    document.body.removeEventListener('touchstart', this._touchStartBound, listenerOptions);\n    document.body.removeEventListener('touchmove', this._touchMoveBound, listenerOptions);\n    document.removeEventListener('touchmove', this._preventDefaultBound, listenerOptions);\n\n    this.element = null;\n    this.id = null;\n  };\n\n  return ScrollFix;\n}();\n\nvar ScrollFix$1 = {\n  /**\n   * Dictionary of ScrollFix instances.\n   * @type {Object.<string, ScrollFix>}\n   * @private\n   */\n  _fixes: new Map(),\n\n  /**\n   * Enable an element to be scrollable.\n   * @param {Element} element Element to make scrollable.\n   * @return {string} Id which is used to remove it.\n   */\n  add: function add(element) {\n    if (_odopod_odo_device__WEBPACK_IMPORTED_MODULE_1__[\"default\"].HAS_TOUCH_EVENTS) {\n      var id = Object(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"randomString\"])();\n      this._fixes.set(id, new ScrollFix(element, id));\n      return id;\n    }\n\n    return '';\n  },\n\n\n  /**\n   * Disable scrolling on an element and remove event listeners. Be aware\n   * that this removes the scroll fix class. If your element doesn't have\n   * the overflow-scrolling: touch property on it, iOS may flicker the whole\n   * container when calling this method.\n   * @param {string} id Id returned from enable.\n   */\n  remove: function remove(id) {\n    if (this._fixes.has(id)) {\n      this._fixes.get(id).dispose();\n      this._fixes.delete(id);\n    }\n  }\n};\n\n/**\n * @fileoverview UI Component for universal dialogs.\n * Notes\n * * The transition is on the main `element` so that `scale()` transforms do not\n * cause the calculation of `scrollHeight` to be artificially increased.\n * * The backdrop is a sibling to the dialog so that it does not cover the\n * scrollbar of the dialog and so that it doesn't jitter in iOS.\n *\n * @author Glen Cheney <glen@odopod.com>\n */\n\nvar FOCUSABLE_ELEMENTS = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'iframe', 'object', 'embed', '[contenteditable]', '[tabindex]:not([tabindex^=\"-\"])'].join(',');\n\nvar Dialog = function (_TinyEmitter) {\n  inherits(Dialog, _TinyEmitter);\n\n  /**\n   * Dialog that can contain static images, carousels, or videos\n   * @param {HTMLElement} element Main element.\n   * @param {object} [opts] Instance options.\n   * @constructor\n   */\n  function Dialog(element, opts) {\n    classCallCheck(this, Dialog);\n\n    var _this = possibleConstructorReturn(this, _TinyEmitter.call(this));\n\n    if (!(element instanceof HTMLElement)) {\n      throw new TypeError('OdoDialog requires an element. Got: \"' + element + '\"');\n    }\n\n    /**\n     * Base Element.\n     * @type {HTMLElement}\n     */\n    _this.element = element;\n\n    /**\n     * Options object.\n     * @type {object}\n     */\n    _this.options = Object.assign({}, Dialog.Defaults, opts);\n\n    /**\n     * Dialog Id.\n     * @type {string}\n     */\n    _this.id = element.getAttribute('id');\n\n    /**\n     * Dialog backdrop\n     * @type {HTMLElement}\n     * @protected\n     */\n    _this.backdrop = document.createElement('div');\n    _this.backdrop.className = Dialog.Classes.BACKDROP;\n\n    /**\n     * Dialog content (role=document).\n     * @type {HTMLElement}\n     * @protected\n     */\n    _this.content = _this.getByClass(Dialog.Classes.CONTENT);\n\n    /**\n     * Elements which, when clicked, close the dialog.\n     * @type {HTMLElement[]}\n     * @private\n     */\n    _this._closers = Array.from(_this.element.querySelectorAll('[data-odo-dialog-close]'));\n\n    /**\n     * Window resize Id\n     * @type {string}\n     * @private\n     */\n    _this._resizeId = null;\n\n    /**\n     * ScrollFix id\n     * @type {?string}\n     * @private\n     */\n    _this._scrollFixId = null;\n\n    /**\n     * Whether the dialog is open.\n     * @type {boolean}\n     */\n    _this.isOpen = false;\n\n    /**\n     * Is the dialog currently animating.\n     * @type {boolean}\n     * @protected\n     */\n    _this.isAnimating = false;\n\n    /**\n     * Whether the body has a scrollbar.\n     * @type {?boolean}\n     * @private\n     */\n    _this._hasBodyScrollbar = null;\n\n    /**\n     * Padding on the body.\n     * @type {number}\n     * @private\n     */\n    _this._originalBodyPadding = -1;\n\n    /**\n     * Whether this is a fullscreen dialog. Fullscreen dialogs should not have\n     * paddingRight applied to them.\n     * @type {?boolean}\n     * @private\n     */\n    _this._isFullscreen = null;\n\n    _this.z = Dialog.Z_BASE;\n\n    Dialog.Instances.push(_this);\n\n    if (Dialog.Instances.length === 1) {\n      document.body.addEventListener('click', Dialog._handleTriggerClick);\n    }\n\n    // If this browser does not support auto margins for flexbox, add a class\n    // so that it can be centered differently.\n    _this.element.classList.toggle(Dialog.Classes.NO_AUTO_MARGIN, !Dialog.SUPPORTS_AUTO_MARGINS);\n\n    _this._bindContexts();\n    _this.onResize();\n    _this._addA11yAttributes();\n    _this._ensureBodyChild();\n    return _this;\n  }\n\n  /**\n   * Find descendent element by class.\n   * @param {string} name Name of the class to find.\n   * @return {Element|undefined} The element or undefined.\n   */\n\n\n  Dialog.prototype.getByClass = function getByClass(name) {\n    return this.element.getElementsByClassName(name)[0];\n  };\n\n  /**\n   * Bind `this` context to event handlers.\n   */\n\n\n  Dialog.prototype._bindContexts = function _bindContexts() {\n    this.onKeyPress = this.onKeyPress.bind(this);\n    this.onClick = this.onClick.bind(this);\n    this.close = this.close.bind(this);\n    this.closeWithAnimation = this.close.bind(this, false);\n    // Bind undefined as the first parameter so that the event object will be\n    // the second parameter and the optional viewportHeight parameter will work.\n    this.onWindowResize = this.onResize.bind(this, undefined);\n  };\n\n  /**\n   * Add static accessibility attributes so that the implementor can leave them\n   * off or in case they forget.\n   */\n\n\n  Dialog.prototype._addA11yAttributes = function _addA11yAttributes() {\n    this.element.tabIndex = -1;\n    this.element.setAttribute('aria-hidden', true);\n    this.element.setAttribute('role', 'dialog');\n    this.content.setAttribute('role', 'document');\n  };\n\n  /**\n   * If the dialog element is not a direct descendent of the <body>, make it so.\n   */\n\n\n  Dialog.prototype._ensureBodyChild = function _ensureBodyChild() {\n    if (this.element.parentNode !== document.body) {\n      document.body.appendChild(this.element);\n    }\n  };\n\n  /**\n   * Determine the correct element to scroll fix and fix it.\n   */\n\n\n  Dialog.prototype._applyScrollFix = function _applyScrollFix() {\n    // Allow the scrollable element to be something inside the dialog.\n    if (this.options.scrollableElement) {\n      var element = this.element.matches(this.options.scrollableElement) ? this.element : this.element.querySelector(this.options.scrollableElement);\n      this._scrollFixId = ScrollFix$1.add(element);\n    }\n  };\n\n  /**\n   * If the page already has a scrollbar, adding overflow: hidden will remove it,\n   * shifting the content to the right. To avoid this, there needs to be padding\n   * on the body that's the same width as the scrollbar, but only when the dialog\n   * will not have a scrollbar to take the page scrollbar's place.\n   * @return {number}\n   */\n\n\n  Dialog.prototype._getScrollbarOffset = function _getScrollbarOffset() {\n    var hasDialogScrollbar = this.element.scrollHeight > document.documentElement.clientHeight;\n    return this._hasBodyScrollbar && !hasDialogScrollbar ? Dialog.SCROLLBAR_WIDTH : 0;\n  };\n\n  /**\n   * Click handler on the main element. When the dialog is dismissable and the\n   * user clicked outside the content (i.e. the backdrop), close it.\n   * @param {MouseEvent} evt Event object.\n   * @protected\n   */\n\n\n  Dialog.prototype.onClick = function onClick(evt) {\n    if (this.options.dismissable && evt.target === this.element) {\n      this.close();\n    }\n  };\n\n  /**\n   * Keypress event handler\n   * @param {KeyboardEvent} evt Event object\n   * @protected\n   */\n\n\n  Dialog.prototype.onKeyPress = function onKeyPress(evt) {\n    // Only react to keys when this dialog is the top-most one.\n    if (this.z === Dialog.getTopLayer()) {\n      // If 'ESC' is pressed, close the dialog\n      if (this.options.dismissable && evt.which === Dialog.Keys.ESC) {\n        this.close();\n      }\n\n      // If the TAB key is being pressed, make sure the focus stays trapped within\n      // the dialog element.\n      if (evt.which === Dialog.Keys.TAB) {\n        Dialog._trapTabKey(this.element, evt);\n      }\n    }\n  };\n\n  /**\n   * The dialog has a height of 100vh, which, in mobile safari, is incorrect\n   * when the toolbars are visible, not allowing the user to scroll the full\n   * height of the content within it.\n   * The viewportHeight parameter is optional so that it can be read in the open()\n   * method with all the other DOM reads. This avoids read->write->read #perfmatters.\n   * @param {number} [viewportHeight=window.innerHeight] Height of the viewport.\n   * @protected\n   */\n\n\n  Dialog.prototype.onResize = function onResize() {\n    var viewportHeight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.innerHeight;\n\n    this.element.style.height = viewportHeight + 'px';\n  };\n\n  /**\n   * Checks to see if a dialog is already open or animating If not, opens dialog.\n   * @param {boolean} [sync=false] Whether to open with transitions or not.\n   */\n\n\n  Dialog.prototype.open = function open() {\n    var _this2 = this;\n\n    var sync = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    if (this.isAnimating || this.isOpen) {\n      return;\n    }\n\n    var viewportHeight = window.innerHeight;\n    Dialog.focusedBeforeDialog = document.activeElement;\n    this._hasBodyScrollbar = document.body.clientWidth < window.innerWidth;\n    this._isFullscreen = this.element.classList.contains(Dialog.Classes.FULLSCREEN);\n\n    // Add aria-hidden to other top-level things.\n    var siblings = Dialog._getSiblings(this.element);\n    var originals = siblings.map(function (element) {\n      return element.getAttribute('aria-hidden');\n    });\n    siblings.forEach(function (element, i) {\n      if (originals[i]) {\n        element.setAttribute('data-odo-dialog-original', originals[i]);\n      }\n      element.setAttribute('aria-hidden', true);\n    });\n\n    // If there is already an open dialog, increase the z-index of this dialog's\n    // main element and backdrop above the open one.\n    if (Dialog.getOpenDialogCount() > 0) {\n      this.handleOtherOpenDialogs();\n    }\n\n    this.isOpen = true;\n    this.onResize(viewportHeight);\n    this.element.removeAttribute('aria-hidden');\n    this.element.classList.add(Dialog.Classes.OPEN);\n    this.element.classList.add(Dialog.Classes.ENTER);\n    if (Dialog.SCROLLBAR_WIDTH) {\n      document.body.style.paddingRight = Dialog.SCROLLBAR_WIDTH + 'px';\n    }\n    document.body.classList.add(Dialog.Classes.BODY_OPEN);\n    document.body.insertBefore(this.backdrop, this.element.nextSibling);\n    this.element.scrollTop = 0;\n\n    this._applyScrollFix();\n\n    this.element.focus();\n\n    document.addEventListener('keydown', this.onKeyPress);\n    window.addEventListener('resize', this.onWindowResize);\n    this.element.addEventListener('click', this.onClick);\n    this._closers.forEach(function (element) {\n      element.addEventListener('click', _this2.closeWithAnimation);\n    });\n\n    if (sync === true) {\n      this._openNext();\n      this._opened();\n    } else {\n      Dialog._nextFrame(function () {\n        _this2._openNext();\n        Object(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"onTransitionEnd\"])(_this2.element, _this2._opened, _this2, null, 1000);\n      });\n    }\n  };\n\n  /**\n   * Start the transition for opening the dialog.\n   */\n\n\n  Dialog.prototype._openNext = function _openNext() {\n    this.isAnimating = true;\n    // Now that the dialog is no longer display:none, the scrollHeight can be measured.\n    var scrollbarOffset = this._getScrollbarOffset();\n    if (!this._isFullscreen && scrollbarOffset > 0) {\n      this.element.style.paddingRight = scrollbarOffset + 'px';\n    }\n\n    this.element.classList.remove(Dialog.Classes.ENTER);\n    this.element.classList.add(Dialog.Classes.ENTERING);\n  };\n\n  /**\n   * Handle the end of the open transition. Emits OPENED event.\n   */\n\n\n  Dialog.prototype._opened = function _opened() {\n    this.element.classList.remove(Dialog.Classes.ENTERING);\n    this.element.classList.add(Dialog.Classes.VISIBLE);\n    this.isAnimating = false;\n    this.emit(Dialog.EventType.OPENED);\n  };\n\n  /**\n   * Hides dialog\n   * @param {boolean} [sync=false] Whether to close with transitions or not.\n   */\n\n\n  Dialog.prototype.close = function close() {\n    var _this3 = this;\n\n    var sync = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    if (this.isAnimating || !this.isOpen) {\n      return;\n    }\n\n    // Remove aria-hidden to other top-level things.\n    var siblings = Dialog._getSiblings(this.element);\n    var originals = siblings.map(function (element) {\n      return element.getAttribute('data-odo-dialog-original');\n    });\n    siblings.forEach(function (element, i) {\n      if (originals[i]) {\n        element.setAttribute('aria-hidden', originals[i]);\n        element.removeAttribute('data-odo-dialog-original');\n      } else {\n        element.removeAttribute('aria-hidden');\n      }\n    });\n\n    this.isOpen = false;\n    this.element.classList.add(Dialog.Classes.LEAVE);\n    this.element.classList.remove(Dialog.Classes.VISIBLE);\n\n    ScrollFix$1.remove(this._scrollFixId);\n\n    // Support: IE11\n    // Clicking on an SVG element inside an <a> will set the `focusedBeforeDialog`\n    // to the SVG, but SVG doesn't have a `focus()` method in IE.\n    if (Dialog.focusedBeforeDialog && typeof Dialog.focusedBeforeDialog.focus === 'function') {\n      Dialog.focusedBeforeDialog.focus();\n    }\n\n    document.removeEventListener('keydown', this.onKeyPress);\n    window.removeEventListener('resize', this.onWindowResize);\n    this.element.removeEventListener('click', this.onClick);\n    this._closers.forEach(function (element) {\n      element.removeEventListener('click', _this3.closeWithAnimation);\n    });\n\n    if (sync === true) {\n      this._closeNext();\n      this._closed();\n    } else {\n      Dialog._nextFrame(function () {\n        _this3._closeNext();\n        Object(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"onTransitionEnd\"])(_this3.element, _this3._closed, _this3, null, 1000);\n      });\n    }\n  };\n\n  /**\n   * Start the transition for closing the dialog.\n   */\n\n\n  Dialog.prototype._closeNext = function _closeNext() {\n    this.isAnimating = true;\n    this.element.classList.remove(Dialog.Classes.LEAVE);\n    this.element.classList.add(Dialog.Classes.LEAVING);\n  };\n\n  /**\n   * Handle the end of the close transition. Emits the CLOSED event.\n   */\n\n\n  Dialog.prototype._closed = function _closed() {\n    this.isAnimating = false;\n    this.element.style.paddingRight = '';\n    this.element.setAttribute('aria-hidden', true);\n    this.element.classList.remove(Dialog.Classes.OPEN);\n    this.element.classList.remove(Dialog.Classes.LEAVING);\n    if (Dialog.getOpenDialogCount() === 0) {\n      document.body.style.paddingRight = '';\n      document.body.classList.remove(Dialog.Classes.BODY_OPEN);\n    }\n    document.body.removeChild(this.backdrop);\n    this.emit(Dialog.EventType.CLOSED);\n  };\n\n  /**\n   * Modify dialog z-indices and more because there are about to be multiple\n   * dialogs open at the same time.\n   * @protected\n   */\n\n\n  Dialog.prototype.handleOtherOpenDialogs = function handleOtherOpenDialogs() {\n    var _this4 = this;\n\n    this.z = Dialog.getTopLayer() + 20;\n    this.element.style.zIndex = this.z;\n    this.backdrop.style.zIndex = this.z - 5;\n\n    // When this dialog is closed, revert the z-index back to its original value.\n    this.once(Dialog.EventType.CLOSED, function () {\n      _this4.z = Dialog.Z_BASE;\n      _this4.element.style.zIndex = '';\n      _this4.backdrop.style.zIndex = '';\n\n      // Find new top dialog.\n      var zTop = Dialog.getTopLayer();\n\n      Dialog.Instances.forEach(function (instance) {\n        if (instance.isOpen && instance.z === zTop) {\n          instance.didEnterForeground();\n        }\n      });\n    });\n\n    // Tell other dialogs they're going into the background.\n    Dialog.Instances.forEach(function (instance) {\n      if (instance.isOpen && instance.id !== _this4.id) {\n        instance.didEnterBackground();\n      }\n    });\n  };\n\n  /**\n   * Dialog went into the background and has another dialog open above it.\n   * @protected\n   */\n\n\n  Dialog.prototype.didEnterBackground = function didEnterBackground() {\n    ScrollFix$1.remove(this._scrollFixId);\n  };\n\n  /**\n   * Dialog came back into the foreground after being in the background.\n   * @protected\n   */\n\n\n  Dialog.prototype.didEnterForeground = function didEnterForeground() {\n    this._applyScrollFix();\n  };\n\n  /**\n   * Close the dialog, remove event listeners and element references.\n   */\n\n\n  Dialog.prototype.dispose = function dispose() {\n    if (this.isOpen) {\n      this.close(true);\n    }\n\n    this.element = null;\n    this.content = null;\n    this.backdrop = null;\n    this._closers.length = 0;\n\n    Object(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"pull\"])(Dialog.Instances, this);\n\n    // If this is the last dialog (being disposed), remove the body listener.\n    if (Dialog.Instances.length === 0) {\n      document.body.removeEventListener('click', Dialog._handleTriggerClick);\n    }\n  };\n\n  /**\n   * Call a function after two animation frames. Using just one is unreliable\n   * when using animations to/from display:none elements or ones that are not\n   * yet in the DOM.\n   * @param {function} fn Function to call on the next frame.\n   */\n\n\n  Dialog._nextFrame = function _nextFrame(fn) {\n    window.requestAnimationFrame(window.requestAnimationFrame.bind(null, fn));\n  };\n\n  /**\n   * Open the correct dialog when an element with `data-odo-dialog-open` attribute\n   * is clicked.\n   * @param {Event} evt Event object.\n   */\n\n\n  Dialog._handleTriggerClick = function _handleTriggerClick(evt) {\n    var trigger = evt.target.closest('[data-odo-dialog-open]');\n\n    if (trigger !== null) {\n      evt.preventDefault();\n      var id = trigger.getAttribute('data-odo-dialog-open');\n      var instance = Dialog.getDialogById(id);\n      instance.emit(Dialog.EventType.TRIGGER_CLICKED, trigger);\n      instance.open();\n    }\n  };\n\n  /**\n   * Trap the focus inside the given element.\n   * @param {Element} node\n   * @param {KeyboardEvent} evt\n   */\n\n\n  Dialog._trapTabKey = function _trapTabKey(node, evt) {\n    var focusableChildren = Dialog._getFocusableChildren(node);\n    var focusedItemIndex = focusableChildren.indexOf(document.activeElement);\n\n    // If the SHIFT key is being pressed while tabbing (moving backwards) and\n    // the currently focused item is the first one, move the focus to the last\n    // focusable item from the dialog element\n    if (evt.shiftKey && focusedItemIndex === 0) {\n      focusableChildren[focusableChildren.length - 1].focus();\n      evt.preventDefault();\n      // If the SHIFT key is not being pressed (moving forwards) and the currently\n      // focused item is the last one, move the focus to the first focusable item\n      // from the dialog element\n    } else if (!evt.shiftKey && focusedItemIndex === focusableChildren.length - 1) {\n      focusableChildren[0].focus();\n      evt.preventDefault();\n    }\n  };\n\n  /**\n   * Get the focusable children of the given element.\n   * @param {Element} element\n   * @return {Element[]}\n   */\n\n\n  Dialog._getFocusableChildren = function _getFocusableChildren(element) {\n    return Array.from(element.querySelectorAll(FOCUSABLE_ELEMENTS)).filter(Dialog._isVisibleElement);\n  };\n\n  /**\n   * Whether an element is visible (and therefore can receive focus). Uses\n   * `getClientRects` due to this issue:\n   * https://github.com/jquery/jquery/issues/2227\n   * http://jsfiddle.net/2tgw2yr3/\n   * @param {HTMLElement} el Element.\n   * @return {boolean}\n   */\n\n\n  Dialog._isVisibleElement = function _isVisibleElement(el) {\n    return !!(el.offsetWidth || el.offsetHeight || el.getClientRects().length);\n  };\n\n  /**\n   * Retrieve the siblings of an element.\n   * @param {Element} element Element to get siblings for.\n   * @return {Array.<Element>}\n   */\n\n\n  Dialog._getSiblings = function _getSiblings(element) {\n    var children = Array.from(element.parentElement.children);\n    var ignore = ['script', 'link', 'meta'];\n    return children.filter(function (node) {\n      return node !== element && !ignore.includes(node.nodeName.toLowerCase());\n    });\n  };\n\n  /**\n   * Calculate the width of the scrollbar because when the body has overflow:hidden,\n   * the scrollbar disappears.\n   * https://davidwalsh.name/detect-scrollbar-width\n   * @return {number}\n   */\n\n\n  Dialog._getScrollbarWidth = function _getScrollbarWidth() {\n    // Create measurement node.\n    var scrollDiv = document.createElement('div');\n    scrollDiv.style.cssText = 'width:50px;height:50px;overflow:scroll;position:absolute;top:-9999px;';\n    document.body.appendChild(scrollDiv);\n\n    // Calculate the scrollbar width.\n    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n\n    // Remove test element.\n    document.body.removeChild(scrollDiv);\n\n    return scrollbarWidth;\n  };\n\n  /**\n   * Unfortunately, the auto margins do not work for flex children in IE11 and\n   * below because the content element does have an explicit height set on it.\n   * @return {boolean}\n   */\n\n\n  Dialog._autoMarginTest = function _autoMarginTest() {\n    var parent = document.createElement('div');\n    var child = document.createElement('div');\n    parent.style.cssText = 'display:flex;height:50px;width:50px;position:absolute;';\n    child.style.cssText = 'margin:auto;';\n    child.innerHTML = 'a';\n    parent.appendChild(child);\n    document.body.appendChild(parent);\n\n    var ret = child.offsetTop > 0;\n    document.body.removeChild(parent);\n\n    return ret;\n  };\n\n  /**\n   * Instantiates all instances of dialogs with the same settings\n   * @param {object} options Object of all dialog options. Is optional.\n   * @return {Dialog[]}\n   */\n\n\n  Dialog.initializeAll = function initializeAll(options) {\n    Dialog.disposeAll();\n\n    return Array.from(document.querySelectorAll('.' + Dialog.Classes.BASE), function (dialog) {\n      return new Dialog(dialog, options);\n    });\n  };\n\n  /**\n   * Clear all references to dialogs so there are no duplicates.\n   */\n\n\n  Dialog.disposeAll = function disposeAll() {\n    var clone = Dialog.Instances.slice();\n    clone.forEach(function (dialog) {\n      dialog.dispose();\n    });\n  };\n\n  /**\n   * Retrieve a dialog instance by its id.\n   * @param {string} id Id of the dialog.\n   * @return {?Dialog} The dialog or undefined if there is no dialog with the given id.\n   */\n\n\n  Dialog.getDialogById = function getDialogById(id) {\n    return Dialog.Instances.find(function (instance) {\n      return instance.id === id;\n    });\n  };\n\n  /**\n   * Count how many dialogs are currently open.\n   * @return {number}\n   */\n\n\n  Dialog.getOpenDialogCount = function getOpenDialogCount() {\n    return Dialog.Instances.filter(function (instance) {\n      return instance.isOpen;\n    }).length;\n  };\n\n  /**\n   * Find the z index of the top-most dialog instance.\n   * @return {number}\n   */\n\n\n  Dialog.getTopLayer = function getTopLayer() {\n    // eslint-disable-next-line prefer-spread\n    return Math.max.apply(Math, Dialog.Instances.map(function (instance) {\n      return instance.z;\n    }));\n  };\n\n  return Dialog;\n}(tiny_emitter__WEBPACK_IMPORTED_MODULE_2___default.a);\n\n/** @enum {string} */\n\n\nDialog.Classes = {\n  BODY_OPEN: 'odo-dialog-open',\n  BASE: 'odo-dialog',\n  OPEN: 'odo-dialog--open',\n  ENTER: 'odo-dialog--enter',\n  ENTERING: 'odo-dialog--enter-active',\n  LEAVE: 'odo-dialog--leave',\n  LEAVING: 'odo-dialog--leave-active',\n  VISIBLE: 'odo-dialog--visible',\n  FULLSCREEN: 'odo-dialog--full',\n  NO_AUTO_MARGIN: 'odo-dialog--no-auto-margin',\n  BACKDROP: 'odo-dialog-backdrop',\n  CONTENT: 'odo-dialog__content'\n};\n\n/** @enum {string} */\nDialog.EventType = {\n  OPENED: 'ododialog:open',\n  CLOSED: 'ododialog:closed',\n  TRIGGER_CLICKED: 'ododialog:triggerclicked'\n};\n\n/** @enum {number} */\nDialog.Keys = {\n  ESC: 27,\n  TAB: 9\n};\n\nDialog.Defaults = {\n  dismissable: true,\n  scrollableElement: '.odo-dialog'\n};\n\n/** @type {Dialog[]} */\nDialog.Instances = [];\n\nDialog.Z_BASE = 1050;\n\nDialog.ScrollFix = ScrollFix$1;\n\n/**\n * Element which had focus before the dialog opened.\n * @type {Element}\n */\nDialog.focusedBeforeDialog = null;\n\nDialog.SUPPORTS_AUTO_MARGINS = Dialog._autoMarginTest();\nDialog.SCROLLBAR_WIDTH = Dialog._getScrollbarWidth();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Dialog);\n//# sourceMappingURL=odo-dialog.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG9kb3BvZC9vZG8tZGlhbG9nL2Rpc3Qvb2RvLWRpYWxvZy5lc20uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG9kb3BvZC9vZG8tZGlhbG9nL2Rpc3Qvb2RvLWRpYWxvZy5lc20uanM/NGJiZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByYW5kb21TdHJpbmcsIHB1bGwsIG9uVHJhbnNpdGlvbkVuZCB9IGZyb20gJ0BvZG9wb2Qvb2RvLWhlbHBlcnMnO1xuaW1wb3J0IE9kb0RldmljZSBmcm9tICdAb2RvcG9kL29kby1kZXZpY2UnO1xuaW1wb3J0IFRpbnlFbWl0dGVyIGZyb20gJ3RpbnktZW1pdHRlcic7XG5cbnZhciBjbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG52YXIgaW5oZXJpdHMgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59O1xuXG52YXIgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiA9IGZ1bmN0aW9uIChzZWxmLCBjYWxsKSB7XG4gIGlmICghc2VsZikge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmO1xufTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IE1ha2VzIGFuIG92ZXJmbG93aW5nIGVsZW1lbnQgc2Nyb2xsYWJsZSBhbmQgaGFuZGxlcyBwcmV2ZW50aW5nXG4gKiBkZWZhdWx0IGV2ZW50cyBhbmQgc3RvcHBpbmcgZXZlbnQgcHJvcGFnYXRpb24gd2hlbiB0aGUgc2Nyb2xsYWJsZSBlbGVtZW50IGlzXG4gKiBhdCB0aGUgdG9wIG9yIGJvdHRvbSBvZiB0aGUgc2Nyb2xsYWJsZSBhcmVhLlxuICpcbiAqIEBhdXRob3IgR2xlbiBDaGVuZXkgPGdsZW5Ab2RvcG9kLmNvbT5cbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xudmFyIGxpc3RlbmVyT3B0aW9ucyA9IE9kb0RldmljZS5IQVNfUEFTU0lWRV9MSVNURU5FUlMgPyB7IHBhc3NpdmU6IGZhbHNlIH0gOiBmYWxzZTtcblxuLyoqXG4gKiBNYWtlcyB0aGUgZWxlbWVudCBzY3JvbGxhYmxlIHdpdGggc29tZSBzbWFydCBsaXN0ZW5lcnMgYmVjYXVzZSBpT1NcbiAqIGJlaGF2ZXMgdW5zYXRpc2ZhY3RvcnkuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byB1c2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgVW5pcXVlIGlkLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxudmFyIFNjcm9sbEZpeCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2Nyb2xsRml4KGVsZW1lbnQsIGlkKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgU2Nyb2xsRml4KTtcblxuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuc3RhcnRZID0gbnVsbDtcbiAgICB0aGlzLnNjcm9sbFkgPSBudWxsO1xuICAgIHRoaXMuX2NyZWF0ZUJvdW5kRXZlbnRzKCk7XG4gICAgdGhpcy5fcmVnaXN0ZXJFdmVudHMoKTtcbiAgfVxuXG4gIFNjcm9sbEZpeC5wcm90b3R5cGUuX2NyZWF0ZUJvdW5kRXZlbnRzID0gZnVuY3Rpb24gX2NyZWF0ZUJvdW5kRXZlbnRzKCkge1xuICAgIHRoaXMuX3RvdWNoU3RhcnRCb3VuZCA9IHRoaXMuX29uVG91Y2hTdGFydC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3RvdWNoTW92ZUJvdW5kID0gdGhpcy5fb25Ub3VjaE1vdmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9wcmV2ZW50RGVmYXVsdEJvdW5kID0gdGhpcy5fcHJldmVudERlZmF1bHQuYmluZCh0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGV2ZW50IGxpc3RlbmVycy5cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBTY3JvbGxGaXgucHJvdG90eXBlLl9yZWdpc3RlckV2ZW50cyA9IGZ1bmN0aW9uIF9yZWdpc3RlckV2ZW50cygpIHtcbiAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl90b3VjaFN0YXJ0Qm91bmQsIGxpc3RlbmVyT3B0aW9ucyk7XG4gICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl90b3VjaE1vdmVCb3VuZCwgbGlzdGVuZXJPcHRpb25zKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9wcmV2ZW50RGVmYXVsdEJvdW5kLCBsaXN0ZW5lck9wdGlvbnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTYXZlIHBvc2l0aW9ucyB3aGVuIHRoZSB0b3VjaCBzdGFydHMuXG4gICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZXZ0IEV2ZW50IG9iamVjdC5cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBTY3JvbGxGaXgucHJvdG90eXBlLl9vblRvdWNoU3RhcnQgPSBmdW5jdGlvbiBfb25Ub3VjaFN0YXJ0KGV2dCkge1xuICAgIHRoaXMuc3RhcnRZID0gZXZ0LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZO1xuICAgIHRoaXMuc2Nyb2xsWSA9IHRoaXMuZWxlbWVudC5zY3JvbGxUb3A7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIHRvdWNoIG1vdmUgYW5kIHRvdWNoIHN0YXJ0IGV2ZW50cyBnZXQgdG8gdGhlIHNjcm9sbGFibGUgZWxlbWVudCxcbiAgICogcHJldmVudCB0aGVtIGZyb20gYnViYmxpbmcgZnVydGhlci5cbiAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBldnQgRXZlbnQgb2JqZWN0LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFNjcm9sbEZpeC5wcm90b3R5cGUuX29uVG91Y2hNb3ZlID0gZnVuY3Rpb24gX29uVG91Y2hNb3ZlKGV2dCkge1xuICAgIHZhciBkZWx0YVkgPSB0aGlzLnN0YXJ0WSAtIGV2dC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWTtcbiAgICB2YXIgc2Nyb2xsVG9wID0gdGhpcy5zY3JvbGxZICsgZGVsdGFZO1xuXG4gICAgLy8gUHJldmVudCBkZWZhdWx0IHN0b3BzIGFsbCBmdXJ0aGVyIHRvdWNoZXMuLi5cbiAgICAvLyB0aGUgdXNlciBtdXN0IGxpZnQgdGhlaXIgZmluZ2VyIGFuZCBzd2lwZSBhZ2FpbiBiZWZvcmUgZHJhZ3MgaW4gdGhlXG4gICAgLy8gb3Bwb3NpdGUgZGlyZWN0aW9uIHJlZ2lzdGVyLlxuICAgIC8vIEhvd2V2ZXIsIHdpdGhvdXQgdGhpcywgdGhlIHNhbWUgdGhpbmcgb2NjdXJzLCBidXQgaW5zdGVhZCBvZiBub1xuICAgIC8vIHNjcm9sbGluZywgdGhlIHBhZ2UgYmVoaW5kIHRoZSBkaWFsb2cgc2Nyb2xscy5cbiAgICBpZiAoc2Nyb2xsVG9wIDwgMCB8fCBzY3JvbGxUb3AgKyB0aGlzLmVsZW1lbnQub2Zmc2V0SGVpZ2h0ID4gdGhpcy5lbGVtZW50LnNjcm9sbEhlaWdodCkge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNpbXBseSBwcmV2ZW50IHRoZSBldmVudCdzIGRlZmF1bHQgYWN0aW9uLlxuICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGV2dCBFdmVudCBvYmplY3QuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgU2Nyb2xsRml4LnByb3RvdHlwZS5fcHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiBfcHJldmVudERlZmF1bHQoZXZ0KSB7XG4gICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERpc3Bvc2Ugb2YgdGhpcyBpbnN0YW5jZSBieSByZW1vdmluZyBoYW5kbGVycyBhbmQgRE9NIHJlZmVyZW5jZXMuXG4gICAqL1xuXG5cbiAgU2Nyb2xsRml4LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl90b3VjaFN0YXJ0Qm91bmQsIGxpc3RlbmVyT3B0aW9ucyk7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl90b3VjaE1vdmVCb3VuZCwgbGlzdGVuZXJPcHRpb25zKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9wcmV2ZW50RGVmYXVsdEJvdW5kLCBsaXN0ZW5lck9wdGlvbnMpO1xuXG4gICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLmlkID0gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gU2Nyb2xsRml4O1xufSgpO1xuXG52YXIgU2Nyb2xsRml4JDEgPSB7XG4gIC8qKlxuICAgKiBEaWN0aW9uYXJ5IG9mIFNjcm9sbEZpeCBpbnN0YW5jZXMuXG4gICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgU2Nyb2xsRml4Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9maXhlczogbmV3IE1hcCgpLFxuXG4gIC8qKlxuICAgKiBFbmFibGUgYW4gZWxlbWVudCB0byBiZSBzY3JvbGxhYmxlLlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBtYWtlIHNjcm9sbGFibGUuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gSWQgd2hpY2ggaXMgdXNlZCB0byByZW1vdmUgaXQuXG4gICAqL1xuICBhZGQ6IGZ1bmN0aW9uIGFkZChlbGVtZW50KSB7XG4gICAgaWYgKE9kb0RldmljZS5IQVNfVE9VQ0hfRVZFTlRTKSB7XG4gICAgICB2YXIgaWQgPSByYW5kb21TdHJpbmcoKTtcbiAgICAgIHRoaXMuX2ZpeGVzLnNldChpZCwgbmV3IFNjcm9sbEZpeChlbGVtZW50LCBpZCkpO1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBEaXNhYmxlIHNjcm9sbGluZyBvbiBhbiBlbGVtZW50IGFuZCByZW1vdmUgZXZlbnQgbGlzdGVuZXJzLiBCZSBhd2FyZVxuICAgKiB0aGF0IHRoaXMgcmVtb3ZlcyB0aGUgc2Nyb2xsIGZpeCBjbGFzcy4gSWYgeW91ciBlbGVtZW50IGRvZXNuJ3QgaGF2ZVxuICAgKiB0aGUgb3ZlcmZsb3ctc2Nyb2xsaW5nOiB0b3VjaCBwcm9wZXJ0eSBvbiBpdCwgaU9TIG1heSBmbGlja2VyIHRoZSB3aG9sZVxuICAgKiBjb250YWluZXIgd2hlbiBjYWxsaW5nIHRoaXMgbWV0aG9kLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSWQgcmV0dXJuZWQgZnJvbSBlbmFibGUuXG4gICAqL1xuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShpZCkge1xuICAgIGlmICh0aGlzLl9maXhlcy5oYXMoaWQpKSB7XG4gICAgICB0aGlzLl9maXhlcy5nZXQoaWQpLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX2ZpeGVzLmRlbGV0ZShpZCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVUkgQ29tcG9uZW50IGZvciB1bml2ZXJzYWwgZGlhbG9ncy5cbiAqIE5vdGVzXG4gKiAqIFRoZSB0cmFuc2l0aW9uIGlzIG9uIHRoZSBtYWluIGBlbGVtZW50YCBzbyB0aGF0IGBzY2FsZSgpYCB0cmFuc2Zvcm1zIGRvIG5vdFxuICogY2F1c2UgdGhlIGNhbGN1bGF0aW9uIG9mIGBzY3JvbGxIZWlnaHRgIHRvIGJlIGFydGlmaWNpYWxseSBpbmNyZWFzZWQuXG4gKiAqIFRoZSBiYWNrZHJvcCBpcyBhIHNpYmxpbmcgdG8gdGhlIGRpYWxvZyBzbyB0aGF0IGl0IGRvZXMgbm90IGNvdmVyIHRoZVxuICogc2Nyb2xsYmFyIG9mIHRoZSBkaWFsb2cgYW5kIHNvIHRoYXQgaXQgZG9lc24ndCBqaXR0ZXIgaW4gaU9TLlxuICpcbiAqIEBhdXRob3IgR2xlbiBDaGVuZXkgPGdsZW5Ab2RvcG9kLmNvbT5cbiAqL1xuXG52YXIgRk9DVVNBQkxFX0VMRU1FTlRTID0gWydhW2hyZWZdJywgJ2FyZWFbaHJlZl0nLCAnaW5wdXQ6bm90KFtkaXNhYmxlZF0pJywgJ3NlbGVjdDpub3QoW2Rpc2FibGVkXSknLCAndGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pJywgJ2J1dHRvbjpub3QoW2Rpc2FibGVkXSknLCAnaWZyYW1lJywgJ29iamVjdCcsICdlbWJlZCcsICdbY29udGVudGVkaXRhYmxlXScsICdbdGFiaW5kZXhdOm5vdChbdGFiaW5kZXhePVwiLVwiXSknXS5qb2luKCcsJyk7XG5cbnZhciBEaWFsb2cgPSBmdW5jdGlvbiAoX1RpbnlFbWl0dGVyKSB7XG4gIGluaGVyaXRzKERpYWxvZywgX1RpbnlFbWl0dGVyKTtcblxuICAvKipcbiAgICogRGlhbG9nIHRoYXQgY2FuIGNvbnRhaW4gc3RhdGljIGltYWdlcywgY2Fyb3VzZWxzLCBvciB2aWRlb3NcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBNYWluIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0c10gSW5zdGFuY2Ugb3B0aW9ucy5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBEaWFsb2coZWxlbWVudCwgb3B0cykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIERpYWxvZyk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UaW55RW1pdHRlci5jYWxsKHRoaXMpKTtcblxuICAgIGlmICghKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09kb0RpYWxvZyByZXF1aXJlcyBhbiBlbGVtZW50LiBHb3Q6IFwiJyArIGVsZW1lbnQgKyAnXCInKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCYXNlIEVsZW1lbnQuXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIF90aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuXG4gICAgLyoqXG4gICAgICogT3B0aW9ucyBvYmplY3QuXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKi9cbiAgICBfdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgRGlhbG9nLkRlZmF1bHRzLCBvcHRzKTtcblxuICAgIC8qKlxuICAgICAqIERpYWxvZyBJZC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIF90aGlzLmlkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG5cbiAgICAvKipcbiAgICAgKiBEaWFsb2cgYmFja2Ryb3BcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF90aGlzLmJhY2tkcm9wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgX3RoaXMuYmFja2Ryb3AuY2xhc3NOYW1lID0gRGlhbG9nLkNsYXNzZXMuQkFDS0RST1A7XG5cbiAgICAvKipcbiAgICAgKiBEaWFsb2cgY29udGVudCAocm9sZT1kb2N1bWVudCkuXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfdGhpcy5jb250ZW50ID0gX3RoaXMuZ2V0QnlDbGFzcyhEaWFsb2cuQ2xhc3Nlcy5DT05URU5UKTtcblxuICAgIC8qKlxuICAgICAqIEVsZW1lbnRzIHdoaWNoLCB3aGVuIGNsaWNrZWQsIGNsb3NlIHRoZSBkaWFsb2cuXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50W119XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdGhpcy5fY2xvc2VycyA9IEFycmF5LmZyb20oX3RoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1vZG8tZGlhbG9nLWNsb3NlXScpKTtcblxuICAgIC8qKlxuICAgICAqIFdpbmRvdyByZXNpemUgSWRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RoaXMuX3Jlc2l6ZUlkID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFNjcm9sbEZpeCBpZFxuICAgICAqIEB0eXBlIHs/c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RoaXMuX3Njcm9sbEZpeElkID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGRpYWxvZyBpcyBvcGVuLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIF90aGlzLmlzT3BlbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogSXMgdGhlIGRpYWxvZyBjdXJyZW50bHkgYW5pbWF0aW5nLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfdGhpcy5pc0FuaW1hdGluZyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgYm9keSBoYXMgYSBzY3JvbGxiYXIuXG4gICAgICogQHR5cGUgez9ib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RoaXMuX2hhc0JvZHlTY3JvbGxiYXIgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogUGFkZGluZyBvbiB0aGUgYm9keS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RoaXMuX29yaWdpbmFsQm9keVBhZGRpbmcgPSAtMTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBpcyBhIGZ1bGxzY3JlZW4gZGlhbG9nLiBGdWxsc2NyZWVuIGRpYWxvZ3Mgc2hvdWxkIG5vdCBoYXZlXG4gICAgICogcGFkZGluZ1JpZ2h0IGFwcGxpZWQgdG8gdGhlbS5cbiAgICAgKiBAdHlwZSB7P2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdGhpcy5faXNGdWxsc2NyZWVuID0gbnVsbDtcblxuICAgIF90aGlzLnogPSBEaWFsb2cuWl9CQVNFO1xuXG4gICAgRGlhbG9nLkluc3RhbmNlcy5wdXNoKF90aGlzKTtcblxuICAgIGlmIChEaWFsb2cuSW5zdGFuY2VzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIERpYWxvZy5faGFuZGxlVHJpZ2dlckNsaWNrKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBhdXRvIG1hcmdpbnMgZm9yIGZsZXhib3gsIGFkZCBhIGNsYXNzXG4gICAgLy8gc28gdGhhdCBpdCBjYW4gYmUgY2VudGVyZWQgZGlmZmVyZW50bHkuXG4gICAgX3RoaXMuZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKERpYWxvZy5DbGFzc2VzLk5PX0FVVE9fTUFSR0lOLCAhRGlhbG9nLlNVUFBPUlRTX0FVVE9fTUFSR0lOUyk7XG5cbiAgICBfdGhpcy5fYmluZENvbnRleHRzKCk7XG4gICAgX3RoaXMub25SZXNpemUoKTtcbiAgICBfdGhpcy5fYWRkQTExeUF0dHJpYnV0ZXMoKTtcbiAgICBfdGhpcy5fZW5zdXJlQm9keUNoaWxkKCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgZGVzY2VuZGVudCBlbGVtZW50IGJ5IGNsYXNzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBjbGFzcyB0byBmaW5kLlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fHVuZGVmaW5lZH0gVGhlIGVsZW1lbnQgb3IgdW5kZWZpbmVkLlxuICAgKi9cblxuXG4gIERpYWxvZy5wcm90b3R5cGUuZ2V0QnlDbGFzcyA9IGZ1bmN0aW9uIGdldEJ5Q2xhc3MobmFtZSkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShuYW1lKVswXTtcbiAgfTtcblxuICAvKipcbiAgICogQmluZCBgdGhpc2AgY29udGV4dCB0byBldmVudCBoYW5kbGVycy5cbiAgICovXG5cblxuICBEaWFsb2cucHJvdG90eXBlLl9iaW5kQ29udGV4dHMgPSBmdW5jdGlvbiBfYmluZENvbnRleHRzKCkge1xuICAgIHRoaXMub25LZXlQcmVzcyA9IHRoaXMub25LZXlQcmVzcy5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25DbGljayA9IHRoaXMub25DbGljay5iaW5kKHRoaXMpO1xuICAgIHRoaXMuY2xvc2UgPSB0aGlzLmNsb3NlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5jbG9zZVdpdGhBbmltYXRpb24gPSB0aGlzLmNsb3NlLmJpbmQodGhpcywgZmFsc2UpO1xuICAgIC8vIEJpbmQgdW5kZWZpbmVkIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIgc28gdGhhdCB0aGUgZXZlbnQgb2JqZWN0IHdpbGwgYmVcbiAgICAvLyB0aGUgc2Vjb25kIHBhcmFtZXRlciBhbmQgdGhlIG9wdGlvbmFsIHZpZXdwb3J0SGVpZ2h0IHBhcmFtZXRlciB3aWxsIHdvcmsuXG4gICAgdGhpcy5vbldpbmRvd1Jlc2l6ZSA9IHRoaXMub25SZXNpemUuYmluZCh0aGlzLCB1bmRlZmluZWQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgc3RhdGljIGFjY2Vzc2liaWxpdHkgYXR0cmlidXRlcyBzbyB0aGF0IHRoZSBpbXBsZW1lbnRvciBjYW4gbGVhdmUgdGhlbVxuICAgKiBvZmYgb3IgaW4gY2FzZSB0aGV5IGZvcmdldC5cbiAgICovXG5cblxuICBEaWFsb2cucHJvdG90eXBlLl9hZGRBMTF5QXR0cmlidXRlcyA9IGZ1bmN0aW9uIF9hZGRBMTF5QXR0cmlidXRlcygpIHtcbiAgICB0aGlzLmVsZW1lbnQudGFiSW5kZXggPSAtMTtcbiAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIHRydWUpO1xuICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnZGlhbG9nJyk7XG4gICAgdGhpcy5jb250ZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdkb2N1bWVudCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJZiB0aGUgZGlhbG9nIGVsZW1lbnQgaXMgbm90IGEgZGlyZWN0IGRlc2NlbmRlbnQgb2YgdGhlIDxib2R5PiwgbWFrZSBpdCBzby5cbiAgICovXG5cblxuICBEaWFsb2cucHJvdG90eXBlLl9lbnN1cmVCb2R5Q2hpbGQgPSBmdW5jdGlvbiBfZW5zdXJlQm9keUNoaWxkKCkge1xuICAgIGlmICh0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHRoZSBjb3JyZWN0IGVsZW1lbnQgdG8gc2Nyb2xsIGZpeCBhbmQgZml4IGl0LlxuICAgKi9cblxuXG4gIERpYWxvZy5wcm90b3R5cGUuX2FwcGx5U2Nyb2xsRml4ID0gZnVuY3Rpb24gX2FwcGx5U2Nyb2xsRml4KCkge1xuICAgIC8vIEFsbG93IHRoZSBzY3JvbGxhYmxlIGVsZW1lbnQgdG8gYmUgc29tZXRoaW5nIGluc2lkZSB0aGUgZGlhbG9nLlxuICAgIGlmICh0aGlzLm9wdGlvbnMuc2Nyb2xsYWJsZUVsZW1lbnQpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50Lm1hdGNoZXModGhpcy5vcHRpb25zLnNjcm9sbGFibGVFbGVtZW50KSA/IHRoaXMuZWxlbWVudCA6IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKHRoaXMub3B0aW9ucy5zY3JvbGxhYmxlRWxlbWVudCk7XG4gICAgICB0aGlzLl9zY3JvbGxGaXhJZCA9IFNjcm9sbEZpeCQxLmFkZChlbGVtZW50KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIElmIHRoZSBwYWdlIGFscmVhZHkgaGFzIGEgc2Nyb2xsYmFyLCBhZGRpbmcgb3ZlcmZsb3c6IGhpZGRlbiB3aWxsIHJlbW92ZSBpdCxcbiAgICogc2hpZnRpbmcgdGhlIGNvbnRlbnQgdG8gdGhlIHJpZ2h0LiBUbyBhdm9pZCB0aGlzLCB0aGVyZSBuZWVkcyB0byBiZSBwYWRkaW5nXG4gICAqIG9uIHRoZSBib2R5IHRoYXQncyB0aGUgc2FtZSB3aWR0aCBhcyB0aGUgc2Nyb2xsYmFyLCBidXQgb25seSB3aGVuIHRoZSBkaWFsb2dcbiAgICogd2lsbCBub3QgaGF2ZSBhIHNjcm9sbGJhciB0byB0YWtlIHRoZSBwYWdlIHNjcm9sbGJhcidzIHBsYWNlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuXG5cbiAgRGlhbG9nLnByb3RvdHlwZS5fZ2V0U2Nyb2xsYmFyT2Zmc2V0ID0gZnVuY3Rpb24gX2dldFNjcm9sbGJhck9mZnNldCgpIHtcbiAgICB2YXIgaGFzRGlhbG9nU2Nyb2xsYmFyID0gdGhpcy5lbGVtZW50LnNjcm9sbEhlaWdodCA+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgcmV0dXJuIHRoaXMuX2hhc0JvZHlTY3JvbGxiYXIgJiYgIWhhc0RpYWxvZ1Njcm9sbGJhciA/IERpYWxvZy5TQ1JPTExCQVJfV0lEVEggOiAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGljayBoYW5kbGVyIG9uIHRoZSBtYWluIGVsZW1lbnQuIFdoZW4gdGhlIGRpYWxvZyBpcyBkaXNtaXNzYWJsZSBhbmQgdGhlXG4gICAqIHVzZXIgY2xpY2tlZCBvdXRzaWRlIHRoZSBjb250ZW50IChpLmUuIHRoZSBiYWNrZHJvcCksIGNsb3NlIGl0LlxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2dCBFdmVudCBvYmplY3QuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblxuICBEaWFsb2cucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiBvbkNsaWNrKGV2dCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzbWlzc2FibGUgJiYgZXZ0LnRhcmdldCA9PT0gdGhpcy5lbGVtZW50KSB7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBLZXlwcmVzcyBldmVudCBoYW5kbGVyXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZ0IEV2ZW50IG9iamVjdFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cbiAgRGlhbG9nLnByb3RvdHlwZS5vbktleVByZXNzID0gZnVuY3Rpb24gb25LZXlQcmVzcyhldnQpIHtcbiAgICAvLyBPbmx5IHJlYWN0IHRvIGtleXMgd2hlbiB0aGlzIGRpYWxvZyBpcyB0aGUgdG9wLW1vc3Qgb25lLlxuICAgIGlmICh0aGlzLnogPT09IERpYWxvZy5nZXRUb3BMYXllcigpKSB7XG4gICAgICAvLyBJZiAnRVNDJyBpcyBwcmVzc2VkLCBjbG9zZSB0aGUgZGlhbG9nXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRpc21pc3NhYmxlICYmIGV2dC53aGljaCA9PT0gRGlhbG9nLktleXMuRVNDKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIFRBQiBrZXkgaXMgYmVpbmcgcHJlc3NlZCwgbWFrZSBzdXJlIHRoZSBmb2N1cyBzdGF5cyB0cmFwcGVkIHdpdGhpblxuICAgICAgLy8gdGhlIGRpYWxvZyBlbGVtZW50LlxuICAgICAgaWYgKGV2dC53aGljaCA9PT0gRGlhbG9nLktleXMuVEFCKSB7XG4gICAgICAgIERpYWxvZy5fdHJhcFRhYktleSh0aGlzLmVsZW1lbnQsIGV2dCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgZGlhbG9nIGhhcyBhIGhlaWdodCBvZiAxMDB2aCwgd2hpY2gsIGluIG1vYmlsZSBzYWZhcmksIGlzIGluY29ycmVjdFxuICAgKiB3aGVuIHRoZSB0b29sYmFycyBhcmUgdmlzaWJsZSwgbm90IGFsbG93aW5nIHRoZSB1c2VyIHRvIHNjcm9sbCB0aGUgZnVsbFxuICAgKiBoZWlnaHQgb2YgdGhlIGNvbnRlbnQgd2l0aGluIGl0LlxuICAgKiBUaGUgdmlld3BvcnRIZWlnaHQgcGFyYW1ldGVyIGlzIG9wdGlvbmFsIHNvIHRoYXQgaXQgY2FuIGJlIHJlYWQgaW4gdGhlIG9wZW4oKVxuICAgKiBtZXRob2Qgd2l0aCBhbGwgdGhlIG90aGVyIERPTSByZWFkcy4gVGhpcyBhdm9pZHMgcmVhZC0+d3JpdGUtPnJlYWQgI3BlcmZtYXR0ZXJzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3ZpZXdwb3J0SGVpZ2h0PXdpbmRvdy5pbm5lckhlaWdodF0gSGVpZ2h0IG9mIHRoZSB2aWV3cG9ydC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXG4gIERpYWxvZy5wcm90b3R5cGUub25SZXNpemUgPSBmdW5jdGlvbiBvblJlc2l6ZSgpIHtcbiAgICB2YXIgdmlld3BvcnRIZWlnaHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHdpbmRvdy5pbm5lckhlaWdodDtcblxuICAgIHRoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQgPSB2aWV3cG9ydEhlaWdodCArICdweCc7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyB0byBzZWUgaWYgYSBkaWFsb2cgaXMgYWxyZWFkeSBvcGVuIG9yIGFuaW1hdGluZyBJZiBub3QsIG9wZW5zIGRpYWxvZy5cbiAgICogQHBhcmFtIHtib29sZWFufSBbc3luYz1mYWxzZV0gV2hldGhlciB0byBvcGVuIHdpdGggdHJhbnNpdGlvbnMgb3Igbm90LlxuICAgKi9cblxuXG4gIERpYWxvZy5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgc3luYyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG5cbiAgICBpZiAodGhpcy5pc0FuaW1hdGluZyB8fCB0aGlzLmlzT3Blbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB2aWV3cG9ydEhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICBEaWFsb2cuZm9jdXNlZEJlZm9yZURpYWxvZyA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgdGhpcy5faGFzQm9keVNjcm9sbGJhciA9IGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGggPCB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICB0aGlzLl9pc0Z1bGxzY3JlZW4gPSB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKERpYWxvZy5DbGFzc2VzLkZVTExTQ1JFRU4pO1xuXG4gICAgLy8gQWRkIGFyaWEtaGlkZGVuIHRvIG90aGVyIHRvcC1sZXZlbCB0aGluZ3MuXG4gICAgdmFyIHNpYmxpbmdzID0gRGlhbG9nLl9nZXRTaWJsaW5ncyh0aGlzLmVsZW1lbnQpO1xuICAgIHZhciBvcmlnaW5hbHMgPSBzaWJsaW5ncy5tYXAoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICB9KTtcbiAgICBzaWJsaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50LCBpKSB7XG4gICAgICBpZiAob3JpZ2luYWxzW2ldKSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLW9kby1kaWFsb2ctb3JpZ2luYWwnLCBvcmlnaW5hbHNbaV0pO1xuICAgICAgfVxuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgdHJ1ZSk7XG4gICAgfSk7XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IGFuIG9wZW4gZGlhbG9nLCBpbmNyZWFzZSB0aGUgei1pbmRleCBvZiB0aGlzIGRpYWxvZydzXG4gICAgLy8gbWFpbiBlbGVtZW50IGFuZCBiYWNrZHJvcCBhYm92ZSB0aGUgb3BlbiBvbmUuXG4gICAgaWYgKERpYWxvZy5nZXRPcGVuRGlhbG9nQ291bnQoKSA+IDApIHtcbiAgICAgIHRoaXMuaGFuZGxlT3RoZXJPcGVuRGlhbG9ncygpO1xuICAgIH1cblxuICAgIHRoaXMuaXNPcGVuID0gdHJ1ZTtcbiAgICB0aGlzLm9uUmVzaXplKHZpZXdwb3J0SGVpZ2h0KTtcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xuICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKERpYWxvZy5DbGFzc2VzLk9QRU4pO1xuICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKERpYWxvZy5DbGFzc2VzLkVOVEVSKTtcbiAgICBpZiAoRGlhbG9nLlNDUk9MTEJBUl9XSURUSCkge1xuICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nUmlnaHQgPSBEaWFsb2cuU0NST0xMQkFSX1dJRFRIICsgJ3B4JztcbiAgICB9XG4gICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKERpYWxvZy5DbGFzc2VzLkJPRFlfT1BFTik7XG4gICAgZG9jdW1lbnQuYm9keS5pbnNlcnRCZWZvcmUodGhpcy5iYWNrZHJvcCwgdGhpcy5lbGVtZW50Lm5leHRTaWJsaW5nKTtcbiAgICB0aGlzLmVsZW1lbnQuc2Nyb2xsVG9wID0gMDtcblxuICAgIHRoaXMuX2FwcGx5U2Nyb2xsRml4KCk7XG5cbiAgICB0aGlzLmVsZW1lbnQuZm9jdXMoKTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLm9uS2V5UHJlc3MpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLm9uV2luZG93UmVzaXplKTtcbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uQ2xpY2spO1xuICAgIHRoaXMuX2Nsb3NlcnMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIF90aGlzMi5jbG9zZVdpdGhBbmltYXRpb24pO1xuICAgIH0pO1xuXG4gICAgaWYgKHN5bmMgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuX29wZW5OZXh0KCk7XG4gICAgICB0aGlzLl9vcGVuZWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgRGlhbG9nLl9uZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuX29wZW5OZXh0KCk7XG4gICAgICAgIG9uVHJhbnNpdGlvbkVuZChfdGhpczIuZWxlbWVudCwgX3RoaXMyLl9vcGVuZWQsIF90aGlzMiwgbnVsbCwgMTAwMCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHRoZSB0cmFuc2l0aW9uIGZvciBvcGVuaW5nIHRoZSBkaWFsb2cuXG4gICAqL1xuXG5cbiAgRGlhbG9nLnByb3RvdHlwZS5fb3Blbk5leHQgPSBmdW5jdGlvbiBfb3Blbk5leHQoKSB7XG4gICAgdGhpcy5pc0FuaW1hdGluZyA9IHRydWU7XG4gICAgLy8gTm93IHRoYXQgdGhlIGRpYWxvZyBpcyBubyBsb25nZXIgZGlzcGxheTpub25lLCB0aGUgc2Nyb2xsSGVpZ2h0IGNhbiBiZSBtZWFzdXJlZC5cbiAgICB2YXIgc2Nyb2xsYmFyT2Zmc2V0ID0gdGhpcy5fZ2V0U2Nyb2xsYmFyT2Zmc2V0KCk7XG4gICAgaWYgKCF0aGlzLl9pc0Z1bGxzY3JlZW4gJiYgc2Nyb2xsYmFyT2Zmc2V0ID4gMCkge1xuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodCA9IHNjcm9sbGJhck9mZnNldCArICdweCc7XG4gICAgfVxuXG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoRGlhbG9nLkNsYXNzZXMuRU5URVIpO1xuICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKERpYWxvZy5DbGFzc2VzLkVOVEVSSU5HKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIHRoZSBlbmQgb2YgdGhlIG9wZW4gdHJhbnNpdGlvbi4gRW1pdHMgT1BFTkVEIGV2ZW50LlxuICAgKi9cblxuXG4gIERpYWxvZy5wcm90b3R5cGUuX29wZW5lZCA9IGZ1bmN0aW9uIF9vcGVuZWQoKSB7XG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoRGlhbG9nLkNsYXNzZXMuRU5URVJJTkcpO1xuICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKERpYWxvZy5DbGFzc2VzLlZJU0lCTEUpO1xuICAgIHRoaXMuaXNBbmltYXRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoRGlhbG9nLkV2ZW50VHlwZS5PUEVORUQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIaWRlcyBkaWFsb2dcbiAgICogQHBhcmFtIHtib29sZWFufSBbc3luYz1mYWxzZV0gV2hldGhlciB0byBjbG9zZSB3aXRoIHRyYW5zaXRpb25zIG9yIG5vdC5cbiAgICovXG5cblxuICBEaWFsb2cucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICB2YXIgc3luYyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG5cbiAgICBpZiAodGhpcy5pc0FuaW1hdGluZyB8fCAhdGhpcy5pc09wZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgYXJpYS1oaWRkZW4gdG8gb3RoZXIgdG9wLWxldmVsIHRoaW5ncy5cbiAgICB2YXIgc2libGluZ3MgPSBEaWFsb2cuX2dldFNpYmxpbmdzKHRoaXMuZWxlbWVudCk7XG4gICAgdmFyIG9yaWdpbmFscyA9IHNpYmxpbmdzLm1hcChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLW9kby1kaWFsb2ctb3JpZ2luYWwnKTtcbiAgICB9KTtcbiAgICBzaWJsaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50LCBpKSB7XG4gICAgICBpZiAob3JpZ2luYWxzW2ldKSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIG9yaWdpbmFsc1tpXSk7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdkYXRhLW9kby1kaWFsb2ctb3JpZ2luYWwnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5pc09wZW4gPSBmYWxzZTtcbiAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChEaWFsb2cuQ2xhc3Nlcy5MRUFWRSk7XG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoRGlhbG9nLkNsYXNzZXMuVklTSUJMRSk7XG5cbiAgICBTY3JvbGxGaXgkMS5yZW1vdmUodGhpcy5fc2Nyb2xsRml4SWQpO1xuXG4gICAgLy8gU3VwcG9ydDogSUUxMVxuICAgIC8vIENsaWNraW5nIG9uIGFuIFNWRyBlbGVtZW50IGluc2lkZSBhbiA8YT4gd2lsbCBzZXQgdGhlIGBmb2N1c2VkQmVmb3JlRGlhbG9nYFxuICAgIC8vIHRvIHRoZSBTVkcsIGJ1dCBTVkcgZG9lc24ndCBoYXZlIGEgYGZvY3VzKClgIG1ldGhvZCBpbiBJRS5cbiAgICBpZiAoRGlhbG9nLmZvY3VzZWRCZWZvcmVEaWFsb2cgJiYgdHlwZW9mIERpYWxvZy5mb2N1c2VkQmVmb3JlRGlhbG9nLmZvY3VzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBEaWFsb2cuZm9jdXNlZEJlZm9yZURpYWxvZy5mb2N1cygpO1xuICAgIH1cblxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLm9uS2V5UHJlc3MpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLm9uV2luZG93UmVzaXplKTtcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uQ2xpY2spO1xuICAgIHRoaXMuX2Nsb3NlcnMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIF90aGlzMy5jbG9zZVdpdGhBbmltYXRpb24pO1xuICAgIH0pO1xuXG4gICAgaWYgKHN5bmMgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuX2Nsb3NlTmV4dCgpO1xuICAgICAgdGhpcy5fY2xvc2VkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIERpYWxvZy5fbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMzLl9jbG9zZU5leHQoKTtcbiAgICAgICAgb25UcmFuc2l0aW9uRW5kKF90aGlzMy5lbGVtZW50LCBfdGhpczMuX2Nsb3NlZCwgX3RoaXMzLCBudWxsLCAxMDAwKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU3RhcnQgdGhlIHRyYW5zaXRpb24gZm9yIGNsb3NpbmcgdGhlIGRpYWxvZy5cbiAgICovXG5cblxuICBEaWFsb2cucHJvdG90eXBlLl9jbG9zZU5leHQgPSBmdW5jdGlvbiBfY2xvc2VOZXh0KCkge1xuICAgIHRoaXMuaXNBbmltYXRpbmcgPSB0cnVlO1xuICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKERpYWxvZy5DbGFzc2VzLkxFQVZFKTtcbiAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChEaWFsb2cuQ2xhc3Nlcy5MRUFWSU5HKTtcbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlIHRoZSBlbmQgb2YgdGhlIGNsb3NlIHRyYW5zaXRpb24uIEVtaXRzIHRoZSBDTE9TRUQgZXZlbnQuXG4gICAqL1xuXG5cbiAgRGlhbG9nLnByb3RvdHlwZS5fY2xvc2VkID0gZnVuY3Rpb24gX2Nsb3NlZCgpIHtcbiAgICB0aGlzLmlzQW5pbWF0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodCA9ICcnO1xuICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgdHJ1ZSk7XG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoRGlhbG9nLkNsYXNzZXMuT1BFTik7XG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoRGlhbG9nLkNsYXNzZXMuTEVBVklORyk7XG4gICAgaWYgKERpYWxvZy5nZXRPcGVuRGlhbG9nQ291bnQoKSA9PT0gMCkge1xuICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nUmlnaHQgPSAnJztcbiAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShEaWFsb2cuQ2xhc3Nlcy5CT0RZX09QRU4pO1xuICAgIH1cbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMuYmFja2Ryb3ApO1xuICAgIHRoaXMuZW1pdChEaWFsb2cuRXZlbnRUeXBlLkNMT1NFRCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1vZGlmeSBkaWFsb2cgei1pbmRpY2VzIGFuZCBtb3JlIGJlY2F1c2UgdGhlcmUgYXJlIGFib3V0IHRvIGJlIG11bHRpcGxlXG4gICAqIGRpYWxvZ3Mgb3BlbiBhdCB0aGUgc2FtZSB0aW1lLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cbiAgRGlhbG9nLnByb3RvdHlwZS5oYW5kbGVPdGhlck9wZW5EaWFsb2dzID0gZnVuY3Rpb24gaGFuZGxlT3RoZXJPcGVuRGlhbG9ncygpIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgIHRoaXMueiA9IERpYWxvZy5nZXRUb3BMYXllcigpICsgMjA7XG4gICAgdGhpcy5lbGVtZW50LnN0eWxlLnpJbmRleCA9IHRoaXMuejtcbiAgICB0aGlzLmJhY2tkcm9wLnN0eWxlLnpJbmRleCA9IHRoaXMueiAtIDU7XG5cbiAgICAvLyBXaGVuIHRoaXMgZGlhbG9nIGlzIGNsb3NlZCwgcmV2ZXJ0IHRoZSB6LWluZGV4IGJhY2sgdG8gaXRzIG9yaWdpbmFsIHZhbHVlLlxuICAgIHRoaXMub25jZShEaWFsb2cuRXZlbnRUeXBlLkNMT1NFRCwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXM0LnogPSBEaWFsb2cuWl9CQVNFO1xuICAgICAgX3RoaXM0LmVsZW1lbnQuc3R5bGUuekluZGV4ID0gJyc7XG4gICAgICBfdGhpczQuYmFja2Ryb3Auc3R5bGUuekluZGV4ID0gJyc7XG5cbiAgICAgIC8vIEZpbmQgbmV3IHRvcCBkaWFsb2cuXG4gICAgICB2YXIgelRvcCA9IERpYWxvZy5nZXRUb3BMYXllcigpO1xuXG4gICAgICBEaWFsb2cuSW5zdGFuY2VzLmZvckVhY2goZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZS5pc09wZW4gJiYgaW5zdGFuY2UueiA9PT0gelRvcCkge1xuICAgICAgICAgIGluc3RhbmNlLmRpZEVudGVyRm9yZWdyb3VuZCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIFRlbGwgb3RoZXIgZGlhbG9ncyB0aGV5J3JlIGdvaW5nIGludG8gdGhlIGJhY2tncm91bmQuXG4gICAgRGlhbG9nLkluc3RhbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgaWYgKGluc3RhbmNlLmlzT3BlbiAmJiBpbnN0YW5jZS5pZCAhPT0gX3RoaXM0LmlkKSB7XG4gICAgICAgIGluc3RhbmNlLmRpZEVudGVyQmFja2dyb3VuZCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEaWFsb2cgd2VudCBpbnRvIHRoZSBiYWNrZ3JvdW5kIGFuZCBoYXMgYW5vdGhlciBkaWFsb2cgb3BlbiBhYm92ZSBpdC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXG4gIERpYWxvZy5wcm90b3R5cGUuZGlkRW50ZXJCYWNrZ3JvdW5kID0gZnVuY3Rpb24gZGlkRW50ZXJCYWNrZ3JvdW5kKCkge1xuICAgIFNjcm9sbEZpeCQxLnJlbW92ZSh0aGlzLl9zY3JvbGxGaXhJZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERpYWxvZyBjYW1lIGJhY2sgaW50byB0aGUgZm9yZWdyb3VuZCBhZnRlciBiZWluZyBpbiB0aGUgYmFja2dyb3VuZC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXG4gIERpYWxvZy5wcm90b3R5cGUuZGlkRW50ZXJGb3JlZ3JvdW5kID0gZnVuY3Rpb24gZGlkRW50ZXJGb3JlZ3JvdW5kKCkge1xuICAgIHRoaXMuX2FwcGx5U2Nyb2xsRml4KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsb3NlIHRoZSBkaWFsb2csIHJlbW92ZSBldmVudCBsaXN0ZW5lcnMgYW5kIGVsZW1lbnQgcmVmZXJlbmNlcy5cbiAgICovXG5cblxuICBEaWFsb2cucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIGlmICh0aGlzLmlzT3Blbikge1xuICAgICAgdGhpcy5jbG9zZSh0cnVlKTtcbiAgICB9XG5cbiAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuY29udGVudCA9IG51bGw7XG4gICAgdGhpcy5iYWNrZHJvcCA9IG51bGw7XG4gICAgdGhpcy5fY2xvc2Vycy5sZW5ndGggPSAwO1xuXG4gICAgcHVsbChEaWFsb2cuSW5zdGFuY2VzLCB0aGlzKTtcblxuICAgIC8vIElmIHRoaXMgaXMgdGhlIGxhc3QgZGlhbG9nIChiZWluZyBkaXNwb3NlZCksIHJlbW92ZSB0aGUgYm9keSBsaXN0ZW5lci5cbiAgICBpZiAoRGlhbG9nLkluc3RhbmNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBEaWFsb2cuX2hhbmRsZVRyaWdnZXJDbGljayk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsIGEgZnVuY3Rpb24gYWZ0ZXIgdHdvIGFuaW1hdGlvbiBmcmFtZXMuIFVzaW5nIGp1c3Qgb25lIGlzIHVucmVsaWFibGVcbiAgICogd2hlbiB1c2luZyBhbmltYXRpb25zIHRvL2Zyb20gZGlzcGxheTpub25lIGVsZW1lbnRzIG9yIG9uZXMgdGhhdCBhcmUgbm90XG4gICAqIHlldCBpbiB0aGUgRE9NLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIG9uIHRoZSBuZXh0IGZyYW1lLlxuICAgKi9cblxuXG4gIERpYWxvZy5fbmV4dEZyYW1lID0gZnVuY3Rpb24gX25leHRGcmFtZShmbikge1xuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKG51bGwsIGZuKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIE9wZW4gdGhlIGNvcnJlY3QgZGlhbG9nIHdoZW4gYW4gZWxlbWVudCB3aXRoIGBkYXRhLW9kby1kaWFsb2ctb3BlbmAgYXR0cmlidXRlXG4gICAqIGlzIGNsaWNrZWQuXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2dCBFdmVudCBvYmplY3QuXG4gICAqL1xuXG5cbiAgRGlhbG9nLl9oYW5kbGVUcmlnZ2VyQ2xpY2sgPSBmdW5jdGlvbiBfaGFuZGxlVHJpZ2dlckNsaWNrKGV2dCkge1xuICAgIHZhciB0cmlnZ2VyID0gZXZ0LnRhcmdldC5jbG9zZXN0KCdbZGF0YS1vZG8tZGlhbG9nLW9wZW5dJyk7XG5cbiAgICBpZiAodHJpZ2dlciAhPT0gbnVsbCkge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB2YXIgaWQgPSB0cmlnZ2VyLmdldEF0dHJpYnV0ZSgnZGF0YS1vZG8tZGlhbG9nLW9wZW4nKTtcbiAgICAgIHZhciBpbnN0YW5jZSA9IERpYWxvZy5nZXREaWFsb2dCeUlkKGlkKTtcbiAgICAgIGluc3RhbmNlLmVtaXQoRGlhbG9nLkV2ZW50VHlwZS5UUklHR0VSX0NMSUNLRUQsIHRyaWdnZXIpO1xuICAgICAgaW5zdGFuY2Uub3BlbigpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVHJhcCB0aGUgZm9jdXMgaW5zaWRlIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldnRcbiAgICovXG5cblxuICBEaWFsb2cuX3RyYXBUYWJLZXkgPSBmdW5jdGlvbiBfdHJhcFRhYktleShub2RlLCBldnQpIHtcbiAgICB2YXIgZm9jdXNhYmxlQ2hpbGRyZW4gPSBEaWFsb2cuX2dldEZvY3VzYWJsZUNoaWxkcmVuKG5vZGUpO1xuICAgIHZhciBmb2N1c2VkSXRlbUluZGV4ID0gZm9jdXNhYmxlQ2hpbGRyZW4uaW5kZXhPZihkb2N1bWVudC5hY3RpdmVFbGVtZW50KTtcblxuICAgIC8vIElmIHRoZSBTSElGVCBrZXkgaXMgYmVpbmcgcHJlc3NlZCB3aGlsZSB0YWJiaW5nIChtb3ZpbmcgYmFja3dhcmRzKSBhbmRcbiAgICAvLyB0aGUgY3VycmVudGx5IGZvY3VzZWQgaXRlbSBpcyB0aGUgZmlyc3Qgb25lLCBtb3ZlIHRoZSBmb2N1cyB0byB0aGUgbGFzdFxuICAgIC8vIGZvY3VzYWJsZSBpdGVtIGZyb20gdGhlIGRpYWxvZyBlbGVtZW50XG4gICAgaWYgKGV2dC5zaGlmdEtleSAmJiBmb2N1c2VkSXRlbUluZGV4ID09PSAwKSB7XG4gICAgICBmb2N1c2FibGVDaGlsZHJlbltmb2N1c2FibGVDaGlsZHJlbi5sZW5ndGggLSAxXS5mb2N1cygpO1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAvLyBJZiB0aGUgU0hJRlQga2V5IGlzIG5vdCBiZWluZyBwcmVzc2VkIChtb3ZpbmcgZm9yd2FyZHMpIGFuZCB0aGUgY3VycmVudGx5XG4gICAgICAvLyBmb2N1c2VkIGl0ZW0gaXMgdGhlIGxhc3Qgb25lLCBtb3ZlIHRoZSBmb2N1cyB0byB0aGUgZmlyc3QgZm9jdXNhYmxlIGl0ZW1cbiAgICAgIC8vIGZyb20gdGhlIGRpYWxvZyBlbGVtZW50XG4gICAgfSBlbHNlIGlmICghZXZ0LnNoaWZ0S2V5ICYmIGZvY3VzZWRJdGVtSW5kZXggPT09IGZvY3VzYWJsZUNoaWxkcmVuLmxlbmd0aCAtIDEpIHtcbiAgICAgIGZvY3VzYWJsZUNoaWxkcmVuWzBdLmZvY3VzKCk7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZm9jdXNhYmxlIGNoaWxkcmVuIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICogQHJldHVybiB7RWxlbWVudFtdfVxuICAgKi9cblxuXG4gIERpYWxvZy5fZ2V0Rm9jdXNhYmxlQ2hpbGRyZW4gPSBmdW5jdGlvbiBfZ2V0Rm9jdXNhYmxlQ2hpbGRyZW4oZWxlbWVudCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChGT0NVU0FCTEVfRUxFTUVOVFMpKS5maWx0ZXIoRGlhbG9nLl9pc1Zpc2libGVFbGVtZW50KTtcbiAgfTtcblxuICAvKipcbiAgICogV2hldGhlciBhbiBlbGVtZW50IGlzIHZpc2libGUgKGFuZCB0aGVyZWZvcmUgY2FuIHJlY2VpdmUgZm9jdXMpLiBVc2VzXG4gICAqIGBnZXRDbGllbnRSZWN0c2AgZHVlIHRvIHRoaXMgaXNzdWU6XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L2lzc3Vlcy8yMjI3XG4gICAqIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvMnRndzJ5cjMvXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIEVsZW1lbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuXG5cbiAgRGlhbG9nLl9pc1Zpc2libGVFbGVtZW50ID0gZnVuY3Rpb24gX2lzVmlzaWJsZUVsZW1lbnQoZWwpIHtcbiAgICByZXR1cm4gISEoZWwub2Zmc2V0V2lkdGggfHwgZWwub2Zmc2V0SGVpZ2h0IHx8IGVsLmdldENsaWVudFJlY3RzKCkubGVuZ3RoKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmUgdGhlIHNpYmxpbmdzIG9mIGFuIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIGdldCBzaWJsaW5ncyBmb3IuXG4gICAqIEByZXR1cm4ge0FycmF5LjxFbGVtZW50Pn1cbiAgICovXG5cblxuICBEaWFsb2cuX2dldFNpYmxpbmdzID0gZnVuY3Rpb24gX2dldFNpYmxpbmdzKGVsZW1lbnQpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBBcnJheS5mcm9tKGVsZW1lbnQucGFyZW50RWxlbWVudC5jaGlsZHJlbik7XG4gICAgdmFyIGlnbm9yZSA9IFsnc2NyaXB0JywgJ2xpbmsnLCAnbWV0YSddO1xuICAgIHJldHVybiBjaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlICE9PSBlbGVtZW50ICYmICFpZ25vcmUuaW5jbHVkZXMobm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSB3aWR0aCBvZiB0aGUgc2Nyb2xsYmFyIGJlY2F1c2Ugd2hlbiB0aGUgYm9keSBoYXMgb3ZlcmZsb3c6aGlkZGVuLFxuICAgKiB0aGUgc2Nyb2xsYmFyIGRpc2FwcGVhcnMuXG4gICAqIGh0dHBzOi8vZGF2aWR3YWxzaC5uYW1lL2RldGVjdC1zY3JvbGxiYXItd2lkdGhcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cblxuXG4gIERpYWxvZy5fZ2V0U2Nyb2xsYmFyV2lkdGggPSBmdW5jdGlvbiBfZ2V0U2Nyb2xsYmFyV2lkdGgoKSB7XG4gICAgLy8gQ3JlYXRlIG1lYXN1cmVtZW50IG5vZGUuXG4gICAgdmFyIHNjcm9sbERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHNjcm9sbERpdi5zdHlsZS5jc3NUZXh0ID0gJ3dpZHRoOjUwcHg7aGVpZ2h0OjUwcHg7b3ZlcmZsb3c6c2Nyb2xsO3Bvc2l0aW9uOmFic29sdXRlO3RvcDotOTk5OXB4Oyc7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JvbGxEaXYpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBzY3JvbGxiYXIgd2lkdGguXG4gICAgdmFyIHNjcm9sbGJhcldpZHRoID0gc2Nyb2xsRGl2Lm9mZnNldFdpZHRoIC0gc2Nyb2xsRGl2LmNsaWVudFdpZHRoO1xuXG4gICAgLy8gUmVtb3ZlIHRlc3QgZWxlbWVudC5cbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHNjcm9sbERpdik7XG5cbiAgICByZXR1cm4gc2Nyb2xsYmFyV2lkdGg7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVuZm9ydHVuYXRlbHksIHRoZSBhdXRvIG1hcmdpbnMgZG8gbm90IHdvcmsgZm9yIGZsZXggY2hpbGRyZW4gaW4gSUUxMSBhbmRcbiAgICogYmVsb3cgYmVjYXVzZSB0aGUgY29udGVudCBlbGVtZW50IGRvZXMgaGF2ZSBhbiBleHBsaWNpdCBoZWlnaHQgc2V0IG9uIGl0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cblxuXG4gIERpYWxvZy5fYXV0b01hcmdpblRlc3QgPSBmdW5jdGlvbiBfYXV0b01hcmdpblRlc3QoKSB7XG4gICAgdmFyIHBhcmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHZhciBjaGlsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHBhcmVudC5zdHlsZS5jc3NUZXh0ID0gJ2Rpc3BsYXk6ZmxleDtoZWlnaHQ6NTBweDt3aWR0aDo1MHB4O3Bvc2l0aW9uOmFic29sdXRlOyc7XG4gICAgY2hpbGQuc3R5bGUuY3NzVGV4dCA9ICdtYXJnaW46YXV0bzsnO1xuICAgIGNoaWxkLmlubmVySFRNTCA9ICdhJztcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocGFyZW50KTtcblxuICAgIHZhciByZXQgPSBjaGlsZC5vZmZzZXRUb3AgPiAwO1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQocGFyZW50KTtcblxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluc3RhbnRpYXRlcyBhbGwgaW5zdGFuY2VzIG9mIGRpYWxvZ3Mgd2l0aCB0aGUgc2FtZSBzZXR0aW5nc1xuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBPYmplY3Qgb2YgYWxsIGRpYWxvZyBvcHRpb25zLiBJcyBvcHRpb25hbC5cbiAgICogQHJldHVybiB7RGlhbG9nW119XG4gICAqL1xuXG5cbiAgRGlhbG9nLmluaXRpYWxpemVBbGwgPSBmdW5jdGlvbiBpbml0aWFsaXplQWxsKG9wdGlvbnMpIHtcbiAgICBEaWFsb2cuZGlzcG9zZUFsbCgpO1xuXG4gICAgcmV0dXJuIEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLicgKyBEaWFsb2cuQ2xhc3Nlcy5CQVNFKSwgZnVuY3Rpb24gKGRpYWxvZykge1xuICAgICAgcmV0dXJuIG5ldyBEaWFsb2coZGlhbG9nLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQ2xlYXIgYWxsIHJlZmVyZW5jZXMgdG8gZGlhbG9ncyBzbyB0aGVyZSBhcmUgbm8gZHVwbGljYXRlcy5cbiAgICovXG5cblxuICBEaWFsb2cuZGlzcG9zZUFsbCA9IGZ1bmN0aW9uIGRpc3Bvc2VBbGwoKSB7XG4gICAgdmFyIGNsb25lID0gRGlhbG9nLkluc3RhbmNlcy5zbGljZSgpO1xuICAgIGNsb25lLmZvckVhY2goZnVuY3Rpb24gKGRpYWxvZykge1xuICAgICAgZGlhbG9nLmRpc3Bvc2UoKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmUgYSBkaWFsb2cgaW5zdGFuY2UgYnkgaXRzIGlkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSWQgb2YgdGhlIGRpYWxvZy5cbiAgICogQHJldHVybiB7P0RpYWxvZ30gVGhlIGRpYWxvZyBvciB1bmRlZmluZWQgaWYgdGhlcmUgaXMgbm8gZGlhbG9nIHdpdGggdGhlIGdpdmVuIGlkLlxuICAgKi9cblxuXG4gIERpYWxvZy5nZXREaWFsb2dCeUlkID0gZnVuY3Rpb24gZ2V0RGlhbG9nQnlJZChpZCkge1xuICAgIHJldHVybiBEaWFsb2cuSW5zdGFuY2VzLmZpbmQoZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2UuaWQgPT09IGlkO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb3VudCBob3cgbWFueSBkaWFsb2dzIGFyZSBjdXJyZW50bHkgb3Blbi5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cblxuXG4gIERpYWxvZy5nZXRPcGVuRGlhbG9nQ291bnQgPSBmdW5jdGlvbiBnZXRPcGVuRGlhbG9nQ291bnQoKSB7XG4gICAgcmV0dXJuIERpYWxvZy5JbnN0YW5jZXMuZmlsdGVyKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlLmlzT3BlbjtcbiAgICB9KS5sZW5ndGg7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIHogaW5kZXggb2YgdGhlIHRvcC1tb3N0IGRpYWxvZyBpbnN0YW5jZS5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cblxuXG4gIERpYWxvZy5nZXRUb3BMYXllciA9IGZ1bmN0aW9uIGdldFRvcExheWVyKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItc3ByZWFkXG4gICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KE1hdGgsIERpYWxvZy5JbnN0YW5jZXMubWFwKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlLno7XG4gICAgfSkpO1xuICB9O1xuXG4gIHJldHVybiBEaWFsb2c7XG59KFRpbnlFbWl0dGVyKTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5cblxuRGlhbG9nLkNsYXNzZXMgPSB7XG4gIEJPRFlfT1BFTjogJ29kby1kaWFsb2ctb3BlbicsXG4gIEJBU0U6ICdvZG8tZGlhbG9nJyxcbiAgT1BFTjogJ29kby1kaWFsb2ctLW9wZW4nLFxuICBFTlRFUjogJ29kby1kaWFsb2ctLWVudGVyJyxcbiAgRU5URVJJTkc6ICdvZG8tZGlhbG9nLS1lbnRlci1hY3RpdmUnLFxuICBMRUFWRTogJ29kby1kaWFsb2ctLWxlYXZlJyxcbiAgTEVBVklORzogJ29kby1kaWFsb2ctLWxlYXZlLWFjdGl2ZScsXG4gIFZJU0lCTEU6ICdvZG8tZGlhbG9nLS12aXNpYmxlJyxcbiAgRlVMTFNDUkVFTjogJ29kby1kaWFsb2ctLWZ1bGwnLFxuICBOT19BVVRPX01BUkdJTjogJ29kby1kaWFsb2ctLW5vLWF1dG8tbWFyZ2luJyxcbiAgQkFDS0RST1A6ICdvZG8tZGlhbG9nLWJhY2tkcm9wJyxcbiAgQ09OVEVOVDogJ29kby1kaWFsb2dfX2NvbnRlbnQnXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbkRpYWxvZy5FdmVudFR5cGUgPSB7XG4gIE9QRU5FRDogJ29kb2RpYWxvZzpvcGVuJyxcbiAgQ0xPU0VEOiAnb2RvZGlhbG9nOmNsb3NlZCcsXG4gIFRSSUdHRVJfQ0xJQ0tFRDogJ29kb2RpYWxvZzp0cmlnZ2VyY2xpY2tlZCdcbn07XG5cbi8qKiBAZW51bSB7bnVtYmVyfSAqL1xuRGlhbG9nLktleXMgPSB7XG4gIEVTQzogMjcsXG4gIFRBQjogOVxufTtcblxuRGlhbG9nLkRlZmF1bHRzID0ge1xuICBkaXNtaXNzYWJsZTogdHJ1ZSxcbiAgc2Nyb2xsYWJsZUVsZW1lbnQ6ICcub2RvLWRpYWxvZydcbn07XG5cbi8qKiBAdHlwZSB7RGlhbG9nW119ICovXG5EaWFsb2cuSW5zdGFuY2VzID0gW107XG5cbkRpYWxvZy5aX0JBU0UgPSAxMDUwO1xuXG5EaWFsb2cuU2Nyb2xsRml4ID0gU2Nyb2xsRml4JDE7XG5cbi8qKlxuICogRWxlbWVudCB3aGljaCBoYWQgZm9jdXMgYmVmb3JlIHRoZSBkaWFsb2cgb3BlbmVkLlxuICogQHR5cGUge0VsZW1lbnR9XG4gKi9cbkRpYWxvZy5mb2N1c2VkQmVmb3JlRGlhbG9nID0gbnVsbDtcblxuRGlhbG9nLlNVUFBPUlRTX0FVVE9fTUFSR0lOUyA9IERpYWxvZy5fYXV0b01hcmdpblRlc3QoKTtcbkRpYWxvZy5TQ1JPTExCQVJfV0lEVEggPSBEaWFsb2cuX2dldFNjcm9sbGJhcldpZHRoKCk7XG5cbmV4cG9ydCBkZWZhdWx0IERpYWxvZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9kby1kaWFsb2cuZXNtLmpzLm1hcFxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@odopod/odo-dialog/dist/odo-dialog.esm.js\n");

/***/ }),

/***/ "./node_modules/@odopod/odo-draggable/dist/odo-draggable.esm.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@odopod/odo-draggable/dist/odo-draggable.esm.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _odopod_odo_pointer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @odopod/odo-pointer */ \"./node_modules/@odopod/odo-pointer/dist/odo-pointer.esm.js\");\n/* harmony import */ var tiny_emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tiny-emitter */ \"./node_modules/tiny-emitter/index.js\");\n/* harmony import */ var tiny_emitter__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(tiny_emitter__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _odopod_odo_device__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @odopod/odo-device */ \"./node_modules/@odopod/odo-device/dist/odo-device.esm.js\");\n/* harmony import */ var _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @odopod/odo-helpers */ \"./node_modules/@odopod/odo-helpers/dist/odo-helpers.esm.js\");\n\n\n\n\n\nvar settings = {\n  /** @enum {string} */\n  EventType: {\n    START: 'ododraggable:start',\n    MOVE: 'ododraggable:move',\n    END: 'ododraggable:end',\n    SETTLE: 'ododraggable:throwsettle'\n  },\n\n  Classes: {\n    GRABBABLE: 'grabbable',\n    GRABBING: 'grabbing'\n  },\n\n  Defaults: {\n    // Draggable axis.\n    axis: _odopod_odo_pointer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Axis.X,\n\n    // Amplifies throw velocity by this value. Higher values make the throwable\n    // travel farther and faster.\n    amplifier: 24,\n\n    // Once the velocity has gone below this threshold, throwing stops.\n    velocityStop: 0.08,\n\n    // On each throw frame, the velocity is multiplied by this friction value.\n    // It must be less than 1. Higher values let the throwable slide farther and longer.\n    throwFriction: 0.94,\n\n    // Whether the draggable will keep its movement momentum after the user releases.\n    isThrowable: false\n  }\n};\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n/**\n * Throws an error if `condition` is falsy.\n * @param {boolean} condition The condition to test.\n * @param {string} message Error message.\n * @throws {Error} If condition is falsy.\n * @private\n */\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\n/**\n * Ensure the containing element has a width and height.\n * @param {Object} obj Object to test.\n */\nfunction ensureObjectHasSize(obj) {\n  assert(obj.width > 0, 'containing element\\'s width is zero');\n  assert(obj.height > 0, 'containing element\\'s height is zero');\n}\n\nvar Draggable = function (_TinyEmitter) {\n  inherits(Draggable, _TinyEmitter);\n\n  function Draggable(element) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    classCallCheck(this, Draggable);\n\n    /**\n     * The draggable element.\n     * @type {HTMLElement}\n     * @private\n     */\n    var _this = possibleConstructorReturn(this, _TinyEmitter.call(this));\n\n    _this.element = element;\n\n    /**\n     * Override any defaults with the given options.\n     * @type {Object}\n     */\n    _this.options = Object.assign({}, Draggable.Defaults, options);\n\n    /**\n     * The element which contains the target.\n     * @type {HTMLElement}\n     * @private\n     */\n    _this._parentEl = element.parentNode;\n\n    /**\n     * Current position of the handle/target.\n     * @type {Coordinate}\n     * @private\n     */\n    _this._currentPosition = new _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_3__[\"Coordinate\"]();\n\n    /**\n     * Starting location of the drag.\n     * @type {Coordinate}\n     * @private\n     */\n    _this._relativeZero = new _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_3__[\"Coordinate\"]();\n\n    /**\n     * Velocity at which the draggable was thrown. This value decays over time\n     * after a throw.\n     * @private\n     * @type {Coordinate}\n     */\n    _this._throwVelocity = new _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_3__[\"Coordinate\"]();\n\n    /**\n     * The change in position from the start of the drag.\n     * @private\n     * @type {Coordinate}\n     */\n    _this._delta = new _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_3__[\"Coordinate\"]();\n\n    /**\n     * Animation frame id.\n     * @private\n     * @type {number}\n     */\n    _this._requestId = 0;\n\n    /**\n     * The size of the containing element. This element is used to determine\n     * the percentage position of the draggable element.\n     * @type {Object}\n     */\n    _this._container = { width: 0, height: 0 };\n\n    /**\n     * Limits of how far the draggable element can be dragged.\n     * @type {Rect}\n     */\n    _this.limits = new _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_3__[\"Rect\"](NaN, NaN, NaN, NaN);\n\n    _this.pointer = new _odopod_odo_pointer__WEBPACK_IMPORTED_MODULE_0__[\"default\"](element, {\n      axis: _this.options.axis\n    });\n\n    _this.element.classList.add(Draggable.Classes.GRABBABLE);\n\n    // Kick off.\n    _this._listen();\n    return _this;\n  }\n\n  Draggable.prototype._listen = function _listen() {\n    this._onStart = this._handleDragStart.bind(this);\n    this._onMove = this._handleDragMove.bind(this);\n    this._onEnd = this._handleDragEnd.bind(this);\n\n    this.pointer.on(_odopod_odo_pointer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].EventType.START, this._onStart);\n    this.pointer.on(_odopod_odo_pointer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].EventType.MOVE, this._onMove);\n    this.pointer.on(_odopod_odo_pointer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].EventType.END, this._onEnd);\n  };\n\n  /**\n   * Saves the containment element's width and height and scrubber position.\n   * @private\n   */\n\n\n  Draggable.prototype._saveDimensions = function _saveDimensions() {\n    this._container = Object(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_3__[\"getSize\"])(this.element);\n    ensureObjectHasSize(this._container);\n    this._relativeZero = this._getRelativeZero();\n  };\n\n  /**\n   * The position relative to the rest of the page. When it's first\n   * initialized, it is zero zero, but after dragging, it is the position\n   * relative to zero zero.\n   * @return {!Coordinate}\n   * @private\n   */\n\n\n  Draggable.prototype._getRelativeZero = function _getRelativeZero() {\n    return _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_3__[\"Coordinate\"].difference(this._getDraggablePosition(), this._getOffsetCorrection());\n  };\n\n  Draggable.prototype._getDraggablePosition = function _getDraggablePosition() {\n    var elRect = this.element.getBoundingClientRect();\n    return new _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_3__[\"Coordinate\"](elRect.left, elRect.top);\n  };\n\n  /**\n   * Because the draggable element gets moved around and repositioned,\n   * the bounding client rect method and the offset left and top properties\n   * are unreliable once the element has been dragged once. This method uses\n   * the bounding client rect of the parent element to get a \"correction\"\n   * value.\n   * @return {!Coordinate}\n   * @private\n   */\n\n\n  Draggable.prototype._getOffsetCorrection = function _getOffsetCorrection() {\n    // getBoundingClientRect does not include margins. They must be accounted for.\n    var containmentRect = this._parentEl.getBoundingClientRect();\n    var paddings = Object(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_3__[\"getPaddingBox\"])(this._parentEl);\n    var margins = Object(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_3__[\"getMarginBox\"])(this.element);\n    var offsetCorrectionX = margins.left + paddings.left + containmentRect.left;\n    var offsetCorrectionY = margins.top + paddings.top + containmentRect.top;\n    return new _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_3__[\"Coordinate\"](offsetCorrectionX, offsetCorrectionY);\n  };\n\n  /**\n   * Sets the current position coordinate to a new coordinate.\n   * @param {Coordinate} position Where the x and y values are a percentage.\n   *     e.g. 50 for \"50%\".\n   */\n\n\n  Draggable.prototype._setCurrentPosition = function _setCurrentPosition(position) {\n    this.pointer.applyFriction(position);\n    var x = this._limitX(position.x / 100 * this._parentEl.offsetWidth);\n    var y = this._limitY(position.y / 100 * this._parentEl.offsetHeight);\n    this._currentPosition = this._getAxisCoordinate(Math.round(x), Math.round(y));\n  };\n\n  /**\n   * Clamp the x or y value.\n   * @param {number} value X or Y value.\n   * @param {number} rectPosition The limits starting edge. (left or top).\n   * @param {number} rectSize The limits dimension. (width or height).\n   * @return {number} The clamped number.\n   */\n\n\n  Draggable._limitValue = function _limitValue(value, rectPosition, rectSize) {\n    var side = Object(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_3__[\"defaultsTo\"])(rectPosition, null, !Number.isNaN(rectPosition));\n    var dimension = Object(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_3__[\"defaultsTo\"])(rectSize, 0, !Number.isNaN(rectSize));\n    var max = Object(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_3__[\"defaultsTo\"])(side + dimension, Infinity, side !== null);\n    var min = Object(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_3__[\"defaultsTo\"])(side, -Infinity, side !== null);\n    return Object(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_3__[\"clamp\"])(value, min, max);\n  };\n\n  /**\n   * Returns the 'real' x after limits are applied (allows for some\n   * limits to be undefined).\n   * @param {number} x X-coordinate to limit.\n   * @return {number} The 'real' X-coordinate after limits are applied.\n   */\n\n\n  Draggable.prototype._limitX = function _limitX(x) {\n    return Draggable._limitValue(x, this.limits.left, this.limits.width);\n  };\n\n  /**\n   * Returns the 'real' y after limits are applied (allows for some\n   * limits to be undefined).\n   * @param {number} y Y-coordinate to limit.\n   * @return {number} The 'real' Y-coordinate after limits are applied.\n   */\n\n\n  Draggable.prototype._limitY = function _limitY(y) {\n    return Draggable._limitValue(y, this.limits.top, this.limits.height);\n  };\n\n  /**\n   * Returns the x and y positions the draggable element should be set to.\n   * @param {Coordinate=} optPosition Position to set the draggable\n   *     element. This will optionally override calculating the position\n   *     from a drag.\n   * @return {!Coordinate} The x and y coordinates.\n   * @private\n   */\n\n\n  Draggable.prototype._getElementPosition = function _getElementPosition(optPosition) {\n    if (optPosition) {\n      this._setCurrentPosition(optPosition);\n    }\n\n    var newX = this._currentPosition.x / this._container.width * 100;\n    var newY = this._currentPosition.y / this._container.height * 100;\n\n    return this._getAxisCoordinate(newX, newY);\n  };\n\n  /**\n   * Ensures the y value of an x axis draggable is zero and visa versa.\n   * @param {number} newX New position for the x value.\n   * @param {number} newY New position for the y value.\n   * @return {!Coordinate}\n   * @private\n   */\n\n\n  Draggable.prototype._getAxisCoordinate = function _getAxisCoordinate(newX, newY) {\n    // Drag horizontal only.\n    if (this.pointer.isXAxis()) {\n      return new _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_3__[\"Coordinate\"](newX, 0);\n    }\n\n    // Drag vertical only.\n    if (this.pointer.isYAxis()) {\n      return new _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_3__[\"Coordinate\"](0, newY);\n    }\n\n    // Drag both directions.\n    return new _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_3__[\"Coordinate\"](newX, newY);\n  };\n\n  /**\n   * Returns a new coordinate with limits applied to it.\n   * @param {Coordinate} deltaFromStart The distance moved since the drag started.\n   * @return {!Coordinate}\n   * @private\n   */\n\n\n  Draggable.prototype._getNewLimitedPosition = function _getNewLimitedPosition(deltaFromStart) {\n    var sum = _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_3__[\"Coordinate\"].sum(this._relativeZero, deltaFromStart);\n    return new _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_3__[\"Coordinate\"](this._limitX(sum.x), this._limitY(sum.y));\n  };\n\n  /**\n   * Drag start handler.\n   * @private\n   */\n\n\n  Draggable.prototype._handleDragStart = function _handleDragStart(evt) {\n    this._stopThrow();\n    this._saveDimensions();\n    this._currentPosition = this._relativeZero;\n    this._emitEvent(this._createEvent(Draggable.EventType.START, evt));\n    this.element.classList.add(Draggable.Classes.GRABBING);\n  };\n\n  /**\n   * Drag move, after _applyPosition has happened\n   * @param {PointerEvent} evt The dragger event.\n   * @private\n   */\n\n\n  Draggable.prototype._handleDragMove = function _handleDragMove(evt) {\n    // Calculate the new position based on limits and the starting point.\n    this._currentPosition = this._getNewLimitedPosition(this.pointer.delta);\n\n    this._emitEvent(this._createEvent(Draggable.EventType.MOVE, evt));\n\n    if (!this.pointer._isDeactivated) {\n      this._applyPosition();\n    }\n  };\n\n  /**\n   * Dragging ended.\n   * @private\n   */\n\n\n  Draggable.prototype._handleDragEnd = function _handleDragEnd(evt) {\n    this._emitEvent(this._createEvent(Draggable.EventType.END, evt));\n    this.element.classList.remove(Draggable.Classes.GRABBING);\n\n    if (this.options.isThrowable && this.pointer.hasVelocity(evt.currentVelocity, 0)) {\n      this._throw(evt.currentVelocity, evt.delta);\n    }\n  };\n\n  /**\n   * Start a throw based on the draggable's velocity.\n   * @param {Coordinate} velocity Velocity.\n   * @param {Coordinate} delta Total drag distance from start to end.\n   * @private\n   */\n\n\n  Draggable.prototype._throw = function _throw(velocity, delta) {\n    this._delta = delta;\n    this._throwVelocity = _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_3__[\"Coordinate\"].scale(velocity, this.options.amplifier);\n    this._animateThrow();\n  };\n\n  /**\n   * Scale down the velocity, update the position, and apply it. Then do it again\n   * until it's below a threshold.\n   * @private\n   */\n\n\n  Draggable.prototype._animateThrow = function _animateThrow() {\n    if (this.pointer.hasVelocity(this._throwVelocity, this.options.velocityStop)) {\n      this._currentPosition = this._getNewLimitedPosition(this._delta);\n      this._applyPosition();\n\n      this._delta.translate(this._throwVelocity);\n      this._throwVelocity.scale(this.options.throwFriction);\n\n      // Again!\n      this._requestId = requestAnimationFrame(this._animateThrow.bind(this));\n    } else {\n      // Settle on the pixel grid.\n      this._currentPosition.x = Math.round(this._currentPosition.x);\n      this._currentPosition.y = Math.round(this._currentPosition.y);\n      this._applyPosition();\n      this._emitSettled();\n    }\n  };\n\n  /**\n   * Interrupt a throw.\n   * @private\n   */\n\n\n  Draggable.prototype._stopThrow = function _stopThrow() {\n    this._delta = new _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_3__[\"Coordinate\"]();\n    this._throwVelocity = new _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_3__[\"Coordinate\"]();\n    cancelAnimationFrame(this._requestId);\n  };\n\n  /**\n   * Dispatches the SETTLE event with data. This data is different from the start,\n   * move, and end events which use data from the pointer.\n   * @private\n   */\n\n\n  Draggable.prototype._emitSettled = function _emitSettled() {\n    this._emitEvent(new _odopod_odo_pointer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Event({\n      type: Draggable.EventType.SETTLE,\n      target: this.element,\n      axis: this.pointer.options.axis,\n      deltaTime: Date.now() - this.pointer.startTime,\n      delta: _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_3__[\"Coordinate\"].difference(this._relativeZero, this._currentPosition),\n      start: this._relativeZero,\n      end: this._currentPosition,\n      currentVelocity: this._throwVelocity,\n      position: {\n        pixel: this.getPosition(),\n        percent: this.getPosition(true)\n      }\n    }));\n  };\n\n  /**\n   * Make a new event with data.\n   * @param {Draggable.EventType} type Event type.\n   * @param {Event} evt Native event object.\n   * @return {!OdoPointer.Event}\n   * @private\n   */\n\n\n  Draggable.prototype._createEvent = function _createEvent(type, evt) {\n    return new _odopod_odo_pointer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Event({\n      type: type,\n      target: evt.target,\n      currentTarget: this.element,\n      axis: this.pointer.options.axis,\n      deltaTime: this.pointer.deltaTime,\n      delta: _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_3__[\"Coordinate\"].difference(this._currentPosition, this._relativeZero),\n      start: this._relativeZero,\n      end: this._currentPosition,\n      currentVelocity: this.pointer.velocity,\n      position: {\n        pixel: this.getPosition(),\n        percent: this.getPosition(true)\n      }\n    });\n  };\n\n  /**\n   * Sets the position of thd draggable element.\n   * @param {Coordinate} [position] Position to set the draggable element. This\n   *     will optionally override calculating the position from a drag.\n   * @return {Coordinate} The position the draggable element was set to.\n   */\n\n\n  Draggable.prototype._applyPosition = function _applyPosition(position) {\n    var pos = this._getElementPosition(position);\n    this.element.style[_odopod_odo_device__WEBPACK_IMPORTED_MODULE_2__[\"default\"].Dom.TRANSFORM] = 'translate(' + pos.x + '%,' + pos.y + '%)';\n    return this._currentPosition;\n  };\n\n  /**\n   * Returns the current position of the draggable element.\n   * @param {boolean} [asPercent] Optionally retrieve percentage values instead\n   *     of pixel values.\n   * @return {Coordinate} X and Y coordinates of the draggable element.\n   */\n\n\n  Draggable.prototype.getPosition = function getPosition(asPercent) {\n    if (asPercent) {\n      return new _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_3__[\"Coordinate\"](this._currentPosition.x / this._parentEl.offsetWidth * 100, this._currentPosition.y / this._parentEl.offsetHeight * 100);\n    }\n    return this._currentPosition;\n  };\n\n  /**\n   * Set the position of the draggable element.\n   * @param {number} x X position as a percentage. Eg. 50 for \"50%\".\n   * @param {number} y Y position as a percentage. Eg. 50 for \"50%\".\n   * @return {Coordinate} The position the draggable element was set to.\n   */\n\n\n  Draggable.prototype.setPosition = function setPosition(x, y) {\n    // setPosition can be called before any dragging, this would cause\n    // the containment width and containment height to be undefined.\n    this.update();\n    return this._applyPosition(new _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_3__[\"Coordinate\"](x, y));\n  };\n\n  /**\n   * Sets (or reset) the Drag limits after a Dragger is created.\n   * @param {Rect} limits Object containing left, top, width,\n   *     height for new Dragger limits.\n   */\n\n\n  Draggable.prototype.setLimits = function setLimits(limits) {\n    this.limits = limits;\n  };\n\n  /**\n   * Easy way to trigger setting dimensions. Useful for doing things after this\n   * class has been initialized, but no dragging has occurred yet.\n   */\n  Draggable.prototype.update = function update() {\n    this._saveDimensions();\n  };\n\n  /**\n   * Remove event listeners and element references.\n   * @private\n   */\n\n\n  Draggable.prototype.dispose = function dispose() {\n    this.pointer.off(_odopod_odo_pointer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].EventType.START, this._onStart);\n    this.pointer.off(_odopod_odo_pointer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].EventType.MOVE, this._onMove);\n    this.pointer.off(_odopod_odo_pointer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].EventType.END, this._onEnd);\n\n    this.pointer.dispose();\n\n    this.element.classList.remove(Draggable.Classes.GRABBABLE);\n\n    this._parentEl = null;\n    this.element = null;\n  };\n\n  /**\n   * Emits a event on this instance.\n   * @param {PointerEvent} event Event object with data.\n   * @return {boolean} Whether preventDefault was called on the event.\n   */\n\n\n  Draggable.prototype._emitEvent = function _emitEvent(event) {\n    this.emit(event.type, event);\n    return event.defaultPrevented;\n  };\n\n  createClass(Draggable, [{\n    key: 'friction',\n    get: function get$$1() {\n      return this.pointer.friction;\n    }\n\n    /**\n     * Set the friction value.\n     * @param {number} friction A number between [1, 0].\n     */\n    ,\n    set: function set$$1(friction) {\n      this.pointer.friction = friction;\n    }\n\n    /**\n     * Get whether dragger is enabled.\n     * @return {boolean} Whether dragger is enabled.\n     */\n\n  }, {\n    key: 'isEnabled',\n    get: function get$$1() {\n      return this.pointer.isEnabled;\n    }\n\n    /**\n     * Set whether dragger is enabled.\n     * @param {boolean} enabled Whether dragger is enabled.\n     */\n    ,\n    set: function set$$1(enabled) {\n      this.pointer.isEnabled = enabled;\n      this.element.classList.toggle(settings.Classes.GRABBABLE, enabled);\n    }\n  }]);\n  return Draggable;\n}(tiny_emitter__WEBPACK_IMPORTED_MODULE_1___default.a);\n\nObject.assign(Draggable, settings);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Draggable);\n//# sourceMappingURL=odo-draggable.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG9kb3BvZC9vZG8tZHJhZ2dhYmxlL2Rpc3Qvb2RvLWRyYWdnYWJsZS5lc20uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG9kb3BvZC9vZG8tZHJhZ2dhYmxlL2Rpc3Qvb2RvLWRyYWdnYWJsZS5lc20uanM/OGVkYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgT2RvUG9pbnRlciBmcm9tICdAb2RvcG9kL29kby1wb2ludGVyJztcbmltcG9ydCBUaW55RW1pdHRlciBmcm9tICd0aW55LWVtaXR0ZXInO1xuaW1wb3J0IE9kb0RldmljZSBmcm9tICdAb2RvcG9kL29kby1kZXZpY2UnO1xuaW1wb3J0IHsgY2xhbXAsIENvb3JkaW5hdGUsIGRlZmF1bHRzVG8sIGdldE1hcmdpbkJveCwgZ2V0UGFkZGluZ0JveCwgZ2V0U2l6ZSwgUmVjdCB9IGZyb20gJ0BvZG9wb2Qvb2RvLWhlbHBlcnMnO1xuXG52YXIgc2V0dGluZ3MgPSB7XG4gIC8qKiBAZW51bSB7c3RyaW5nfSAqL1xuICBFdmVudFR5cGU6IHtcbiAgICBTVEFSVDogJ29kb2RyYWdnYWJsZTpzdGFydCcsXG4gICAgTU9WRTogJ29kb2RyYWdnYWJsZTptb3ZlJyxcbiAgICBFTkQ6ICdvZG9kcmFnZ2FibGU6ZW5kJyxcbiAgICBTRVRUTEU6ICdvZG9kcmFnZ2FibGU6dGhyb3dzZXR0bGUnXG4gIH0sXG5cbiAgQ2xhc3Nlczoge1xuICAgIEdSQUJCQUJMRTogJ2dyYWJiYWJsZScsXG4gICAgR1JBQkJJTkc6ICdncmFiYmluZydcbiAgfSxcblxuICBEZWZhdWx0czoge1xuICAgIC8vIERyYWdnYWJsZSBheGlzLlxuICAgIGF4aXM6IE9kb1BvaW50ZXIuQXhpcy5YLFxuXG4gICAgLy8gQW1wbGlmaWVzIHRocm93IHZlbG9jaXR5IGJ5IHRoaXMgdmFsdWUuIEhpZ2hlciB2YWx1ZXMgbWFrZSB0aGUgdGhyb3dhYmxlXG4gICAgLy8gdHJhdmVsIGZhcnRoZXIgYW5kIGZhc3Rlci5cbiAgICBhbXBsaWZpZXI6IDI0LFxuXG4gICAgLy8gT25jZSB0aGUgdmVsb2NpdHkgaGFzIGdvbmUgYmVsb3cgdGhpcyB0aHJlc2hvbGQsIHRocm93aW5nIHN0b3BzLlxuICAgIHZlbG9jaXR5U3RvcDogMC4wOCxcblxuICAgIC8vIE9uIGVhY2ggdGhyb3cgZnJhbWUsIHRoZSB2ZWxvY2l0eSBpcyBtdWx0aXBsaWVkIGJ5IHRoaXMgZnJpY3Rpb24gdmFsdWUuXG4gICAgLy8gSXQgbXVzdCBiZSBsZXNzIHRoYW4gMS4gSGlnaGVyIHZhbHVlcyBsZXQgdGhlIHRocm93YWJsZSBzbGlkZSBmYXJ0aGVyIGFuZCBsb25nZXIuXG4gICAgdGhyb3dGcmljdGlvbjogMC45NCxcblxuICAgIC8vIFdoZXRoZXIgdGhlIGRyYWdnYWJsZSB3aWxsIGtlZXAgaXRzIG1vdmVtZW50IG1vbWVudHVtIGFmdGVyIHRoZSB1c2VyIHJlbGVhc2VzLlxuICAgIGlzVGhyb3dhYmxlOiBmYWxzZVxuICB9XG59O1xuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG52YXIgaW5oZXJpdHMgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59O1xuXG52YXIgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiA9IGZ1bmN0aW9uIChzZWxmLCBjYWxsKSB7XG4gIGlmICghc2VsZikge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmO1xufTtcblxuLyoqXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgYGNvbmRpdGlvbmAgaXMgZmFsc3kuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbmRpdGlvbiBUaGUgY29uZGl0aW9uIHRvIHRlc3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBFcnJvciBtZXNzYWdlLlxuICogQHRocm93cyB7RXJyb3J9IElmIGNvbmRpdGlvbiBpcyBmYWxzeS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhlIGNvbnRhaW5pbmcgZWxlbWVudCBoYXMgYSB3aWR0aCBhbmQgaGVpZ2h0LlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBPYmplY3QgdG8gdGVzdC5cbiAqL1xuZnVuY3Rpb24gZW5zdXJlT2JqZWN0SGFzU2l6ZShvYmopIHtcbiAgYXNzZXJ0KG9iai53aWR0aCA+IDAsICdjb250YWluaW5nIGVsZW1lbnRcXCdzIHdpZHRoIGlzIHplcm8nKTtcbiAgYXNzZXJ0KG9iai5oZWlnaHQgPiAwLCAnY29udGFpbmluZyBlbGVtZW50XFwncyBoZWlnaHQgaXMgemVybycpO1xufVxuXG52YXIgRHJhZ2dhYmxlID0gZnVuY3Rpb24gKF9UaW55RW1pdHRlcikge1xuICBpbmhlcml0cyhEcmFnZ2FibGUsIF9UaW55RW1pdHRlcik7XG5cbiAgZnVuY3Rpb24gRHJhZ2dhYmxlKGVsZW1lbnQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgRHJhZ2dhYmxlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkcmFnZ2FibGUgZWxlbWVudC5cbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UaW55RW1pdHRlci5jYWxsKHRoaXMpKTtcblxuICAgIF90aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgYW55IGRlZmF1bHRzIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICBfdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgRHJhZ2dhYmxlLkRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBlbGVtZW50IHdoaWNoIGNvbnRhaW5zIHRoZSB0YXJnZXQuXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RoaXMuX3BhcmVudEVsID0gZWxlbWVudC5wYXJlbnROb2RlO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBwb3NpdGlvbiBvZiB0aGUgaGFuZGxlL3RhcmdldC5cbiAgICAgKiBAdHlwZSB7Q29vcmRpbmF0ZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF90aGlzLl9jdXJyZW50UG9zaXRpb24gPSBuZXcgQ29vcmRpbmF0ZSgpO1xuXG4gICAgLyoqXG4gICAgICogU3RhcnRpbmcgbG9jYXRpb24gb2YgdGhlIGRyYWcuXG4gICAgICogQHR5cGUge0Nvb3JkaW5hdGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdGhpcy5fcmVsYXRpdmVaZXJvID0gbmV3IENvb3JkaW5hdGUoKTtcblxuICAgIC8qKlxuICAgICAqIFZlbG9jaXR5IGF0IHdoaWNoIHRoZSBkcmFnZ2FibGUgd2FzIHRocm93bi4gVGhpcyB2YWx1ZSBkZWNheXMgb3ZlciB0aW1lXG4gICAgICogYWZ0ZXIgYSB0aHJvdy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtDb29yZGluYXRlfVxuICAgICAqL1xuICAgIF90aGlzLl90aHJvd1ZlbG9jaXR5ID0gbmV3IENvb3JkaW5hdGUoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjaGFuZ2UgaW4gcG9zaXRpb24gZnJvbSB0aGUgc3RhcnQgb2YgdGhlIGRyYWcuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Q29vcmRpbmF0ZX1cbiAgICAgKi9cbiAgICBfdGhpcy5fZGVsdGEgPSBuZXcgQ29vcmRpbmF0ZSgpO1xuXG4gICAgLyoqXG4gICAgICogQW5pbWF0aW9uIGZyYW1lIGlkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBfdGhpcy5fcmVxdWVzdElkID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzaXplIG9mIHRoZSBjb250YWluaW5nIGVsZW1lbnQuIFRoaXMgZWxlbWVudCBpcyB1c2VkIHRvIGRldGVybWluZVxuICAgICAqIHRoZSBwZXJjZW50YWdlIHBvc2l0aW9uIG9mIHRoZSBkcmFnZ2FibGUgZWxlbWVudC5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIF90aGlzLl9jb250YWluZXIgPSB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcblxuICAgIC8qKlxuICAgICAqIExpbWl0cyBvZiBob3cgZmFyIHRoZSBkcmFnZ2FibGUgZWxlbWVudCBjYW4gYmUgZHJhZ2dlZC5cbiAgICAgKiBAdHlwZSB7UmVjdH1cbiAgICAgKi9cbiAgICBfdGhpcy5saW1pdHMgPSBuZXcgUmVjdChOYU4sIE5hTiwgTmFOLCBOYU4pO1xuXG4gICAgX3RoaXMucG9pbnRlciA9IG5ldyBPZG9Qb2ludGVyKGVsZW1lbnQsIHtcbiAgICAgIGF4aXM6IF90aGlzLm9wdGlvbnMuYXhpc1xuICAgIH0pO1xuXG4gICAgX3RoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKERyYWdnYWJsZS5DbGFzc2VzLkdSQUJCQUJMRSk7XG5cbiAgICAvLyBLaWNrIG9mZi5cbiAgICBfdGhpcy5fbGlzdGVuKCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgRHJhZ2dhYmxlLnByb3RvdHlwZS5fbGlzdGVuID0gZnVuY3Rpb24gX2xpc3RlbigpIHtcbiAgICB0aGlzLl9vblN0YXJ0ID0gdGhpcy5faGFuZGxlRHJhZ1N0YXJ0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25Nb3ZlID0gdGhpcy5faGFuZGxlRHJhZ01vdmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkVuZCA9IHRoaXMuX2hhbmRsZURyYWdFbmQuYmluZCh0aGlzKTtcblxuICAgIHRoaXMucG9pbnRlci5vbihPZG9Qb2ludGVyLkV2ZW50VHlwZS5TVEFSVCwgdGhpcy5fb25TdGFydCk7XG4gICAgdGhpcy5wb2ludGVyLm9uKE9kb1BvaW50ZXIuRXZlbnRUeXBlLk1PVkUsIHRoaXMuX29uTW92ZSk7XG4gICAgdGhpcy5wb2ludGVyLm9uKE9kb1BvaW50ZXIuRXZlbnRUeXBlLkVORCwgdGhpcy5fb25FbmQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTYXZlcyB0aGUgY29udGFpbm1lbnQgZWxlbWVudCdzIHdpZHRoIGFuZCBoZWlnaHQgYW5kIHNjcnViYmVyIHBvc2l0aW9uLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIERyYWdnYWJsZS5wcm90b3R5cGUuX3NhdmVEaW1lbnNpb25zID0gZnVuY3Rpb24gX3NhdmVEaW1lbnNpb25zKCkge1xuICAgIHRoaXMuX2NvbnRhaW5lciA9IGdldFNpemUodGhpcy5lbGVtZW50KTtcbiAgICBlbnN1cmVPYmplY3RIYXNTaXplKHRoaXMuX2NvbnRhaW5lcik7XG4gICAgdGhpcy5fcmVsYXRpdmVaZXJvID0gdGhpcy5fZ2V0UmVsYXRpdmVaZXJvKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgcmVzdCBvZiB0aGUgcGFnZS4gV2hlbiBpdCdzIGZpcnN0XG4gICAqIGluaXRpYWxpemVkLCBpdCBpcyB6ZXJvIHplcm8sIGJ1dCBhZnRlciBkcmFnZ2luZywgaXQgaXMgdGhlIHBvc2l0aW9uXG4gICAqIHJlbGF0aXZlIHRvIHplcm8gemVyby5cbiAgICogQHJldHVybiB7IUNvb3JkaW5hdGV9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgRHJhZ2dhYmxlLnByb3RvdHlwZS5fZ2V0UmVsYXRpdmVaZXJvID0gZnVuY3Rpb24gX2dldFJlbGF0aXZlWmVybygpIHtcbiAgICByZXR1cm4gQ29vcmRpbmF0ZS5kaWZmZXJlbmNlKHRoaXMuX2dldERyYWdnYWJsZVBvc2l0aW9uKCksIHRoaXMuX2dldE9mZnNldENvcnJlY3Rpb24oKSk7XG4gIH07XG5cbiAgRHJhZ2dhYmxlLnByb3RvdHlwZS5fZ2V0RHJhZ2dhYmxlUG9zaXRpb24gPSBmdW5jdGlvbiBfZ2V0RHJhZ2dhYmxlUG9zaXRpb24oKSB7XG4gICAgdmFyIGVsUmVjdCA9IHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4gbmV3IENvb3JkaW5hdGUoZWxSZWN0LmxlZnQsIGVsUmVjdC50b3ApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBCZWNhdXNlIHRoZSBkcmFnZ2FibGUgZWxlbWVudCBnZXRzIG1vdmVkIGFyb3VuZCBhbmQgcmVwb3NpdGlvbmVkLFxuICAgKiB0aGUgYm91bmRpbmcgY2xpZW50IHJlY3QgbWV0aG9kIGFuZCB0aGUgb2Zmc2V0IGxlZnQgYW5kIHRvcCBwcm9wZXJ0aWVzXG4gICAqIGFyZSB1bnJlbGlhYmxlIG9uY2UgdGhlIGVsZW1lbnQgaGFzIGJlZW4gZHJhZ2dlZCBvbmNlLiBUaGlzIG1ldGhvZCB1c2VzXG4gICAqIHRoZSBib3VuZGluZyBjbGllbnQgcmVjdCBvZiB0aGUgcGFyZW50IGVsZW1lbnQgdG8gZ2V0IGEgXCJjb3JyZWN0aW9uXCJcbiAgICogdmFsdWUuXG4gICAqIEByZXR1cm4geyFDb29yZGluYXRlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIERyYWdnYWJsZS5wcm90b3R5cGUuX2dldE9mZnNldENvcnJlY3Rpb24gPSBmdW5jdGlvbiBfZ2V0T2Zmc2V0Q29ycmVjdGlvbigpIHtcbiAgICAvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZG9lcyBub3QgaW5jbHVkZSBtYXJnaW5zLiBUaGV5IG11c3QgYmUgYWNjb3VudGVkIGZvci5cbiAgICB2YXIgY29udGFpbm1lbnRSZWN0ID0gdGhpcy5fcGFyZW50RWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIHBhZGRpbmdzID0gZ2V0UGFkZGluZ0JveCh0aGlzLl9wYXJlbnRFbCk7XG4gICAgdmFyIG1hcmdpbnMgPSBnZXRNYXJnaW5Cb3godGhpcy5lbGVtZW50KTtcbiAgICB2YXIgb2Zmc2V0Q29ycmVjdGlvblggPSBtYXJnaW5zLmxlZnQgKyBwYWRkaW5ncy5sZWZ0ICsgY29udGFpbm1lbnRSZWN0LmxlZnQ7XG4gICAgdmFyIG9mZnNldENvcnJlY3Rpb25ZID0gbWFyZ2lucy50b3AgKyBwYWRkaW5ncy50b3AgKyBjb250YWlubWVudFJlY3QudG9wO1xuICAgIHJldHVybiBuZXcgQ29vcmRpbmF0ZShvZmZzZXRDb3JyZWN0aW9uWCwgb2Zmc2V0Q29ycmVjdGlvblkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjdXJyZW50IHBvc2l0aW9uIGNvb3JkaW5hdGUgdG8gYSBuZXcgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtDb29yZGluYXRlfSBwb3NpdGlvbiBXaGVyZSB0aGUgeCBhbmQgeSB2YWx1ZXMgYXJlIGEgcGVyY2VudGFnZS5cbiAgICogICAgIGUuZy4gNTAgZm9yIFwiNTAlXCIuXG4gICAqL1xuXG5cbiAgRHJhZ2dhYmxlLnByb3RvdHlwZS5fc2V0Q3VycmVudFBvc2l0aW9uID0gZnVuY3Rpb24gX3NldEN1cnJlbnRQb3NpdGlvbihwb3NpdGlvbikge1xuICAgIHRoaXMucG9pbnRlci5hcHBseUZyaWN0aW9uKHBvc2l0aW9uKTtcbiAgICB2YXIgeCA9IHRoaXMuX2xpbWl0WChwb3NpdGlvbi54IC8gMTAwICogdGhpcy5fcGFyZW50RWwub2Zmc2V0V2lkdGgpO1xuICAgIHZhciB5ID0gdGhpcy5fbGltaXRZKHBvc2l0aW9uLnkgLyAxMDAgKiB0aGlzLl9wYXJlbnRFbC5vZmZzZXRIZWlnaHQpO1xuICAgIHRoaXMuX2N1cnJlbnRQb3NpdGlvbiA9IHRoaXMuX2dldEF4aXNDb29yZGluYXRlKE1hdGgucm91bmQoeCksIE1hdGgucm91bmQoeSkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGFtcCB0aGUgeCBvciB5IHZhbHVlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgWCBvciBZIHZhbHVlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmVjdFBvc2l0aW9uIFRoZSBsaW1pdHMgc3RhcnRpbmcgZWRnZS4gKGxlZnQgb3IgdG9wKS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJlY3RTaXplIFRoZSBsaW1pdHMgZGltZW5zaW9uLiAod2lkdGggb3IgaGVpZ2h0KS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgY2xhbXBlZCBudW1iZXIuXG4gICAqL1xuXG5cbiAgRHJhZ2dhYmxlLl9saW1pdFZhbHVlID0gZnVuY3Rpb24gX2xpbWl0VmFsdWUodmFsdWUsIHJlY3RQb3NpdGlvbiwgcmVjdFNpemUpIHtcbiAgICB2YXIgc2lkZSA9IGRlZmF1bHRzVG8ocmVjdFBvc2l0aW9uLCBudWxsLCAhTnVtYmVyLmlzTmFOKHJlY3RQb3NpdGlvbikpO1xuICAgIHZhciBkaW1lbnNpb24gPSBkZWZhdWx0c1RvKHJlY3RTaXplLCAwLCAhTnVtYmVyLmlzTmFOKHJlY3RTaXplKSk7XG4gICAgdmFyIG1heCA9IGRlZmF1bHRzVG8oc2lkZSArIGRpbWVuc2lvbiwgSW5maW5pdHksIHNpZGUgIT09IG51bGwpO1xuICAgIHZhciBtaW4gPSBkZWZhdWx0c1RvKHNpZGUsIC1JbmZpbml0eSwgc2lkZSAhPT0gbnVsbCk7XG4gICAgcmV0dXJuIGNsYW1wKHZhbHVlLCBtaW4sIG1heCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlICdyZWFsJyB4IGFmdGVyIGxpbWl0cyBhcmUgYXBwbGllZCAoYWxsb3dzIGZvciBzb21lXG4gICAqIGxpbWl0cyB0byBiZSB1bmRlZmluZWQpLlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBYLWNvb3JkaW5hdGUgdG8gbGltaXQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlICdyZWFsJyBYLWNvb3JkaW5hdGUgYWZ0ZXIgbGltaXRzIGFyZSBhcHBsaWVkLlxuICAgKi9cblxuXG4gIERyYWdnYWJsZS5wcm90b3R5cGUuX2xpbWl0WCA9IGZ1bmN0aW9uIF9saW1pdFgoeCkge1xuICAgIHJldHVybiBEcmFnZ2FibGUuX2xpbWl0VmFsdWUoeCwgdGhpcy5saW1pdHMubGVmdCwgdGhpcy5saW1pdHMud2lkdGgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSAncmVhbCcgeSBhZnRlciBsaW1pdHMgYXJlIGFwcGxpZWQgKGFsbG93cyBmb3Igc29tZVxuICAgKiBsaW1pdHMgdG8gYmUgdW5kZWZpbmVkKS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgWS1jb29yZGluYXRlIHRvIGxpbWl0LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSAncmVhbCcgWS1jb29yZGluYXRlIGFmdGVyIGxpbWl0cyBhcmUgYXBwbGllZC5cbiAgICovXG5cblxuICBEcmFnZ2FibGUucHJvdG90eXBlLl9saW1pdFkgPSBmdW5jdGlvbiBfbGltaXRZKHkpIHtcbiAgICByZXR1cm4gRHJhZ2dhYmxlLl9saW1pdFZhbHVlKHksIHRoaXMubGltaXRzLnRvcCwgdGhpcy5saW1pdHMuaGVpZ2h0KTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgeCBhbmQgeSBwb3NpdGlvbnMgdGhlIGRyYWdnYWJsZSBlbGVtZW50IHNob3VsZCBiZSBzZXQgdG8uXG4gICAqIEBwYXJhbSB7Q29vcmRpbmF0ZT19IG9wdFBvc2l0aW9uIFBvc2l0aW9uIHRvIHNldCB0aGUgZHJhZ2dhYmxlXG4gICAqICAgICBlbGVtZW50LiBUaGlzIHdpbGwgb3B0aW9uYWxseSBvdmVycmlkZSBjYWxjdWxhdGluZyB0aGUgcG9zaXRpb25cbiAgICogICAgIGZyb20gYSBkcmFnLlxuICAgKiBAcmV0dXJuIHshQ29vcmRpbmF0ZX0gVGhlIHggYW5kIHkgY29vcmRpbmF0ZXMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgRHJhZ2dhYmxlLnByb3RvdHlwZS5fZ2V0RWxlbWVudFBvc2l0aW9uID0gZnVuY3Rpb24gX2dldEVsZW1lbnRQb3NpdGlvbihvcHRQb3NpdGlvbikge1xuICAgIGlmIChvcHRQb3NpdGlvbikge1xuICAgICAgdGhpcy5fc2V0Q3VycmVudFBvc2l0aW9uKG9wdFBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICB2YXIgbmV3WCA9IHRoaXMuX2N1cnJlbnRQb3NpdGlvbi54IC8gdGhpcy5fY29udGFpbmVyLndpZHRoICogMTAwO1xuICAgIHZhciBuZXdZID0gdGhpcy5fY3VycmVudFBvc2l0aW9uLnkgLyB0aGlzLl9jb250YWluZXIuaGVpZ2h0ICogMTAwO1xuXG4gICAgcmV0dXJuIHRoaXMuX2dldEF4aXNDb29yZGluYXRlKG5ld1gsIG5ld1kpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbnN1cmVzIHRoZSB5IHZhbHVlIG9mIGFuIHggYXhpcyBkcmFnZ2FibGUgaXMgemVybyBhbmQgdmlzYSB2ZXJzYS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG5ld1ggTmV3IHBvc2l0aW9uIGZvciB0aGUgeCB2YWx1ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG5ld1kgTmV3IHBvc2l0aW9uIGZvciB0aGUgeSB2YWx1ZS5cbiAgICogQHJldHVybiB7IUNvb3JkaW5hdGV9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgRHJhZ2dhYmxlLnByb3RvdHlwZS5fZ2V0QXhpc0Nvb3JkaW5hdGUgPSBmdW5jdGlvbiBfZ2V0QXhpc0Nvb3JkaW5hdGUobmV3WCwgbmV3WSkge1xuICAgIC8vIERyYWcgaG9yaXpvbnRhbCBvbmx5LlxuICAgIGlmICh0aGlzLnBvaW50ZXIuaXNYQXhpcygpKSB7XG4gICAgICByZXR1cm4gbmV3IENvb3JkaW5hdGUobmV3WCwgMCk7XG4gICAgfVxuXG4gICAgLy8gRHJhZyB2ZXJ0aWNhbCBvbmx5LlxuICAgIGlmICh0aGlzLnBvaW50ZXIuaXNZQXhpcygpKSB7XG4gICAgICByZXR1cm4gbmV3IENvb3JkaW5hdGUoMCwgbmV3WSk7XG4gICAgfVxuXG4gICAgLy8gRHJhZyBib3RoIGRpcmVjdGlvbnMuXG4gICAgcmV0dXJuIG5ldyBDb29yZGluYXRlKG5ld1gsIG5ld1kpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IGNvb3JkaW5hdGUgd2l0aCBsaW1pdHMgYXBwbGllZCB0byBpdC5cbiAgICogQHBhcmFtIHtDb29yZGluYXRlfSBkZWx0YUZyb21TdGFydCBUaGUgZGlzdGFuY2UgbW92ZWQgc2luY2UgdGhlIGRyYWcgc3RhcnRlZC5cbiAgICogQHJldHVybiB7IUNvb3JkaW5hdGV9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgRHJhZ2dhYmxlLnByb3RvdHlwZS5fZ2V0TmV3TGltaXRlZFBvc2l0aW9uID0gZnVuY3Rpb24gX2dldE5ld0xpbWl0ZWRQb3NpdGlvbihkZWx0YUZyb21TdGFydCkge1xuICAgIHZhciBzdW0gPSBDb29yZGluYXRlLnN1bSh0aGlzLl9yZWxhdGl2ZVplcm8sIGRlbHRhRnJvbVN0YXJ0KTtcbiAgICByZXR1cm4gbmV3IENvb3JkaW5hdGUodGhpcy5fbGltaXRYKHN1bS54KSwgdGhpcy5fbGltaXRZKHN1bS55KSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERyYWcgc3RhcnQgaGFuZGxlci5cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBEcmFnZ2FibGUucHJvdG90eXBlLl9oYW5kbGVEcmFnU3RhcnQgPSBmdW5jdGlvbiBfaGFuZGxlRHJhZ1N0YXJ0KGV2dCkge1xuICAgIHRoaXMuX3N0b3BUaHJvdygpO1xuICAgIHRoaXMuX3NhdmVEaW1lbnNpb25zKCk7XG4gICAgdGhpcy5fY3VycmVudFBvc2l0aW9uID0gdGhpcy5fcmVsYXRpdmVaZXJvO1xuICAgIHRoaXMuX2VtaXRFdmVudCh0aGlzLl9jcmVhdGVFdmVudChEcmFnZ2FibGUuRXZlbnRUeXBlLlNUQVJULCBldnQpKTtcbiAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChEcmFnZ2FibGUuQ2xhc3Nlcy5HUkFCQklORyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERyYWcgbW92ZSwgYWZ0ZXIgX2FwcGx5UG9zaXRpb24gaGFzIGhhcHBlbmVkXG4gICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBldnQgVGhlIGRyYWdnZXIgZXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgRHJhZ2dhYmxlLnByb3RvdHlwZS5faGFuZGxlRHJhZ01vdmUgPSBmdW5jdGlvbiBfaGFuZGxlRHJhZ01vdmUoZXZ0KSB7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBuZXcgcG9zaXRpb24gYmFzZWQgb24gbGltaXRzIGFuZCB0aGUgc3RhcnRpbmcgcG9pbnQuXG4gICAgdGhpcy5fY3VycmVudFBvc2l0aW9uID0gdGhpcy5fZ2V0TmV3TGltaXRlZFBvc2l0aW9uKHRoaXMucG9pbnRlci5kZWx0YSk7XG5cbiAgICB0aGlzLl9lbWl0RXZlbnQodGhpcy5fY3JlYXRlRXZlbnQoRHJhZ2dhYmxlLkV2ZW50VHlwZS5NT1ZFLCBldnQpKTtcblxuICAgIGlmICghdGhpcy5wb2ludGVyLl9pc0RlYWN0aXZhdGVkKSB7XG4gICAgICB0aGlzLl9hcHBseVBvc2l0aW9uKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBEcmFnZ2luZyBlbmRlZC5cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBEcmFnZ2FibGUucHJvdG90eXBlLl9oYW5kbGVEcmFnRW5kID0gZnVuY3Rpb24gX2hhbmRsZURyYWdFbmQoZXZ0KSB7XG4gICAgdGhpcy5fZW1pdEV2ZW50KHRoaXMuX2NyZWF0ZUV2ZW50KERyYWdnYWJsZS5FdmVudFR5cGUuRU5ELCBldnQpKTtcbiAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShEcmFnZ2FibGUuQ2xhc3Nlcy5HUkFCQklORyk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmlzVGhyb3dhYmxlICYmIHRoaXMucG9pbnRlci5oYXNWZWxvY2l0eShldnQuY3VycmVudFZlbG9jaXR5LCAwKSkge1xuICAgICAgdGhpcy5fdGhyb3coZXZ0LmN1cnJlbnRWZWxvY2l0eSwgZXZ0LmRlbHRhKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGEgdGhyb3cgYmFzZWQgb24gdGhlIGRyYWdnYWJsZSdzIHZlbG9jaXR5LlxuICAgKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IHZlbG9jaXR5IFZlbG9jaXR5LlxuICAgKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGRlbHRhIFRvdGFsIGRyYWcgZGlzdGFuY2UgZnJvbSBzdGFydCB0byBlbmQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgRHJhZ2dhYmxlLnByb3RvdHlwZS5fdGhyb3cgPSBmdW5jdGlvbiBfdGhyb3codmVsb2NpdHksIGRlbHRhKSB7XG4gICAgdGhpcy5fZGVsdGEgPSBkZWx0YTtcbiAgICB0aGlzLl90aHJvd1ZlbG9jaXR5ID0gQ29vcmRpbmF0ZS5zY2FsZSh2ZWxvY2l0eSwgdGhpcy5vcHRpb25zLmFtcGxpZmllcik7XG4gICAgdGhpcy5fYW5pbWF0ZVRocm93KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNjYWxlIGRvd24gdGhlIHZlbG9jaXR5LCB1cGRhdGUgdGhlIHBvc2l0aW9uLCBhbmQgYXBwbHkgaXQuIFRoZW4gZG8gaXQgYWdhaW5cbiAgICogdW50aWwgaXQncyBiZWxvdyBhIHRocmVzaG9sZC5cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBEcmFnZ2FibGUucHJvdG90eXBlLl9hbmltYXRlVGhyb3cgPSBmdW5jdGlvbiBfYW5pbWF0ZVRocm93KCkge1xuICAgIGlmICh0aGlzLnBvaW50ZXIuaGFzVmVsb2NpdHkodGhpcy5fdGhyb3dWZWxvY2l0eSwgdGhpcy5vcHRpb25zLnZlbG9jaXR5U3RvcCkpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRQb3NpdGlvbiA9IHRoaXMuX2dldE5ld0xpbWl0ZWRQb3NpdGlvbih0aGlzLl9kZWx0YSk7XG4gICAgICB0aGlzLl9hcHBseVBvc2l0aW9uKCk7XG5cbiAgICAgIHRoaXMuX2RlbHRhLnRyYW5zbGF0ZSh0aGlzLl90aHJvd1ZlbG9jaXR5KTtcbiAgICAgIHRoaXMuX3Rocm93VmVsb2NpdHkuc2NhbGUodGhpcy5vcHRpb25zLnRocm93RnJpY3Rpb24pO1xuXG4gICAgICAvLyBBZ2FpbiFcbiAgICAgIHRoaXMuX3JlcXVlc3RJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9hbmltYXRlVGhyb3cuYmluZCh0aGlzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNldHRsZSBvbiB0aGUgcGl4ZWwgZ3JpZC5cbiAgICAgIHRoaXMuX2N1cnJlbnRQb3NpdGlvbi54ID0gTWF0aC5yb3VuZCh0aGlzLl9jdXJyZW50UG9zaXRpb24ueCk7XG4gICAgICB0aGlzLl9jdXJyZW50UG9zaXRpb24ueSA9IE1hdGgucm91bmQodGhpcy5fY3VycmVudFBvc2l0aW9uLnkpO1xuICAgICAgdGhpcy5fYXBwbHlQb3NpdGlvbigpO1xuICAgICAgdGhpcy5fZW1pdFNldHRsZWQoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEludGVycnVwdCBhIHRocm93LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIERyYWdnYWJsZS5wcm90b3R5cGUuX3N0b3BUaHJvdyA9IGZ1bmN0aW9uIF9zdG9wVGhyb3coKSB7XG4gICAgdGhpcy5fZGVsdGEgPSBuZXcgQ29vcmRpbmF0ZSgpO1xuICAgIHRoaXMuX3Rocm93VmVsb2NpdHkgPSBuZXcgQ29vcmRpbmF0ZSgpO1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlcXVlc3RJZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgdGhlIFNFVFRMRSBldmVudCB3aXRoIGRhdGEuIFRoaXMgZGF0YSBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgc3RhcnQsXG4gICAqIG1vdmUsIGFuZCBlbmQgZXZlbnRzIHdoaWNoIHVzZSBkYXRhIGZyb20gdGhlIHBvaW50ZXIuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgRHJhZ2dhYmxlLnByb3RvdHlwZS5fZW1pdFNldHRsZWQgPSBmdW5jdGlvbiBfZW1pdFNldHRsZWQoKSB7XG4gICAgdGhpcy5fZW1pdEV2ZW50KG5ldyBPZG9Qb2ludGVyLkV2ZW50KHtcbiAgICAgIHR5cGU6IERyYWdnYWJsZS5FdmVudFR5cGUuU0VUVExFLFxuICAgICAgdGFyZ2V0OiB0aGlzLmVsZW1lbnQsXG4gICAgICBheGlzOiB0aGlzLnBvaW50ZXIub3B0aW9ucy5heGlzLFxuICAgICAgZGVsdGFUaW1lOiBEYXRlLm5vdygpIC0gdGhpcy5wb2ludGVyLnN0YXJ0VGltZSxcbiAgICAgIGRlbHRhOiBDb29yZGluYXRlLmRpZmZlcmVuY2UodGhpcy5fcmVsYXRpdmVaZXJvLCB0aGlzLl9jdXJyZW50UG9zaXRpb24pLFxuICAgICAgc3RhcnQ6IHRoaXMuX3JlbGF0aXZlWmVybyxcbiAgICAgIGVuZDogdGhpcy5fY3VycmVudFBvc2l0aW9uLFxuICAgICAgY3VycmVudFZlbG9jaXR5OiB0aGlzLl90aHJvd1ZlbG9jaXR5LFxuICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgcGl4ZWw6IHRoaXMuZ2V0UG9zaXRpb24oKSxcbiAgICAgICAgcGVyY2VudDogdGhpcy5nZXRQb3NpdGlvbih0cnVlKVxuICAgICAgfVxuICAgIH0pKTtcbiAgfTtcblxuICAvKipcbiAgICogTWFrZSBhIG5ldyBldmVudCB3aXRoIGRhdGEuXG4gICAqIEBwYXJhbSB7RHJhZ2dhYmxlLkV2ZW50VHlwZX0gdHlwZSBFdmVudCB0eXBlLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldnQgTmF0aXZlIGV2ZW50IG9iamVjdC5cbiAgICogQHJldHVybiB7IU9kb1BvaW50ZXIuRXZlbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgRHJhZ2dhYmxlLnByb3RvdHlwZS5fY3JlYXRlRXZlbnQgPSBmdW5jdGlvbiBfY3JlYXRlRXZlbnQodHlwZSwgZXZ0KSB7XG4gICAgcmV0dXJuIG5ldyBPZG9Qb2ludGVyLkV2ZW50KHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICB0YXJnZXQ6IGV2dC50YXJnZXQsXG4gICAgICBjdXJyZW50VGFyZ2V0OiB0aGlzLmVsZW1lbnQsXG4gICAgICBheGlzOiB0aGlzLnBvaW50ZXIub3B0aW9ucy5heGlzLFxuICAgICAgZGVsdGFUaW1lOiB0aGlzLnBvaW50ZXIuZGVsdGFUaW1lLFxuICAgICAgZGVsdGE6IENvb3JkaW5hdGUuZGlmZmVyZW5jZSh0aGlzLl9jdXJyZW50UG9zaXRpb24sIHRoaXMuX3JlbGF0aXZlWmVybyksXG4gICAgICBzdGFydDogdGhpcy5fcmVsYXRpdmVaZXJvLFxuICAgICAgZW5kOiB0aGlzLl9jdXJyZW50UG9zaXRpb24sXG4gICAgICBjdXJyZW50VmVsb2NpdHk6IHRoaXMucG9pbnRlci52ZWxvY2l0eSxcbiAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgIHBpeGVsOiB0aGlzLmdldFBvc2l0aW9uKCksXG4gICAgICAgIHBlcmNlbnQ6IHRoaXMuZ2V0UG9zaXRpb24odHJ1ZSlcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB0aGUgcG9zaXRpb24gb2YgdGhkIGRyYWdnYWJsZSBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IFtwb3NpdGlvbl0gUG9zaXRpb24gdG8gc2V0IHRoZSBkcmFnZ2FibGUgZWxlbWVudC4gVGhpc1xuICAgKiAgICAgd2lsbCBvcHRpb25hbGx5IG92ZXJyaWRlIGNhbGN1bGF0aW5nIHRoZSBwb3NpdGlvbiBmcm9tIGEgZHJhZy5cbiAgICogQHJldHVybiB7Q29vcmRpbmF0ZX0gVGhlIHBvc2l0aW9uIHRoZSBkcmFnZ2FibGUgZWxlbWVudCB3YXMgc2V0IHRvLlxuICAgKi9cblxuXG4gIERyYWdnYWJsZS5wcm90b3R5cGUuX2FwcGx5UG9zaXRpb24gPSBmdW5jdGlvbiBfYXBwbHlQb3NpdGlvbihwb3NpdGlvbikge1xuICAgIHZhciBwb3MgPSB0aGlzLl9nZXRFbGVtZW50UG9zaXRpb24ocG9zaXRpb24pO1xuICAgIHRoaXMuZWxlbWVudC5zdHlsZVtPZG9EZXZpY2UuRG9tLlRSQU5TRk9STV0gPSAndHJhbnNsYXRlKCcgKyBwb3MueCArICclLCcgKyBwb3MueSArICclKSc7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRQb3NpdGlvbjtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FzUGVyY2VudF0gT3B0aW9uYWxseSByZXRyaWV2ZSBwZXJjZW50YWdlIHZhbHVlcyBpbnN0ZWFkXG4gICAqICAgICBvZiBwaXhlbCB2YWx1ZXMuXG4gICAqIEByZXR1cm4ge0Nvb3JkaW5hdGV9IFggYW5kIFkgY29vcmRpbmF0ZXMgb2YgdGhlIGRyYWdnYWJsZSBlbGVtZW50LlxuICAgKi9cblxuXG4gIERyYWdnYWJsZS5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiBnZXRQb3NpdGlvbihhc1BlcmNlbnQpIHtcbiAgICBpZiAoYXNQZXJjZW50KSB7XG4gICAgICByZXR1cm4gbmV3IENvb3JkaW5hdGUodGhpcy5fY3VycmVudFBvc2l0aW9uLnggLyB0aGlzLl9wYXJlbnRFbC5vZmZzZXRXaWR0aCAqIDEwMCwgdGhpcy5fY3VycmVudFBvc2l0aW9uLnkgLyB0aGlzLl9wYXJlbnRFbC5vZmZzZXRIZWlnaHQgKiAxMDApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFBvc2l0aW9uO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBkcmFnZ2FibGUgZWxlbWVudC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggWCBwb3NpdGlvbiBhcyBhIHBlcmNlbnRhZ2UuIEVnLiA1MCBmb3IgXCI1MCVcIi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgWSBwb3NpdGlvbiBhcyBhIHBlcmNlbnRhZ2UuIEVnLiA1MCBmb3IgXCI1MCVcIi5cbiAgICogQHJldHVybiB7Q29vcmRpbmF0ZX0gVGhlIHBvc2l0aW9uIHRoZSBkcmFnZ2FibGUgZWxlbWVudCB3YXMgc2V0IHRvLlxuICAgKi9cblxuXG4gIERyYWdnYWJsZS5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbiBzZXRQb3NpdGlvbih4LCB5KSB7XG4gICAgLy8gc2V0UG9zaXRpb24gY2FuIGJlIGNhbGxlZCBiZWZvcmUgYW55IGRyYWdnaW5nLCB0aGlzIHdvdWxkIGNhdXNlXG4gICAgLy8gdGhlIGNvbnRhaW5tZW50IHdpZHRoIGFuZCBjb250YWlubWVudCBoZWlnaHQgdG8gYmUgdW5kZWZpbmVkLlxuICAgIHRoaXMudXBkYXRlKCk7XG4gICAgcmV0dXJuIHRoaXMuX2FwcGx5UG9zaXRpb24obmV3IENvb3JkaW5hdGUoeCwgeSkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIChvciByZXNldCkgdGhlIERyYWcgbGltaXRzIGFmdGVyIGEgRHJhZ2dlciBpcyBjcmVhdGVkLlxuICAgKiBAcGFyYW0ge1JlY3R9IGxpbWl0cyBPYmplY3QgY29udGFpbmluZyBsZWZ0LCB0b3AsIHdpZHRoLFxuICAgKiAgICAgaGVpZ2h0IGZvciBuZXcgRHJhZ2dlciBsaW1pdHMuXG4gICAqL1xuXG5cbiAgRHJhZ2dhYmxlLnByb3RvdHlwZS5zZXRMaW1pdHMgPSBmdW5jdGlvbiBzZXRMaW1pdHMobGltaXRzKSB7XG4gICAgdGhpcy5saW1pdHMgPSBsaW1pdHM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVhc3kgd2F5IHRvIHRyaWdnZXIgc2V0dGluZyBkaW1lbnNpb25zLiBVc2VmdWwgZm9yIGRvaW5nIHRoaW5ncyBhZnRlciB0aGlzXG4gICAqIGNsYXNzIGhhcyBiZWVuIGluaXRpYWxpemVkLCBidXQgbm8gZHJhZ2dpbmcgaGFzIG9jY3VycmVkIHlldC5cbiAgICovXG4gIERyYWdnYWJsZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHRoaXMuX3NhdmVEaW1lbnNpb25zKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBldmVudCBsaXN0ZW5lcnMgYW5kIGVsZW1lbnQgcmVmZXJlbmNlcy5cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBEcmFnZ2FibGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIHRoaXMucG9pbnRlci5vZmYoT2RvUG9pbnRlci5FdmVudFR5cGUuU1RBUlQsIHRoaXMuX29uU3RhcnQpO1xuICAgIHRoaXMucG9pbnRlci5vZmYoT2RvUG9pbnRlci5FdmVudFR5cGUuTU9WRSwgdGhpcy5fb25Nb3ZlKTtcbiAgICB0aGlzLnBvaW50ZXIub2ZmKE9kb1BvaW50ZXIuRXZlbnRUeXBlLkVORCwgdGhpcy5fb25FbmQpO1xuXG4gICAgdGhpcy5wb2ludGVyLmRpc3Bvc2UoKTtcblxuICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKERyYWdnYWJsZS5DbGFzc2VzLkdSQUJCQUJMRSk7XG5cbiAgICB0aGlzLl9wYXJlbnRFbCA9IG51bGw7XG4gICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogRW1pdHMgYSBldmVudCBvbiB0aGlzIGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gZXZlbnQgRXZlbnQgb2JqZWN0IHdpdGggZGF0YS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBwcmV2ZW50RGVmYXVsdCB3YXMgY2FsbGVkIG9uIHRoZSBldmVudC5cbiAgICovXG5cblxuICBEcmFnZ2FibGUucHJvdG90eXBlLl9lbWl0RXZlbnQgPSBmdW5jdGlvbiBfZW1pdEV2ZW50KGV2ZW50KSB7XG4gICAgdGhpcy5lbWl0KGV2ZW50LnR5cGUsIGV2ZW50KTtcbiAgICByZXR1cm4gZXZlbnQuZGVmYXVsdFByZXZlbnRlZDtcbiAgfTtcblxuICBjcmVhdGVDbGFzcyhEcmFnZ2FibGUsIFt7XG4gICAga2V5OiAnZnJpY3Rpb24nLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgcmV0dXJuIHRoaXMucG9pbnRlci5mcmljdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGZyaWN0aW9uIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmcmljdGlvbiBBIG51bWJlciBiZXR3ZWVuIFsxLCAwXS5cbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEoZnJpY3Rpb24pIHtcbiAgICAgIHRoaXMucG9pbnRlci5mcmljdGlvbiA9IGZyaWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB3aGV0aGVyIGRyYWdnZXIgaXMgZW5hYmxlZC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIGRyYWdnZXIgaXMgZW5hYmxlZC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaXNFbmFibGVkJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBvaW50ZXIuaXNFbmFibGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB3aGV0aGVyIGRyYWdnZXIgaXMgZW5hYmxlZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWQgV2hldGhlciBkcmFnZ2VyIGlzIGVuYWJsZWQuXG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKGVuYWJsZWQpIHtcbiAgICAgIHRoaXMucG9pbnRlci5pc0VuYWJsZWQgPSBlbmFibGVkO1xuICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoc2V0dGluZ3MuQ2xhc3Nlcy5HUkFCQkFCTEUsIGVuYWJsZWQpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRHJhZ2dhYmxlO1xufShUaW55RW1pdHRlcik7XG5cbk9iamVjdC5hc3NpZ24oRHJhZ2dhYmxlLCBzZXR0aW5ncyk7XG5cbmV4cG9ydCBkZWZhdWx0IERyYWdnYWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9kby1kcmFnZ2FibGUuZXNtLmpzLm1hcFxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@odopod/odo-draggable/dist/odo-draggable.esm.js\n");

/***/ }),

/***/ "./node_modules/@odopod/odo-helpers/dist/odo-helpers.esm.js":
/*!******************************************************************!*\
  !*** ./node_modules/@odopod/odo-helpers/dist/odo-helpers.esm.js ***!
  \******************************************************************/
/*! exports provided: getTransitions, animationClasses, Stepper, Box, cancelTransitionEnd, capitalize, causeLayout, chunk, clamp, closestGreaterThan, closestLessThan, closest, Coordinate, defaultsTo, domLoaded, domReady, evenHeights, events, fadeInElement, fadeOutElement, forceRedraw, getElementsSize, getIOSVersion, getMarginBox, getNthSibling, getNumberOption, getPaddingBox, getPercentageOption, getRelativeDepth, getSize, getStringOption, giveId, hasScrollEvents, hyphenate, isAndroidOS, isChrome, isDefined, isEdge, isIE, isIOS, isNativeAndroid, isString, noop, onAnimationEnd, onTransitionEnd, pull, randomString, Rect, removeChildren, replaceWithHash, scrollToTop, scrollTo, setHash, swapElements, Timer, wrapAroundList */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getTransitions\", function() { return getTransitions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"animationClasses\", function() { return Classes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Stepper\", function() { return Stepper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Box\", function() { return Box; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cancelTransitionEnd\", function() { return cancelTransitionEnd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"capitalize\", function() { return capitalize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"causeLayout\", function() { return causeLayout; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"chunk\", function() { return chunk; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clamp\", function() { return clamp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"closestGreaterThan\", function() { return closestGreaterThan; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"closestLessThan\", function() { return closestLessThan; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"closest\", function() { return closest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Coordinate\", function() { return Coordinate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"defaultsTo\", function() { return defaultsTo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"domLoaded\", function() { return domLoaded; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"domReady\", function() { return domReady; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"evenHeights\", function() { return evenHeights; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"events\", function() { return events; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fadeInElement\", function() { return fadeInElement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fadeOutElement\", function() { return fadeOutElement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forceRedraw\", function() { return forceRedraw; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getElementsSize\", function() { return getElementsSize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getIOSVersion\", function() { return getIOSVersion; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getMarginBox\", function() { return getMarginBox; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getNthSibling\", function() { return getNthSibling; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getNumberOption\", function() { return getNumberOption; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getPaddingBox\", function() { return getPaddingBox; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getPercentageOption\", function() { return getPercentageOption; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getRelativeDepth\", function() { return getRelativeDepth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getSize\", function() { return getSize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getStringOption\", function() { return getStringOption; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"giveId\", function() { return giveId; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hasScrollEvents\", function() { return hasScrollEvents; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hyphenate\", function() { return hyphenate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isAndroidOS\", function() { return isAndroidOS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isChrome\", function() { return isChrome; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isDefined\", function() { return isDefined; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isEdge\", function() { return isEdge; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isIE\", function() { return isIE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isIOS\", function() { return isIOS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNativeAndroid\", function() { return isNativeAndroid; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isString\", function() { return isString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"noop\", function() { return noop; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"onAnimationEnd\", function() { return onAnimationEnd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"onTransitionEnd\", function() { return onTransitionEnd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pull\", function() { return pull; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"randomString\", function() { return random; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Rect\", function() { return Rect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"removeChildren\", function() { return removeChildren; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"replaceWithHash\", function() { return replaceWithHash; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scrollToTop\", function() { return scrollTo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scrollTo\", function() { return scrollTo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setHash\", function() { return setHash; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"swapElements\", function() { return swapElements; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Timer\", function() { return Timer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"wrapAroundList\", function() { return wrapAroundList; });\n/* harmony import */ var _odopod_odo_device__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @odopod/odo-device */ \"./node_modules/@odopod/odo-device/dist/odo-device.esm.js\");\n\n\n/**\n * @param {*} value Anything.\n * @return {boolean}\n */\nfunction isDefined(value) {\n  return value !== undefined && value !== null;\n}\n\nvar transitions = {};\nvar transitionId = 0;\n\n/**\n * Store a pending transition.\n * @param {HTMLElement} element Element which has the transitionend listener.\n * @param {number} timerId Timer id from setTimeout to cancel the transition.\n * @param {(evt: TransitionEvent) => void} listener Callback.\n * @return {number} Transition id.\n */\nfunction saveTransition(element, timerId, listener) {\n  transitionId += 1;\n  transitions[transitionId] = {\n    element: element,\n    timerId: timerId,\n    listener: listener\n  };\n  return transitionId;\n}\n\n/**\n * Remove a transition id from the stored list.\n * @param {number} transitionId Transition id to remove.\n */\nfunction clearTransition(transitionId) {\n  delete transitions[transitionId];\n}\n\n/**\n * Retrieve a transition object.\n * @param {number} transitionId Transition id to retrieve.\n * @return {{element: HTMLElement, timerId: number, listener: (evt: TransitionEvent) => void}}\n *   Transition object.\n */\nfunction getTransition(transitionId) {\n  return transitions[transitionId];\n}\n\n/**\n * Retrieve all transition objects.\n * @return {object}\n */\nfunction getTransitions() {\n  return transitions;\n}\n\n/**\n * Returns the element when the first parameter is a jQuery collection.\n * @param {HTMLElement|jQuery} elem An element or a jQuery collection.\n * @return {HTMLElement}\n * @throws {Error} If it's a jQuery collection of more than one element.\n */\nfunction getElement(elem) {\n  if (elem.jquery) {\n    if (elem.length > 1) {\n      throw new TypeError('This method only supports transition end for one element, not a collection');\n    }\n\n    return elem[0];\n  }\n\n  return elem;\n}\n\nfunction isOwnEvent(event) {\n  return event.target === event.currentTarget;\n}\n\nfunction isSameTransitionProperty(event, prop) {\n  return event.fake || !isDefined(prop) || event.propertyName === prop;\n}\n\nfunction getFakeEvent(elem) {\n  return {\n    target: elem,\n    currentTarget: elem,\n    fake: true\n  };\n}\n\nvar Classes = {\n  FADE: 'fade',\n  IN: 'in',\n  INVISIBLE: 'invisible'\n};\n\nfunction noop() {}\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n/**\n * @fileoverview A simple class for providing a stepping function for each\n * animation frame over a given length of time. Uses requestAnimationFrame\n * where available. Its API is similar to the AnimationPlayer in `Element.animate`.\n *\n * Assumes `requestAnimationFrame`, `Function.prototype.bind`, and `Object.assign`\n * are available.\n *\n * @author Glen Cheney <glen@odopod.com>\n */\n\nvar Stepper = function () {\n  /**\n   * Easy animation stepper.\n   *\n   * @param {Object} [options] Options object.\n   * @param {number} [options.start] Starting number. Value to animate from.\n   * @param {number} [options.end] Ending number. Value to animate to.\n   * @param {function(number, number):void} [options.step] Step function which\n   *     will receive the step value and the current percentage completed.\n   * @param {number} [options.duration] Length of the animation. Default is 250ms.\n   * @param {Object} [options.context] The object scope to invoke the function in.\n   * @param {function(number):number} [options.easing] Easing function to apply.\n   * @constructor\n   */\n  function Stepper(options) {\n    classCallCheck(this, Stepper);\n\n    this.options = Object.assign({}, Stepper.Defaults, options);\n\n    /**\n     * The percentage value which the scrubber and reveals will be animated to.\n     * @type {number}\n     * @private\n     */\n    this._animationAmount = this.options.end - this.options.start;\n\n    /**\n     * Time when the animation timer started.\n     * @type {number}\n     * @private\n     */\n    this._animationStart = +new Date();\n\n    this._handler = this._animateLoop.bind(this);\n\n    /**\n     * Called at the end of the animation with `options.context`.\n     * @type {function:void}\n     */\n    this.onfinish = noop;\n\n    // Start loop.\n    this._requestId = requestAnimationFrame(this._handler);\n  }\n\n  /**\n   * Internal loop ticker.\n   * @private\n   */\n\n\n  Stepper.prototype._animateLoop = function _animateLoop() {\n    var now = new Date().getTime();\n    var remainingTime = this._animationStart + this.options.duration - now;\n\n    // Even when duration is zero, this will result in Infinity, which will only\n    // call the step method once then onfinish, which is desired.\n    var percent = 1 - remainingTime / this.options.duration;\n\n    // Abort if already at or past 100%.\n    if (percent >= 1) {\n      // Make sure it always finishes with 1.\n      this.options.step.call(this.options.context, this.options.end, 1);\n      this.onfinish.call(this.options.context);\n      this.dispose();\n      return;\n    }\n\n    // Apply easing.\n    percent = this.options.easing(percent);\n\n    // Request animation frame.\n    this._requestId = requestAnimationFrame(this._handler);\n\n    // Tick.\n    this.options.step.call(this.options.context, this.options.start + this._animationAmount * percent, percent);\n  };\n\n  /**\n   * Stop the animation and dispose of it.\n   */\n\n\n  Stepper.prototype.cancel = function cancel() {\n    cancelAnimationFrame(this._requestId);\n    this.dispose();\n  };\n\n  /**\n   * Destroy the animation instance.\n   */\n\n\n  Stepper.prototype.dispose = function dispose() {\n    this._handler = null;\n    this.options.context = null;\n  };\n\n  return Stepper;\n}();\n\nStepper.Defaults = {\n  start: 0,\n  end: 1,\n  duration: 250,\n  step: noop,\n  context: window,\n  easing: function easing(k) {\n    return -0.5 * (Math.cos(Math.PI * k) - 1);\n  }\n};\n\nvar Box =\n/**\n * Class for representing a box. A box is specified as a top, right, bottom,\n * and left. A box is useful for representing margins and padding.\n * @param {number} top Top.\n * @param {number} right Right.\n * @param {number} bottom Bottom.\n * @param {number} left Left.\n * @constructor\n */\nfunction Box(top, right, bottom, left) {\n  classCallCheck(this, Box);\n\n  /**\n   * Top\n   * @type {number}\n   */\n  this.top = top;\n\n  /**\n   * Right\n   * @type {number}\n   */\n  this.right = right;\n\n  /**\n   * Bottom\n   * @type {number}\n   */\n  this.bottom = bottom;\n\n  /**\n   * Left\n   * @type {number}\n   */\n  this.left = left;\n};\n\n/**\n * Returns the prefixed or unprefixed pointer event name or null if not pointer events.\n * @param {string} event The event name. e.g. \"pointerdown\".\n * @return {?string} The event name or null.\n */\nfunction getPointerEvent(event) {\n  /* istanbul ignore else */\n  if (_odopod_odo_device__WEBPACK_IMPORTED_MODULE_0__[\"default\"].HAS_POINTER_EVENTS) {\n    return event;\n  }\n\n  /* istanbul ignore next */\n  return null;\n}\n\n/**\n * Returns a normalized transition end event name.\n *\n * Issue with Modernizr prefixing related to stock Android 4.1.2\n * That version of Android has both unprefixed and prefixed transitions\n * built in, but will only listen to the prefixed on in certain cases\n * https://github.com/Modernizr/Modernizr/issues/897\n *\n * @return {string} A patched transition end event name.\n */\nfunction getTransitionEndEvent() {\n  var div = document.createElement('div');\n  div.style.transitionProperty = 'width';\n\n  // Test the value which was just set. If it wasn't able to be set,\n  // then it shouldn't use unprefixed transitions.\n  /* istanbul ignore next */\n  if (div.style.transitionProperty !== 'width' && 'webkitTransition' in div.style) {\n    return 'webkitTransitionEnd';\n  }\n\n  return {\n    // Saf < 7, Android Browser < 4.4\n    WebkitTransition: 'webkitTransitionEnd',\n    transition: 'transitionend'\n  }[_odopod_odo_device__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Dom.TRANSITION];\n}\n\n/**\n * Returns a normalized animation end event name.\n * @return {string}\n */\nfunction getAnimationEndEvent() {\n  return {\n    WebkitAnimation: 'webkitAnimationEnd',\n    animation: 'animationend'\n  }[_odopod_odo_device__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Dom.ANIMATION];\n}\n\nvar events = {\n  // Mouse events\n  CLICK: 'click',\n  DBLCLICK: 'dblclick',\n  MOUSEDOWN: 'mousedown',\n  MOUSEUP: 'mouseup',\n  MOUSEOVER: 'mouseover',\n  MOUSEOUT: 'mouseout',\n  MOUSEMOVE: 'mousemove',\n\n  // IE, Safari, Chrome\n  SELECTSTART: 'selectstart',\n\n  // Key events\n  KEYPRESS: 'keypress',\n  KEYDOWN: 'keydown',\n  KEYUP: 'keyup',\n\n  // Focus\n  BLUR: 'blur',\n  FOCUS: 'focus',\n\n  // IE only\n  DEACTIVATE: 'deactivate',\n\n  FOCUSIN: 'focusin',\n  FOCUSOUT: 'focusout',\n\n  // Forms\n  CHANGE: 'change',\n  SELECT: 'select',\n  SUBMIT: 'submit',\n  INPUT: 'input',\n\n  // IE only\n  PROPERTYCHANGE: 'propertychange',\n\n  // Drag and drop\n  DRAGSTART: 'dragstart',\n  DRAG: 'drag',\n  DRAGENTER: 'dragenter',\n  DRAGOVER: 'dragover',\n  DRAGLEAVE: 'dragleave',\n  DROP: 'drop',\n  DRAGEND: 'dragend',\n\n  // WebKit touch events.\n  TOUCHSTART: 'touchstart',\n  TOUCHMOVE: 'touchmove',\n  TOUCHEND: 'touchend',\n  TOUCHCANCEL: 'touchcancel',\n\n  // Misc\n  BEFOREUNLOAD: 'beforeunload',\n  CONTEXTMENU: 'contextmenu',\n  ERROR: 'error',\n  HELP: 'help',\n  LOAD: 'load',\n  LOSECAPTURE: 'losecapture',\n  READYSTATECHANGE: 'readystatechange',\n  RESIZE: 'resize',\n  SCROLL: 'scroll',\n  UNLOAD: 'unload',\n\n  // HTML 5 History events\n  // See http://www.w3.org/TR/html5/history.html#event-definitions\n  HASHCHANGE: 'hashchange',\n  PAGEHIDE: 'pagehide',\n  PAGESHOW: 'pageshow',\n  POPSTATE: 'popstate',\n\n  // Copy and Paste\n  // Support is limited. Make sure it works on your favorite browser\n  // before using.\n  // http://www.quirksmode.org/dom/events/cutcopypaste.html\n  COPY: 'copy',\n  PASTE: 'paste',\n  CUT: 'cut',\n  BEFORECOPY: 'beforecopy',\n  BEFORECUT: 'beforecut',\n  BEFOREPASTE: 'beforepaste',\n\n  // HTML5 online/offline events.\n  // http://www.w3.org/TR/offline-webapps/#related\n  ONLINE: 'online',\n  OFFLINE: 'offline',\n\n  // HTML 5 worker events\n  MESSAGE: 'message',\n  CONNECT: 'connect',\n\n  // Css transition events.\n  TRANSITIONEND: getTransitionEndEvent(),\n\n  ANIMATIONEND: getAnimationEndEvent(),\n\n  // Pointer events\n  POINTERCANCEL: getPointerEvent('pointercancel'),\n  POINTERDOWN: getPointerEvent('pointerdown'),\n  POINTERMOVE: getPointerEvent('pointermove'),\n  POINTEROVER: getPointerEvent('pointerover'),\n  POINTEROUT: getPointerEvent('pointerout'),\n  POINTERUP: getPointerEvent('pointerup')\n};\n\n/**\n * Remove the event listener for `transitionend`.\n * @param {number} id The number returned by `onTransitionEnd`.\n * @return {boolean} Whether the transition was canceled or not. If the transition\n *     already finished, this method will return false.\n */\nfunction cancelTransitionEnd(id) {\n  var obj = getTransition(id);\n\n  if (obj) {\n    clearTimeout(obj.timerId);\n\n    if (_odopod_odo_device__WEBPACK_IMPORTED_MODULE_0__[\"default\"].HAS_TRANSITIONS) {\n      obj.element.removeEventListener(events.TRANSITIONEND, obj.listener);\n    }\n\n    clearTransition(id);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Capitalize a string.\n * @param {string} str String to capitalize.\n * @return {string} Capitalized string.\n */\nfunction capitalize(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\n/**\n * Ask the browser for a property that will cause it to recalculate styles\n * and layout the element (and possibly surrounding/parent elements).\n * @param {HTMLElement} element Element to for a layout for.\n * @return {number} Width of the element. If you actually need the width of\n *     element, use the `style.getSize` method.\n */\nfunction causeLayout(element) {\n  return element.offsetWidth;\n}\n\n/**\n * Make an array of smaller arrays from an array.\n * @param {Array.<*>} array An array to take chunks from.\n * @param {number} size The number of items per chunk.\n * @return {Array.<Array.<*>>}\n */\nfunction chunk(array, size) {\n  if (!size) {\n    return [];\n  }\n\n  var numArrays = Math.ceil(array.length / size);\n  var chunked = new Array(numArrays);\n\n  // eslint-disable-next-line no-plusplus\n  for (var i = 0, index = 0; i < numArrays; index += size, i++) {\n    chunked[i] = array.slice(index, index + size);\n  }\n\n  return chunked;\n}\n\n/**\n * Takes a number and clamps it to within the provided bounds.\n * @param {number} value The input number.\n * @param {number} min The minimum value to return.\n * @param {number} max The maximum value to return.\n * @return {number} The input number if it is within bounds, or the nearest\n *     number within the bounds.\n */\nfunction clamp(value, min, max) {\n  return Math.min(Math.max(value, min), max);\n}\n\n/**\n * Given an array of numbers (`arr`), find the item in the array closest\n * to a given number (`num`).\n *\n * @param  {Array.<number>} arr An array of numbers.\n * @param  {number} num Close number to search from.\n * @return {?number} The closest number in the array.\n */\nfunction closest(arr, num) {\n  var closest = null;\n\n  arr.reduce(function (closestDiff, value) {\n    var diff = Math.abs(value - num);\n    if (diff < closestDiff) {\n      closest = value;\n      return diff;\n    }\n\n    return closestDiff;\n  }, Infinity);\n\n  return closest;\n}\n\n/**\n * Given an array of numbers (`arr`), find the item in the array closest\n * to a given number (`num`), while also greater than (`num`).\n *\n * @param  {Array.<number>} arr An array of numbers.\n * @param  {number} num Close number to search from.\n * @return {?number} The closest number in the array.\n */\nfunction closestGreaterThan(arr, num) {\n  return closest(arr.filter(function (value) {\n    return value > num;\n  }), num);\n}\n\n/**\n * Given an array of numbers (`arr`), find the item in the array closest\n * to a given number (`num`), while also less than (`num`).\n *\n * @param  {Array.<number>} arr An array of numbers.\n * @param  {number} num Close number to search from.\n * @return {?number} The closest number in the array.\n */\nfunction closestLessThan(arr, num) {\n  return closest(arr.filter(function (value) {\n    return value < num;\n  }), num);\n}\n\nvar Coordinate = function () {\n  /**\n   * Class for representing coordinates and positions.\n   * @param {number} [x=0] Left, defaults to 0.\n   * @param {number} [y=0] Top, defaults to 0.\n   * @constructor\n   */\n  function Coordinate() {\n    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    classCallCheck(this, Coordinate);\n\n    /**\n     * X-value\n     * @type {number}\n     */\n    this.x = x;\n\n    /**\n     * Y-value\n     * @type {number}\n     */\n    this.y = y;\n  }\n\n  /**\n   * Returns a duplicate of this coordinate.\n   * @return {Coordinate}\n   */\n\n\n  Coordinate.prototype.clone = function clone() {\n    return new Coordinate(this.x, this.y);\n  };\n\n  /**\n   * Scales this coordinate by the given scale factors. The x and y values are\n   * scaled by {@code sx} and {@code optSy} respectively.  If {@code optSy}\n   * is not given, then {@code sx} is used for both x and y.\n   * @param {number} sx The scale factor to use for the x dimension.\n   * @param {number=} optSy The scale factor to use for the y dimension.\n   * @return {!Coordinate} This coordinate after scaling.\n   */\n\n\n  Coordinate.prototype.scale = function scale(sx) {\n    var optSy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : sx;\n\n    this.x *= sx;\n    this.y *= optSy;\n    return this;\n  };\n\n  /**\n   * Translates this box by the given offsets. If a {@code Coordinate}\n   * is given, then the x and y values are translated by the coordinate's x and y.\n   * Otherwise, x and y are translated by {@code tx} and {@code opt_ty}\n   * respectively.\n   * @param {number|Coordinate} tx The value to translate x by or the\n   *     the coordinate to translate this coordinate by.\n   * @param {number} [ty] The value to translate y by.\n   * @return {!Coordinate} This coordinate after translating.\n   */\n\n\n  Coordinate.prototype.translate = function translate(tx, ty) {\n    if (tx instanceof Coordinate) {\n      this.x += tx.x;\n      this.y += tx.y;\n    } else {\n      this.x += tx;\n      this.y += ty;\n    }\n\n    return this;\n  };\n\n  /**\n   * Compares coordinates for equality.\n   * @param {Coordinate} a A Coordinate.\n   * @param {Coordinate} b A Coordinate.\n   * @return {boolean} True iff the coordinates are equal, or if both are null.\n   */\n\n\n  Coordinate.equals = function equals(a, b) {\n    if (a === b) {\n      return true;\n    }\n\n    if (!a || !b) {\n      return false;\n    }\n\n    return a.x === b.x && a.y === b.y;\n  };\n\n  /**\n   * Returns the distance between two coordinates.\n   * @param {!Coordinate} a A Coordinate.\n   * @param {!Coordinate} b A Coordinate.\n   * @return {number} The distance between {@code a} and {@code b}.\n   */\n\n\n  Coordinate.distance = function distance(a, b) {\n    var dx = a.x - b.x;\n    var dy = a.y - b.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  };\n\n  /**\n   * Returns the difference between two coordinates as a new Coordinate.\n   * @param {!Coordinate} a A Coordinate.\n   * @param {!Coordinate} b A Coordinate.\n   * @return {!Coordinate} A Coordinate representing the difference\n   *     between {@code a} and {@code b}.\n   */\n\n\n  Coordinate.difference = function difference(a, b) {\n    return new Coordinate(a.x - b.x, a.y - b.y);\n  };\n\n  /**\n   * Returns the sum of two coordinates as a new Coordinate.\n   * @param {!Coordinate} a A Coordinate.\n   * @param {!Coordinate} b A Coordinate.\n   * @return {!Coordinate} A Coordinate representing the sum of the two coordinates.\n   */\n\n\n  Coordinate.sum = function sum(a, b) {\n    return new Coordinate(a.x + b.x, a.y + b.y);\n  };\n\n  /**\n   * Returns the product of two coordinates as a new Coordinate.\n   * @param {!Coordinate} a A Coordinate.\n   * @param {!Coordinate} b A Coordinate.\n   * @return {!Coordinate} A Coordinate representing the product of the two coordinates.\n   */\n\n\n  Coordinate.product = function product(a, b) {\n    return new Coordinate(a.x * b.x, a.y * b.y);\n  };\n\n  /**\n   * Returns the quotient of two coordinates as a new Coordinate.\n   * @param {!Coordinate} a A Coordinate.\n   * @param {!Coordinate} b A Coordinate.\n   * @return {!Coordinate} A Coordinate representing the quotient of the two coordinates.\n   */\n\n\n  Coordinate.quotient = function quotient(a, b) {\n    return new Coordinate(a.x / b.x, a.y / b.y);\n  };\n\n  /**\n   * Scales this coordinate by the given scale factors. This does not affect the\n   * properites of the coordinate parameter.\n   * @param {!Coordinate} a A Coordinate.\n   * @param {number} sx The scale factor to use for the x dimension.\n   * @param {number=} optSy The scale factor to use for the y dimension.\n   * @return {!Coordinate} This coordinate after scaling.\n   */\n\n\n  Coordinate.scale = function scale(a, sx) {\n    var optSy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : sx;\n\n    return new Coordinate(a.x * sx, a.y * optSy);\n  };\n\n  return Coordinate;\n}();\n\n/**\n * Fallback to a specified default if an input is undefined or null.\n * @param {*} obj The input to test.\n * @param {*} defaultValue The fallback if the input is undefined.\n * @param {boolean=} test If defined, `test` will be used to determine which\n *     value should be used.\n * @return {*} The sanitized output, either `obj` or `defaultValue`.\n */\nfunction defaultsTo(obj, defaultValue) {\n  var test = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : isDefined(obj);\n\n  return test ? obj : defaultValue;\n}\n\n/**\n * Returns a promise which resolves when the window load event is fired, or\n * one which resolves immediately if that has already happened.\n * @type {Promise<void>}\n */\nvar domLoaded = new Promise(function (resolve) {\n  /* istanbul ignore if */\n  if (document.readyState === 'complete') {\n    resolve();\n  } else {\n    window.addEventListener('load', function complete() {\n      window.removeEventListener('load', complete);\n      resolve();\n    });\n  }\n});\n\n/**\n * Returns a promise which resolves when the DOMContentLoaded event is fired, or\n * one which resolves immediately if that has already happened.\n * @type {Promise<void>}\n */\nvar domReady = new Promise(function (resolve) {\n  /* istanbul ignore if */\n  if (document.readyState === 'interactive') {\n    resolve();\n  } else {\n    document.addEventListener('DOMContentLoaded', function ready() {\n      document.removeEventListener('DOMContentLoaded', ready);\n      resolve();\n    });\n  }\n});\n\n/**\n * Determine which element in an array is the tallest.\n * @param {ArrayLike<HTMLElement>} elements Array-like of elements.\n * @return {number} Height of the tallest element.\n */\nfunction getTallest(elements) {\n  var tallest = 0;\n\n  for (var i = elements.length - 1; i >= 0; i--) {\n    if (elements[i].offsetHeight > tallest) {\n      tallest = elements[i].offsetHeight;\n    }\n  }\n\n  return tallest;\n}\n\n/**\n * Set the height of every element in an array to a value.\n * @param {ArrayLike<HTMLElement>} elements Array-like of elements.\n * @param {string} height Height value to set.\n */\nfunction setAllHeights(elements, height) {\n  for (var i = elements.length - 1; i >= 0; i--) {\n    elements[i].style.height = height;\n  }\n}\n\n/**\n * For groups of elements which should be the same height. Using this method\n * will create far less style recalculations and layouts.\n * @param {ArrayLike.<HTMLElement>|ArrayLike.<ArrayLike.<HTMLElement>>} groups An\n *     array-like collection of an array-like collection of elements.\n * @return {number|Array.<number>} An array containing the pixel value of the\n *     tallest element for each group, or just a number if it's one group.\n */\nfunction evenHeights(groups) {\n  var list = Array.from(groups);\n\n  // If the first item in the list is an element, then it needs to be wrapped\n  // in an array so the rest of the methods will work.\n  var isGroup = true;\n  if (list[0] && list[0].nodeType) {\n    isGroup = false;\n    list = [list];\n  }\n\n  // First, reset the height for every element.\n  // This is done first, otherwise we dirty the DOM on each loop!\n  list.forEach(function (elements) {\n    setAllHeights(elements, '');\n  });\n\n  // Now, measure heights in each group and save the tallest value. Instead of\n  // setting the height value for the entire group, save it. If it were set,\n  // the next iteration in the loop would have to recalculate styles in the DOM\n  var tallests = list.map(function (elements) {\n    return getTallest(elements);\n  });\n\n  // Lastly, set them all.\n  list.forEach(function (elements, i) {\n    setAllHeights(elements, tallests[i] + 'px');\n  });\n\n  if (isGroup) {\n    return tallests;\n  }\n  return tallests[0];\n}\n\nfunction onTransitionEnd(elem, fn) {\n  var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : window;\n  var property = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var timeout = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\n  var element = getElement(elem);\n\n  var callback = fn.bind(context);\n  var timerId = void 0;\n\n  /**\n   * @param {TransitionEvent|{target: Element, currentTarget: Element}} evt Event object.\n   */\n\n  function transitionEnded(evt) {\n    // Some other element's transition event could have bubbled up to this.\n    // or\n    // If the optional property exists and it's not the property which was\n    // transitioned, exit out of the function and continue waiting for the\n    // right transition property.\n    if (!isOwnEvent(evt) || !isSameTransitionProperty(evt, property)) {\n      return;\n    }\n\n    // Remove from active transitions.\n    clearTransition(transitionId); // eslint-disable-line no-use-before-define\n\n    // If the browser has transitions, there will be a listener bound to the\n    // `transitionend` event which needs to be removed.\n    if (_odopod_odo_device__WEBPACK_IMPORTED_MODULE_0__[\"default\"].HAS_TRANSITIONS) {\n      evt.currentTarget.removeEventListener(events.TRANSITIONEND, transitionEnded);\n    }\n\n    // Done!\n    callback(evt);\n    clearTimeout(timerId);\n  }\n\n  if (_odopod_odo_device__WEBPACK_IMPORTED_MODULE_0__[\"default\"].HAS_TRANSITIONS) {\n    element.addEventListener(events.TRANSITIONEND, transitionEnded);\n\n    // Sometimes the transition end event doesn't fire, usually when\n    // properties don't change or when iOS decides to just snap instead of\n    // transition. To get around this, a timer is set which will trigger the\n    // fake event.\n    if (timeout) {\n      timerId = setTimeout(function () {\n        transitionEnded(getFakeEvent(element));\n      }, timeout);\n    }\n  } else {\n    // Push to the end of the queue with a fake event which will pass the checks\n    // inside the callback function.\n    timerId = setTimeout(function () {\n      transitionEnded(getFakeEvent(element));\n    }, 0);\n  }\n\n  // Save this active transition end listener so it can be canceled.\n  var transitionId = saveTransition(element, timerId, transitionEnded);\n\n  // Return id used to cancel the transition end listener, similar to setTimeout\n  // and requestAnimationFrame.\n  return transitionId;\n}\n\n/**\n * Fade out an element and then set visibilty hidden on it.\n * @param {Element} elem Element to fade.\n * @param {boolean} [isOut] Whether to fade out or in.\n * @param {Function} [fn=noop] Callback function when faded out.\n * @param {Window|HTMLElement} [context=window] Context for the callback.\n * @param {boolean} [invisible=false] Whether to add visibility:hidden to the\n *     element once it has faded out. Defaults to false.\n * @return {number} id used to cancel the transition end listener.\n */\nfunction fadeElement(elem, isOut) {\n  var fn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;\n  var context = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : window;\n  var invisible = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  var element = getElement(elem);\n\n  // Bind the context to the callback here so that the context and function\n  // references can be garbage collected and the only things left are `callback`\n  // and `invisible`.\n  var callback = fn.bind(context);\n\n  // Make sure the transition will actually happen.\n  // isIn and has `in` and `fade` classes or\n  // isIn but doesn't have `fade` or\n  // isOut and has `fade`, but doesn't have `in` class.\n  var hasIn = element.classList.contains(Classes.IN);\n  var hasFade = element.classList.contains(Classes.FADE);\n  if (!isOut && hasIn && hasFade || !isOut && !hasFade || isOut && !hasIn && hasFade) {\n    var fakeEvent = getFakeEvent(element);\n\n    // This is expected to be async.\n    setTimeout(function () {\n      callback(fakeEvent);\n    }, 0);\n\n    return 0;\n  }\n\n  /**\n   * Internal callback when the element has finished its transition.\n   * @param {{target: Element, currentTarget: Element}} evt Event object.\n   */\n  function faded(evt) {\n    // Element has faded out, add invisible class.\n    if (isOut && invisible) {\n      evt.currentTarget.classList.add(Classes.INVISIBLE);\n    }\n\n    callback(evt);\n  }\n\n  // Fading in, remove invisible class.\n  if (!isOut && invisible) {\n    elem.classList.remove(Classes.INVISIBLE);\n  }\n\n  // Make sure it has the \"fade\" class. It won't do anything if it already does.\n  elem.classList.add(Classes.FADE);\n\n  // Remove (or add) the \"in\" class which triggers the transition.\n  // If the element had neither of these classes, adding the \"fade\" class\n  // will trigger the transition.\n  elem.classList.toggle(Classes.IN, !isOut);\n\n  return onTransitionEnd(elem, faded, null, 'opacity');\n}\n\n/**\n * Fade in an element and optionally remove a class which sets visibility\n * to hidden.\n * @param {Element} elem Element to fade.\n * @param {Function} [fn=noop] Callback function when faded out.\n * @param {Window|HTMLElement} [context=window] Context for the callback.\n * @param {boolean} [invisible=false] Whether to add visibility:hidden to the\n *     element once it has faded. Defaults to false.\n */\nfunction fadeInElement(elem, fn, context, invisible) {\n  return fadeElement(elem, false, fn, context, invisible);\n}\n\n/**\n * Fade in an element and optionally add a class which sets visibility\n * to hidden.\n * @param {Element} elem Element to fade.\n * @param {Function} [fn=noop] Callback function when faded out.\n * @param {Window|HTMLElement} [context=window] Context for the callback.\n * @param {boolean} [invisible=false] Whether to add visibility:hidden to the\n *     element once it has faded. Defaults to false.\n */\nfunction fadeOutElement(elem, fn, context, invisible) {\n  return fadeElement(elem, true, fn, context, invisible);\n}\n\n/**\n * Force the page to be repainted.\n */\nfunction forceRedraw() {\n  var tempStyleSheet = document.createElement('style');\n  document.body.appendChild(tempStyleSheet);\n  document.body.removeChild(tempStyleSheet);\n}\n\n/**\n * Gets the height and with of an element when the display is not none.\n * @param {HTMLElement} element Element to get size of.\n * @return {!{width: number, height: number}} Object with width/height.\n */\nfunction getSize(element) {\n  return {\n    width: element.offsetWidth,\n    height: element.offsetHeight\n  };\n}\n\n/**\n * Parse string to return numerical value.\n * @param {string} value String of number\n * @return {number} Numerical value or 0 if parseFloat returns NaN\n */\nfunction getFloat(value) {\n  return parseFloat(value) || 0;\n}\n\nfunction getBox(element, property) {\n  var props = window.getComputedStyle(element, null);\n  return new Box(getFloat(props[property + 'Top']), getFloat(props[property + 'Right']), getFloat(props[property + 'Bottom']), getFloat(props[property + 'Left']));\n}\n\nfunction getMarginBox(element) {\n  return getBox(element, 'margin');\n}\n\n/**\n * Returns the size (width or height) of a list of elements, including margins.\n * @param {HTMLElement[]} elements An array of child elements (not a NodeList).\n * @param {string} dimension `'width'` or `'height'`.\n * @return {number}\n */\nfunction getElementsSize(elements, dimension) {\n  return elements.reduce(function (memo, el) {\n    var outerSize = getSize(el)[dimension];\n    var margins = getMarginBox(el);\n    var marginSize = dimension === 'height' ? margins.top + margins.bottom : margins.left + margins.right;\n\n    return memo + outerSize + marginSize;\n  }, 0);\n}\n\n/**\n * Detects the version of iOS operating system.\n * @param {string} userAgent The user agent string.\n * @return {number} iOS version. iOS 8.4.0, for example, will return `840`.\n */\nfunction getIOSVersion(userAgent) {\n  var iosUserAgent = userAgent.match(/OS\\s+([\\d_]+)/i);\n  var iosVersion = iosUserAgent[1].split('_');\n\n  // The iOS ua string doesn't include the patch version if it's zero.\n  if (iosVersion.length === 2) {\n    iosVersion[2] = '0';\n  }\n\n  return parseInt(iosVersion.reduce(function (str, number) {\n    return str + number;\n  }, ''), 10);\n}\n\n/**\n * Retrieves the nth sibling of an element, or null if the would be nth sibling\n * does not exist. Heads up! This function excludes text nodes.\n * @param {Element} node Element to start looking from.\n * @param {number} n An integer representing the desired element relative to\n *     `node`. For example, `2` would look for `node.nextSibling.nextSibling`.\n * @param {boolean=} optIsForward Whether to look forwards or backwards. Default is true.\n * @return {?Element} The nth sibling or null.\n */\nfunction getNthSibling(node, n, optIsForward) {\n  var isForward = optIsForward !== false;\n  var siblingCount = 0;\n  var sibling = node;\n  do {\n    sibling = isForward ? sibling.nextElementSibling : sibling.previousElementSibling;\n    siblingCount += 1;\n  } while (sibling && siblingCount < n);\n  return sibling;\n}\n\n/**\n * Parse a value as a number. If it's not numeric, then the default value will\n * be returned.\n * @param {*} value The option.\n * @param {*} defaultValue The fallback value.\n * @return {*} If value is numeric, value, else defaultValue.\n */\nfunction getNumberOption(value, defaultValue) {\n  var number = parseFloat(value);\n  return defaultsTo(number, defaultValue, !Number.isNaN(number));\n}\n\nfunction getPaddingBox(element) {\n  return getBox(element, 'padding');\n}\n\n/**\n * @param {*} value Anything.\n * @return {boolean}\n */\nfunction isString(value) {\n  return typeof value === 'string';\n}\n\n/**\n * Parse a value as a string. If it's not a string, then the default value\n * will be returned.\n * @param {*} value The option.\n * @param {*} defaultValue The fallback value.\n * @return {*} If value is a string, value, else defaultValue.\n */\nfunction getStringOption(value, defaultValue) {\n  return defaultsTo(value, defaultValue, isString(value));\n}\n\n/**\n * Parse a value as a percentage. If it's a string with '%' in it, it will\n * be parsed as a string, otherwise it will be parsed as a number.\n * @param {*} value The option.\n * @param {*} defaultValue The fallback value.\n * @return {*}\n */\nfunction getPercentageOption(value, defaultValue) {\n  if (isString(value) && value.indexOf('%') > -1) {\n    return getStringOption(value, defaultValue);\n  }\n\n  return getNumberOption(value, defaultValue);\n}\n\n/**\n * Ripped from: goog.testing.editor.dom.getRelativeDepth_.\n *\n * Returns the depth of the given node relative to the given parent node, or -1\n * if the given node is not a descendant of the given parent node. E.g. if\n * node == parentNode returns 0, if node.parentNode == parentNode returns 1,\n * etc.\n * @param {Node} node Node whose depth to get.\n * @param {Node} parentNode Node relative to which the depth should be\n *     calculated.\n * @return {number} The depth of the given node relative to the given parent\n *     node, or -1 if the given node is not a descendant of the given parent\n *     node.\n */\nfunction getRelativeDepth(node, parentNode) {\n  var depth = 0;\n  var child = node;\n  while (child) {\n    if (child === parentNode) {\n      return depth;\n    }\n\n    child = child.parentNode;\n    depth += 1;\n  }\n\n  return -1;\n}\n\n/**\n * Set an id on an element if one doesn't exist.\n * @param {Element} element Element to give an id.\n * @param {string|function(): string} fn Returns an id to set.\n */\nfunction giveId(element, fn) {\n  if (!element.id) {\n    element.id = typeof fn === 'function' ? fn() : fn;\n  }\n}\n\n/**\n * Detects the native Android Operating System.\n * @param {string} userAgent The user agent string.\n * @return {boolean}\n */\nfunction isAndroidOS(userAgent) {\n  return userAgent.includes('Mozilla/5.0') && userAgent.includes('Android ');\n}\n\n/**\n * Check for Microsoft Edge string.\n * @param {string} userAgent The user agent string.\n * @return {boolean}\n */\nfunction isEdge(userAgent) {\n  return userAgent.includes('Edge/');\n}\n\n/**\n * Detects all Google Chrome browsers.\n * @param {string} userAgent The user agent string.\n * @return {boolean}\n */\nfunction isChrome(userAgent) {\n  return !isEdge(userAgent) && userAgent.includes('Chrome');\n}\n\n/**\n * Whether the give user agent is from the stock Android browser.\n * @param {string} userAgent User agent string.\n * @return {boolean}\n */\nfunction isNativeAndroid(userAgent) {\n  return isAndroidOS(userAgent) && !isChrome(userAgent);\n}\n\n/**\n * Detects the iOS operating system.\n * @param {string} userAgent  The user agent string.\n * @return {boolean}\n */\nfunction isIOS(userAgent) {\n  return (/(iPad|iPhone|iPod)/g.test(userAgent)\n  );\n}\n\n/**\n * User agent test for IOS. Determines whether current version is < 8. Version 8\n * and higher allow javascript execution while scrolling.\n * @param {string} userAgent The user agent string.\n * @return {boolean}\n */\nfunction hasScrollEvents(userAgent) {\n  if (isIOS(userAgent)) {\n    return getIOSVersion(userAgent) >= 800;\n  }\n  return !isNativeAndroid(userAgent);\n}\n\n/**\n * Hyphenates a javascript style string to a css one. For example:\n * MozBoxSizing -> -moz-box-sizing.\n * @param {string|false} str The string to hyphenate.\n * @return {string} The hyphenated string.\n */\nfunction hyphenate(str) {\n  // Catch booleans.\n  if (!str) {\n    return '';\n  }\n\n  // Turn MozBoxSizing into -moz-box-sizing.\n  return str.replace(/([A-Z])/g, function (str, m1) {\n    return '-' + m1.toLowerCase();\n  }).replace(/^ms-/, '-ms-');\n}\n\n/**\n * Check for Microsoft Internet Explorer string.\n * @param {string} userAgent The user agent string.\n * @return {boolean}\n */\nfunction isIE(userAgent) {\n  return userAgent.includes('Trident/');\n}\n\n/**\n * Execute a callback when a css animation finishes.\n * @param {Element} elem The element which as an animation on it.\n * @param {Function} fn Callback function\n * @param {Object} [context=window] Optional context for the callback.\n */\nfunction onAnimationEnd(elem, fn) {\n  var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : window;\n\n  var element = getElement(elem);\n\n  var callback = fn.bind(context);\n\n  function animationEnded(evt) {\n    // Ensure the `animationend` event was from the element specified.\n    // Difficult to test without tracking callbacks.\n    /* istanbul ignore next */\n    if (!isOwnEvent(evt)) {\n      return;\n    }\n\n    // Remove the listener if it was bound.\n    if (_odopod_odo_device__WEBPACK_IMPORTED_MODULE_0__[\"default\"].HAS_CSS_ANIMATIONS) {\n      evt.currentTarget.removeEventListener(events.ANIMATIONEND, animationEnded);\n    }\n\n    callback(evt);\n  }\n\n  if (_odopod_odo_device__WEBPACK_IMPORTED_MODULE_0__[\"default\"].HAS_CSS_ANIMATIONS) {\n    element.addEventListener(events.ANIMATIONEND, animationEnded);\n  } else {\n    // Callback is expected to be async, so push it to the end of the queue.\n    setTimeout(function () {\n      animationEnded(getFakeEvent(element));\n    }, 0);\n  }\n}\n\n/**\n * Remove an item from an array.\n * @param {Array.<*>} arr An array.\n * @param {*} item Thing to remove from the array.\n * @return {?*} The item which was removed or null.\n */\nfunction pull(arr, item) {\n  var index = arr.indexOf(item);\n  if (index === -1) {\n    return null;\n  }\n\n  arr.splice(index, 1);\n  return item;\n}\n\n/**\n * Creates a random string for IDs, etc.\n * http://stackoverflow.com/a/8084248/995529\n * @return {string} Random string.\n */\nfunction random() {\n  return Math.random().toString(36).substring(7);\n}\n\nvar Rect = function () {\n  /**\n   * Class for representing rectangular regions.\n   * @param {number} x Left.\n   * @param {number} y Top.\n   * @param {number} w Width.\n   * @param {number} h Height.\n   * @constructor\n   */\n  function Rect(x, y, w, h) {\n    classCallCheck(this, Rect);\n\n    /**\n     * Left\n     * @type {number}\n     */\n    this.left = x;\n\n    /**\n     * Top\n     * @type {number}\n     */\n    this.top = y;\n\n    /**\n     * Width\n     * @type {number}\n     */\n    this.width = w;\n\n    /**\n     * Height\n     * @type {number}\n     */\n    this.height = h;\n  }\n\n  /**\n   * Right\n   * @type {number}\n   */\n\n\n  /**\n   * Returns whether two rectangles intersect. Two rectangles intersect if they\n   * touch at all, for example, two zero width and height rectangles would\n   * intersect if they had the same top and left.\n   * @param {Rect} a A Rectangle.\n   * @param {Rect} b A Rectangle.\n   * @return {boolean} Whether a and b intersect.\n   */\n  Rect.intersects = function intersects(a, b) {\n    return a.left <= b.right && b.left <= a.right && a.top <= b.bottom && b.top <= a.bottom;\n  };\n\n  createClass(Rect, [{\n    key: \"right\",\n    get: function get$$1() {\n      return this.left + this.width;\n    }\n\n    /**\n     * Bottom\n     * @type {number}\n     */\n\n  }, {\n    key: \"bottom\",\n    get: function get$$1() {\n      return this.top + this.height;\n    }\n  }]);\n  return Rect;\n}();\n\n/**\n * Removes all children from a parent node.\n * @param {Element} element Parent node.\n */\nfunction removeChildren(element) {\n  element.textContent = '';\n}\n\n/* istanbul ignore next */\nfunction normalizeHash(hash) {\n  if (typeof hash !== 'string') {\n    throw new Error('Hash must be of type string');\n  } else {\n    return hash.replace(/^#/, '');\n  }\n}\n\n/**\n * Updates the browser's hash\n * @param {string} newHash New hash, without `#`\n */\nfunction setHash(newHash) {\n  var hash = normalizeHash(newHash);\n  var st = void 0;\n\n  // When resetting the hash with `''`, the page will scroll back to the top,\n  // so we cache the current scroll position.\n  if (!hash) {\n    st = window.pageYOffset;\n  }\n\n  window.location.hash = hash;\n\n  // Scroll back to the position from before.\n  if (!hash) {\n    window.scrollTo(0, st);\n  }\n}\n\n/**\n * Updates the user's history with new hash\n * @param {string} newHash New hash, without `#`\n */\nfunction replaceWithHash(newHash) {\n  var hash = normalizeHash(newHash);\n  if (window.history.replaceState) {\n    hash = normalizeHash(hash);\n\n    // If resetting the hash, the whole path is needed. `''` doesn't work.\n    if (hash) {\n      hash = '#' + hash;\n    } else {\n      hash = window.location.pathname + window.location.search;\n    }\n\n    window.history.replaceState({}, null, hash);\n  } else {\n    setHash(hash);\n  }\n}\n\n/**\n * Scroll the page to a destination.\n * @param {number} [position] End scroll position.\n * @param {number} [duration] Duration in milliseconds.\n * @param {function:void} [callback] Optional callback.\n * @param {function(number):number} [easing] Easing function.\n */\nfunction scrollTo() {\n  var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 400;\n  var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;\n  var easing = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n\n  var options = {\n    start: window.pageYOffset,\n    end: position,\n    duration: duration,\n    step: function step(scrollTop) {\n      window.scrollTo(0, scrollTop);\n    }\n  };\n\n  // Avoid setting `easing` to `undefined`.\n  if (typeof easing === 'function') {\n    options.easing = easing;\n  }\n\n  var anim = new Stepper(options);\n  anim.onfinish = callback;\n  return anim;\n}\n\n/**\n * Swaps element1 with element2 in the DOM.\n * @param {Element} elm1 first element.\n * @param {Element} elm2 second element.\n */\nfunction swapElements(elm1, elm2) {\n  if (!elm1 || !elm2) {\n    return;\n  }\n\n  var parent1 = elm1.parentNode;\n  var next1 = elm1.nextSibling;\n  var parent2 = elm2.parentNode;\n  var next2 = elm2.nextSibling;\n\n  parent1.insertBefore(elm2, next1);\n  parent2.insertBefore(elm1, next2);\n}\n\nvar Timer = function () {\n  /**\n   * A simple timer class. The timer does not start automatically when\n   * initialized.\n   * @param {Function} fn Callback for when the timer expires.\n   * @param {number} delay Timer length in milliseconds.\n   * @param {boolean} [continuous] If true, the timer will automatically\n   *     restart itself when it expires.\n   * @constructor\n   */\n  function Timer(fn, delay) {\n    var continuous = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    classCallCheck(this, Timer);\n\n    this.timerId = null;\n    this.startTime = null;\n    this.isPaused = false;\n    this.isTicking = false;\n    this.isContinuous = continuous;\n    this.delay = delay;\n    this.remaining = delay;\n    this.fn = fn;\n\n    this.resume = this.start;\n    this.pause = this.stop;\n  }\n\n  /**\n   * Starts ticking the timer.\n   * @return {number|boolean} The remaining time or false if the timer is\n   *     already ticking.\n   */\n\n\n  Timer.prototype.start = function start() {\n    var _this = this;\n\n    if (this.isTicking) {\n      return false;\n    }\n\n    this.startTime = Date.now();\n    this.timerId = setTimeout(function () {\n      _this.fn();\n\n      // If the timer wasn't stopped in the callback and this is a continuous\n      // timer, start it again.\n      if (!_this.isPaused && _this.isContinuous) {\n        _this.restart();\n      } else {\n        _this.reset();\n      }\n    }, this.remaining);\n    this.isTicking = true;\n    this.isPaused = false;\n    return this.remaining;\n  };\n\n  /**\n   * Pauses the timer. Resuming will continue it with the remaining time.\n   * @return {number} Time remaining.\n   */\n\n\n  Timer.prototype.stop = function stop() {\n    this.clear();\n    this.remaining -= Date.now() - this.startTime;\n    this.isPaused = true;\n    this.isTicking = false;\n    return this.remaining;\n  };\n\n  /**\n   * Sets time remaining to initial delay and clears timer.\n   */\n\n\n  Timer.prototype.reset = function reset() {\n    this.remaining = this.delay;\n    this.clear();\n  };\n\n  /**\n   * Resets the timer to the original delay, clears the current timer, and\n   * starts the timer again.\n   */\n\n\n  Timer.prototype.restart = function restart() {\n    this.reset();\n    this.resume();\n  };\n\n  /**\n   * Clears timer.\n   */\n\n\n  Timer.prototype.clear = function clear() {\n    clearTimeout(this.timerId);\n    this.isPaused = false;\n    this.isTicking = false;\n  };\n\n  /**\n   * Destroy the timer.\n   */\n\n\n  Timer.prototype.dispose = function dispose() {\n    this.clear();\n    this.fn = null;\n  };\n\n  return Timer;\n}();\n\n/**\n * Calculates the offset index for a circular list.\n * @param {number} index Starting index.\n * @param {number} displacement Offset from the starting index. Can be negative\n *     or positive. For example, -2 or 2.\n * @param {number} length Length of the list.\n * @return {number} The index of the relative displacement, wrapping around\n *     the end of the list to the start when the displacement is larger than\n *     what's left in the list.\n */\nfunction wrapAroundList(index, displacement, length) {\n  return (index + displacement + length * 10) % length;\n}\n\n\n//# sourceMappingURL=odo-helpers.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG9kb3BvZC9vZG8taGVscGVycy9kaXN0L29kby1oZWxwZXJzLmVzbS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ab2RvcG9kL29kby1oZWxwZXJzL2Rpc3Qvb2RvLWhlbHBlcnMuZXNtLmpzPzQ0MzMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE9kb0RldmljZSBmcm9tICdAb2RvcG9kL29kby1kZXZpY2UnO1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55dGhpbmcuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGw7XG59XG5cbnZhciB0cmFuc2l0aW9ucyA9IHt9O1xudmFyIHRyYW5zaXRpb25JZCA9IDA7XG5cbi8qKlxuICogU3RvcmUgYSBwZW5kaW5nIHRyYW5zaXRpb24uXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgd2hpY2ggaGFzIHRoZSB0cmFuc2l0aW9uZW5kIGxpc3RlbmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVySWQgVGltZXIgaWQgZnJvbSBzZXRUaW1lb3V0IHRvIGNhbmNlbCB0aGUgdHJhbnNpdGlvbi5cbiAqIEBwYXJhbSB7KGV2dDogVHJhbnNpdGlvbkV2ZW50KSA9PiB2b2lkfSBsaXN0ZW5lciBDYWxsYmFjay5cbiAqIEByZXR1cm4ge251bWJlcn0gVHJhbnNpdGlvbiBpZC5cbiAqL1xuZnVuY3Rpb24gc2F2ZVRyYW5zaXRpb24oZWxlbWVudCwgdGltZXJJZCwgbGlzdGVuZXIpIHtcbiAgdHJhbnNpdGlvbklkICs9IDE7XG4gIHRyYW5zaXRpb25zW3RyYW5zaXRpb25JZF0gPSB7XG4gICAgZWxlbWVudDogZWxlbWVudCxcbiAgICB0aW1lcklkOiB0aW1lcklkLFxuICAgIGxpc3RlbmVyOiBsaXN0ZW5lclxuICB9O1xuICByZXR1cm4gdHJhbnNpdGlvbklkO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhIHRyYW5zaXRpb24gaWQgZnJvbSB0aGUgc3RvcmVkIGxpc3QuXG4gKiBAcGFyYW0ge251bWJlcn0gdHJhbnNpdGlvbklkIFRyYW5zaXRpb24gaWQgdG8gcmVtb3ZlLlxuICovXG5mdW5jdGlvbiBjbGVhclRyYW5zaXRpb24odHJhbnNpdGlvbklkKSB7XG4gIGRlbGV0ZSB0cmFuc2l0aW9uc1t0cmFuc2l0aW9uSWRdO1xufVxuXG4vKipcbiAqIFJldHJpZXZlIGEgdHJhbnNpdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge251bWJlcn0gdHJhbnNpdGlvbklkIFRyYW5zaXRpb24gaWQgdG8gcmV0cmlldmUuXG4gKiBAcmV0dXJuIHt7ZWxlbWVudDogSFRNTEVsZW1lbnQsIHRpbWVySWQ6IG51bWJlciwgbGlzdGVuZXI6IChldnQ6IFRyYW5zaXRpb25FdmVudCkgPT4gdm9pZH19XG4gKiAgIFRyYW5zaXRpb24gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uKHRyYW5zaXRpb25JZCkge1xuICByZXR1cm4gdHJhbnNpdGlvbnNbdHJhbnNpdGlvbklkXTtcbn1cblxuLyoqXG4gKiBSZXRyaWV2ZSBhbGwgdHJhbnNpdGlvbiBvYmplY3RzLlxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9ucygpIHtcbiAgcmV0dXJuIHRyYW5zaXRpb25zO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGVsZW1lbnQgd2hlbiB0aGUgZmlyc3QgcGFyYW1ldGVyIGlzIGEgalF1ZXJ5IGNvbGxlY3Rpb24uXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fGpRdWVyeX0gZWxlbSBBbiBlbGVtZW50IG9yIGEgalF1ZXJ5IGNvbGxlY3Rpb24uXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBpdCdzIGEgalF1ZXJ5IGNvbGxlY3Rpb24gb2YgbW9yZSB0aGFuIG9uZSBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBnZXRFbGVtZW50KGVsZW0pIHtcbiAgaWYgKGVsZW0uanF1ZXJ5KSB7XG4gICAgaWYgKGVsZW0ubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcyBtZXRob2Qgb25seSBzdXBwb3J0cyB0cmFuc2l0aW9uIGVuZCBmb3Igb25lIGVsZW1lbnQsIG5vdCBhIGNvbGxlY3Rpb24nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbVswXTtcbiAgfVxuXG4gIHJldHVybiBlbGVtO1xufVxuXG5mdW5jdGlvbiBpc093bkV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC50YXJnZXQgPT09IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG59XG5cbmZ1bmN0aW9uIGlzU2FtZVRyYW5zaXRpb25Qcm9wZXJ0eShldmVudCwgcHJvcCkge1xuICByZXR1cm4gZXZlbnQuZmFrZSB8fCAhaXNEZWZpbmVkKHByb3ApIHx8IGV2ZW50LnByb3BlcnR5TmFtZSA9PT0gcHJvcDtcbn1cblxuZnVuY3Rpb24gZ2V0RmFrZUV2ZW50KGVsZW0pIHtcbiAgcmV0dXJuIHtcbiAgICB0YXJnZXQ6IGVsZW0sXG4gICAgY3VycmVudFRhcmdldDogZWxlbSxcbiAgICBmYWtlOiB0cnVlXG4gIH07XG59XG5cbnZhciBDbGFzc2VzID0ge1xuICBGQURFOiAnZmFkZScsXG4gIElOOiAnaW4nLFxuICBJTlZJU0lCTEU6ICdpbnZpc2libGUnXG59O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxudmFyIGNsYXNzQ2FsbENoZWNrID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cbnZhciBjcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEEgc2ltcGxlIGNsYXNzIGZvciBwcm92aWRpbmcgYSBzdGVwcGluZyBmdW5jdGlvbiBmb3IgZWFjaFxuICogYW5pbWF0aW9uIGZyYW1lIG92ZXIgYSBnaXZlbiBsZW5ndGggb2YgdGltZS4gVXNlcyByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAqIHdoZXJlIGF2YWlsYWJsZS4gSXRzIEFQSSBpcyBzaW1pbGFyIHRvIHRoZSBBbmltYXRpb25QbGF5ZXIgaW4gYEVsZW1lbnQuYW5pbWF0ZWAuXG4gKlxuICogQXNzdW1lcyBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCwgYEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kYCwgYW5kIGBPYmplY3QuYXNzaWduYFxuICogYXJlIGF2YWlsYWJsZS5cbiAqXG4gKiBAYXV0aG9yIEdsZW4gQ2hlbmV5IDxnbGVuQG9kb3BvZC5jb20+XG4gKi9cblxudmFyIFN0ZXBwZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBFYXN5IGFuaW1hdGlvbiBzdGVwcGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3RhcnRdIFN0YXJ0aW5nIG51bWJlci4gVmFsdWUgdG8gYW5pbWF0ZSBmcm9tLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZW5kXSBFbmRpbmcgbnVtYmVyLiBWYWx1ZSB0byBhbmltYXRlIHRvLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlciwgbnVtYmVyKTp2b2lkfSBbb3B0aW9ucy5zdGVwXSBTdGVwIGZ1bmN0aW9uIHdoaWNoXG4gICAqICAgICB3aWxsIHJlY2VpdmUgdGhlIHN0ZXAgdmFsdWUgYW5kIHRoZSBjdXJyZW50IHBlcmNlbnRhZ2UgY29tcGxldGVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZHVyYXRpb25dIExlbmd0aCBvZiB0aGUgYW5pbWF0aW9uLiBEZWZhdWx0IGlzIDI1MG1zLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuY29udGV4dF0gVGhlIG9iamVjdCBzY29wZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIGluLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlcik6bnVtYmVyfSBbb3B0aW9ucy5lYXNpbmddIEVhc2luZyBmdW5jdGlvbiB0byBhcHBseS5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBTdGVwcGVyKG9wdGlvbnMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTdGVwcGVyKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIFN0ZXBwZXIuRGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBlcmNlbnRhZ2UgdmFsdWUgd2hpY2ggdGhlIHNjcnViYmVyIGFuZCByZXZlYWxzIHdpbGwgYmUgYW5pbWF0ZWQgdG8uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2FuaW1hdGlvbkFtb3VudCA9IHRoaXMub3B0aW9ucy5lbmQgLSB0aGlzLm9wdGlvbnMuc3RhcnQ7XG5cbiAgICAvKipcbiAgICAgKiBUaW1lIHdoZW4gdGhlIGFuaW1hdGlvbiB0aW1lciBzdGFydGVkLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9hbmltYXRpb25TdGFydCA9ICtuZXcgRGF0ZSgpO1xuXG4gICAgdGhpcy5faGFuZGxlciA9IHRoaXMuX2FuaW1hdGVMb29wLmJpbmQodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYXQgdGhlIGVuZCBvZiB0aGUgYW5pbWF0aW9uIHdpdGggYG9wdGlvbnMuY29udGV4dGAuXG4gICAgICogQHR5cGUge2Z1bmN0aW9uOnZvaWR9XG4gICAgICovXG4gICAgdGhpcy5vbmZpbmlzaCA9IG5vb3A7XG5cbiAgICAvLyBTdGFydCBsb29wLlxuICAgIHRoaXMuX3JlcXVlc3RJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9oYW5kbGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBsb29wIHRpY2tlci5cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBTdGVwcGVyLnByb3RvdHlwZS5fYW5pbWF0ZUxvb3AgPSBmdW5jdGlvbiBfYW5pbWF0ZUxvb3AoKSB7XG4gICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIHZhciByZW1haW5pbmdUaW1lID0gdGhpcy5fYW5pbWF0aW9uU3RhcnQgKyB0aGlzLm9wdGlvbnMuZHVyYXRpb24gLSBub3c7XG5cbiAgICAvLyBFdmVuIHdoZW4gZHVyYXRpb24gaXMgemVybywgdGhpcyB3aWxsIHJlc3VsdCBpbiBJbmZpbml0eSwgd2hpY2ggd2lsbCBvbmx5XG4gICAgLy8gY2FsbCB0aGUgc3RlcCBtZXRob2Qgb25jZSB0aGVuIG9uZmluaXNoLCB3aGljaCBpcyBkZXNpcmVkLlxuICAgIHZhciBwZXJjZW50ID0gMSAtIHJlbWFpbmluZ1RpbWUgLyB0aGlzLm9wdGlvbnMuZHVyYXRpb247XG5cbiAgICAvLyBBYm9ydCBpZiBhbHJlYWR5IGF0IG9yIHBhc3QgMTAwJS5cbiAgICBpZiAocGVyY2VudCA+PSAxKSB7XG4gICAgICAvLyBNYWtlIHN1cmUgaXQgYWx3YXlzIGZpbmlzaGVzIHdpdGggMS5cbiAgICAgIHRoaXMub3B0aW9ucy5zdGVwLmNhbGwodGhpcy5vcHRpb25zLmNvbnRleHQsIHRoaXMub3B0aW9ucy5lbmQsIDEpO1xuICAgICAgdGhpcy5vbmZpbmlzaC5jYWxsKHRoaXMub3B0aW9ucy5jb250ZXh0KTtcbiAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEFwcGx5IGVhc2luZy5cbiAgICBwZXJjZW50ID0gdGhpcy5vcHRpb25zLmVhc2luZyhwZXJjZW50KTtcblxuICAgIC8vIFJlcXVlc3QgYW5pbWF0aW9uIGZyYW1lLlxuICAgIHRoaXMuX3JlcXVlc3RJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9oYW5kbGVyKTtcblxuICAgIC8vIFRpY2suXG4gICAgdGhpcy5vcHRpb25zLnN0ZXAuY2FsbCh0aGlzLm9wdGlvbnMuY29udGV4dCwgdGhpcy5vcHRpb25zLnN0YXJ0ICsgdGhpcy5fYW5pbWF0aW9uQW1vdW50ICogcGVyY2VudCwgcGVyY2VudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0b3AgdGhlIGFuaW1hdGlvbiBhbmQgZGlzcG9zZSBvZiBpdC5cbiAgICovXG5cblxuICBTdGVwcGVyLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fcmVxdWVzdElkKTtcbiAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgfTtcblxuICAvKipcbiAgICogRGVzdHJveSB0aGUgYW5pbWF0aW9uIGluc3RhbmNlLlxuICAgKi9cblxuXG4gIFN0ZXBwZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIHRoaXMuX2hhbmRsZXIgPSBudWxsO1xuICAgIHRoaXMub3B0aW9ucy5jb250ZXh0ID0gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gU3RlcHBlcjtcbn0oKTtcblxuU3RlcHBlci5EZWZhdWx0cyA9IHtcbiAgc3RhcnQ6IDAsXG4gIGVuZDogMSxcbiAgZHVyYXRpb246IDI1MCxcbiAgc3RlcDogbm9vcCxcbiAgY29udGV4dDogd2luZG93LFxuICBlYXNpbmc6IGZ1bmN0aW9uIGVhc2luZyhrKSB7XG4gICAgcmV0dXJuIC0wLjUgKiAoTWF0aC5jb3MoTWF0aC5QSSAqIGspIC0gMSk7XG4gIH1cbn07XG5cbnZhciBCb3ggPVxuLyoqXG4gKiBDbGFzcyBmb3IgcmVwcmVzZW50aW5nIGEgYm94LiBBIGJveCBpcyBzcGVjaWZpZWQgYXMgYSB0b3AsIHJpZ2h0LCBib3R0b20sXG4gKiBhbmQgbGVmdC4gQSBib3ggaXMgdXNlZnVsIGZvciByZXByZXNlbnRpbmcgbWFyZ2lucyBhbmQgcGFkZGluZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3AgVG9wLlxuICogQHBhcmFtIHtudW1iZXJ9IHJpZ2h0IFJpZ2h0LlxuICogQHBhcmFtIHtudW1iZXJ9IGJvdHRvbSBCb3R0b20uXG4gKiBAcGFyYW0ge251bWJlcn0gbGVmdCBMZWZ0LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEJveCh0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQpIHtcbiAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQm94KTtcblxuICAvKipcbiAgICogVG9wXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLnRvcCA9IHRvcDtcblxuICAvKipcbiAgICogUmlnaHRcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRoaXMucmlnaHQgPSByaWdodDtcblxuICAvKipcbiAgICogQm90dG9tXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLmJvdHRvbSA9IGJvdHRvbTtcblxuICAvKipcbiAgICogTGVmdFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5sZWZ0ID0gbGVmdDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcHJlZml4ZWQgb3IgdW5wcmVmaXhlZCBwb2ludGVyIGV2ZW50IG5hbWUgb3IgbnVsbCBpZiBub3QgcG9pbnRlciBldmVudHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgVGhlIGV2ZW50IG5hbWUuIGUuZy4gXCJwb2ludGVyZG93blwiLlxuICogQHJldHVybiB7P3N0cmluZ30gVGhlIGV2ZW50IG5hbWUgb3IgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZ2V0UG9pbnRlckV2ZW50KGV2ZW50KSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChPZG9EZXZpY2UuSEFTX1BPSU5URVJfRVZFTlRTKSB7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIG5vcm1hbGl6ZWQgdHJhbnNpdGlvbiBlbmQgZXZlbnQgbmFtZS5cbiAqXG4gKiBJc3N1ZSB3aXRoIE1vZGVybml6ciBwcmVmaXhpbmcgcmVsYXRlZCB0byBzdG9jayBBbmRyb2lkIDQuMS4yXG4gKiBUaGF0IHZlcnNpb24gb2YgQW5kcm9pZCBoYXMgYm90aCB1bnByZWZpeGVkIGFuZCBwcmVmaXhlZCB0cmFuc2l0aW9uc1xuICogYnVpbHQgaW4sIGJ1dCB3aWxsIG9ubHkgbGlzdGVuIHRvIHRoZSBwcmVmaXhlZCBvbiBpbiBjZXJ0YWluIGNhc2VzXG4gKiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9pc3N1ZXMvODk3XG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBBIHBhdGNoZWQgdHJhbnNpdGlvbiBlbmQgZXZlbnQgbmFtZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkVuZEV2ZW50KCkge1xuICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRpdi5zdHlsZS50cmFuc2l0aW9uUHJvcGVydHkgPSAnd2lkdGgnO1xuXG4gIC8vIFRlc3QgdGhlIHZhbHVlIHdoaWNoIHdhcyBqdXN0IHNldC4gSWYgaXQgd2Fzbid0IGFibGUgdG8gYmUgc2V0LFxuICAvLyB0aGVuIGl0IHNob3VsZG4ndCB1c2UgdW5wcmVmaXhlZCB0cmFuc2l0aW9ucy5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKGRpdi5zdHlsZS50cmFuc2l0aW9uUHJvcGVydHkgIT09ICd3aWR0aCcgJiYgJ3dlYmtpdFRyYW5zaXRpb24nIGluIGRpdi5zdHlsZSkge1xuICAgIHJldHVybiAnd2Via2l0VHJhbnNpdGlvbkVuZCc7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC8vIFNhZiA8IDcsIEFuZHJvaWQgQnJvd3NlciA8IDQuNFxuICAgIFdlYmtpdFRyYW5zaXRpb246ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcbiAgICB0cmFuc2l0aW9uOiAndHJhbnNpdGlvbmVuZCdcbiAgfVtPZG9EZXZpY2UuRG9tLlRSQU5TSVRJT05dO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBub3JtYWxpemVkIGFuaW1hdGlvbiBlbmQgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0QW5pbWF0aW9uRW5kRXZlbnQoKSB7XG4gIHJldHVybiB7XG4gICAgV2Via2l0QW5pbWF0aW9uOiAnd2Via2l0QW5pbWF0aW9uRW5kJyxcbiAgICBhbmltYXRpb246ICdhbmltYXRpb25lbmQnXG4gIH1bT2RvRGV2aWNlLkRvbS5BTklNQVRJT05dO1xufVxuXG52YXIgZXZlbnRzID0ge1xuICAvLyBNb3VzZSBldmVudHNcbiAgQ0xJQ0s6ICdjbGljaycsXG4gIERCTENMSUNLOiAnZGJsY2xpY2snLFxuICBNT1VTRURPV046ICdtb3VzZWRvd24nLFxuICBNT1VTRVVQOiAnbW91c2V1cCcsXG4gIE1PVVNFT1ZFUjogJ21vdXNlb3ZlcicsXG4gIE1PVVNFT1VUOiAnbW91c2VvdXQnLFxuICBNT1VTRU1PVkU6ICdtb3VzZW1vdmUnLFxuXG4gIC8vIElFLCBTYWZhcmksIENocm9tZVxuICBTRUxFQ1RTVEFSVDogJ3NlbGVjdHN0YXJ0JyxcblxuICAvLyBLZXkgZXZlbnRzXG4gIEtFWVBSRVNTOiAna2V5cHJlc3MnLFxuICBLRVlET1dOOiAna2V5ZG93bicsXG4gIEtFWVVQOiAna2V5dXAnLFxuXG4gIC8vIEZvY3VzXG4gIEJMVVI6ICdibHVyJyxcbiAgRk9DVVM6ICdmb2N1cycsXG5cbiAgLy8gSUUgb25seVxuICBERUFDVElWQVRFOiAnZGVhY3RpdmF0ZScsXG5cbiAgRk9DVVNJTjogJ2ZvY3VzaW4nLFxuICBGT0NVU09VVDogJ2ZvY3Vzb3V0JyxcblxuICAvLyBGb3Jtc1xuICBDSEFOR0U6ICdjaGFuZ2UnLFxuICBTRUxFQ1Q6ICdzZWxlY3QnLFxuICBTVUJNSVQ6ICdzdWJtaXQnLFxuICBJTlBVVDogJ2lucHV0JyxcblxuICAvLyBJRSBvbmx5XG4gIFBST1BFUlRZQ0hBTkdFOiAncHJvcGVydHljaGFuZ2UnLFxuXG4gIC8vIERyYWcgYW5kIGRyb3BcbiAgRFJBR1NUQVJUOiAnZHJhZ3N0YXJ0JyxcbiAgRFJBRzogJ2RyYWcnLFxuICBEUkFHRU5URVI6ICdkcmFnZW50ZXInLFxuICBEUkFHT1ZFUjogJ2RyYWdvdmVyJyxcbiAgRFJBR0xFQVZFOiAnZHJhZ2xlYXZlJyxcbiAgRFJPUDogJ2Ryb3AnLFxuICBEUkFHRU5EOiAnZHJhZ2VuZCcsXG5cbiAgLy8gV2ViS2l0IHRvdWNoIGV2ZW50cy5cbiAgVE9VQ0hTVEFSVDogJ3RvdWNoc3RhcnQnLFxuICBUT1VDSE1PVkU6ICd0b3VjaG1vdmUnLFxuICBUT1VDSEVORDogJ3RvdWNoZW5kJyxcbiAgVE9VQ0hDQU5DRUw6ICd0b3VjaGNhbmNlbCcsXG5cbiAgLy8gTWlzY1xuICBCRUZPUkVVTkxPQUQ6ICdiZWZvcmV1bmxvYWQnLFxuICBDT05URVhUTUVOVTogJ2NvbnRleHRtZW51JyxcbiAgRVJST1I6ICdlcnJvcicsXG4gIEhFTFA6ICdoZWxwJyxcbiAgTE9BRDogJ2xvYWQnLFxuICBMT1NFQ0FQVFVSRTogJ2xvc2VjYXB0dXJlJyxcbiAgUkVBRFlTVEFURUNIQU5HRTogJ3JlYWR5c3RhdGVjaGFuZ2UnLFxuICBSRVNJWkU6ICdyZXNpemUnLFxuICBTQ1JPTEw6ICdzY3JvbGwnLFxuICBVTkxPQUQ6ICd1bmxvYWQnLFxuXG4gIC8vIEhUTUwgNSBIaXN0b3J5IGV2ZW50c1xuICAvLyBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaGlzdG9yeS5odG1sI2V2ZW50LWRlZmluaXRpb25zXG4gIEhBU0hDSEFOR0U6ICdoYXNoY2hhbmdlJyxcbiAgUEFHRUhJREU6ICdwYWdlaGlkZScsXG4gIFBBR0VTSE9XOiAncGFnZXNob3cnLFxuICBQT1BTVEFURTogJ3BvcHN0YXRlJyxcblxuICAvLyBDb3B5IGFuZCBQYXN0ZVxuICAvLyBTdXBwb3J0IGlzIGxpbWl0ZWQuIE1ha2Ugc3VyZSBpdCB3b3JrcyBvbiB5b3VyIGZhdm9yaXRlIGJyb3dzZXJcbiAgLy8gYmVmb3JlIHVzaW5nLlxuICAvLyBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2RvbS9ldmVudHMvY3V0Y29weXBhc3RlLmh0bWxcbiAgQ09QWTogJ2NvcHknLFxuICBQQVNURTogJ3Bhc3RlJyxcbiAgQ1VUOiAnY3V0JyxcbiAgQkVGT1JFQ09QWTogJ2JlZm9yZWNvcHknLFxuICBCRUZPUkVDVVQ6ICdiZWZvcmVjdXQnLFxuICBCRUZPUkVQQVNURTogJ2JlZm9yZXBhc3RlJyxcblxuICAvLyBIVE1MNSBvbmxpbmUvb2ZmbGluZSBldmVudHMuXG4gIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL29mZmxpbmUtd2ViYXBwcy8jcmVsYXRlZFxuICBPTkxJTkU6ICdvbmxpbmUnLFxuICBPRkZMSU5FOiAnb2ZmbGluZScsXG5cbiAgLy8gSFRNTCA1IHdvcmtlciBldmVudHNcbiAgTUVTU0FHRTogJ21lc3NhZ2UnLFxuICBDT05ORUNUOiAnY29ubmVjdCcsXG5cbiAgLy8gQ3NzIHRyYW5zaXRpb24gZXZlbnRzLlxuICBUUkFOU0lUSU9ORU5EOiBnZXRUcmFuc2l0aW9uRW5kRXZlbnQoKSxcblxuICBBTklNQVRJT05FTkQ6IGdldEFuaW1hdGlvbkVuZEV2ZW50KCksXG5cbiAgLy8gUG9pbnRlciBldmVudHNcbiAgUE9JTlRFUkNBTkNFTDogZ2V0UG9pbnRlckV2ZW50KCdwb2ludGVyY2FuY2VsJyksXG4gIFBPSU5URVJET1dOOiBnZXRQb2ludGVyRXZlbnQoJ3BvaW50ZXJkb3duJyksXG4gIFBPSU5URVJNT1ZFOiBnZXRQb2ludGVyRXZlbnQoJ3BvaW50ZXJtb3ZlJyksXG4gIFBPSU5URVJPVkVSOiBnZXRQb2ludGVyRXZlbnQoJ3BvaW50ZXJvdmVyJyksXG4gIFBPSU5URVJPVVQ6IGdldFBvaW50ZXJFdmVudCgncG9pbnRlcm91dCcpLFxuICBQT0lOVEVSVVA6IGdldFBvaW50ZXJFdmVudCgncG9pbnRlcnVwJylcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBldmVudCBsaXN0ZW5lciBmb3IgYHRyYW5zaXRpb25lbmRgLlxuICogQHBhcmFtIHtudW1iZXJ9IGlkIFRoZSBudW1iZXIgcmV0dXJuZWQgYnkgYG9uVHJhbnNpdGlvbkVuZGAuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB0cmFuc2l0aW9uIHdhcyBjYW5jZWxlZCBvciBub3QuIElmIHRoZSB0cmFuc2l0aW9uXG4gKiAgICAgYWxyZWFkeSBmaW5pc2hlZCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gZmFsc2UuXG4gKi9cbmZ1bmN0aW9uIGNhbmNlbFRyYW5zaXRpb25FbmQoaWQpIHtcbiAgdmFyIG9iaiA9IGdldFRyYW5zaXRpb24oaWQpO1xuXG4gIGlmIChvYmopIHtcbiAgICBjbGVhclRpbWVvdXQob2JqLnRpbWVySWQpO1xuXG4gICAgaWYgKE9kb0RldmljZS5IQVNfVFJBTlNJVElPTlMpIHtcbiAgICAgIG9iai5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRzLlRSQU5TSVRJT05FTkQsIG9iai5saXN0ZW5lcik7XG4gICAgfVxuXG4gICAgY2xlYXJUcmFuc2l0aW9uKGlkKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ2FwaXRhbGl6ZSBhIHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGNhcGl0YWxpemUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IENhcGl0YWxpemVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn1cblxuLyoqXG4gKiBBc2sgdGhlIGJyb3dzZXIgZm9yIGEgcHJvcGVydHkgdGhhdCB3aWxsIGNhdXNlIGl0IHRvIHJlY2FsY3VsYXRlIHN0eWxlc1xuICogYW5kIGxheW91dCB0aGUgZWxlbWVudCAoYW5kIHBvc3NpYmx5IHN1cnJvdW5kaW5nL3BhcmVudCBlbGVtZW50cykuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gZm9yIGEgbGF5b3V0IGZvci5cbiAqIEByZXR1cm4ge251bWJlcn0gV2lkdGggb2YgdGhlIGVsZW1lbnQuIElmIHlvdSBhY3R1YWxseSBuZWVkIHRoZSB3aWR0aCBvZlxuICogICAgIGVsZW1lbnQsIHVzZSB0aGUgYHN0eWxlLmdldFNpemVgIG1ldGhvZC5cbiAqL1xuZnVuY3Rpb24gY2F1c2VMYXlvdXQoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC5vZmZzZXRXaWR0aDtcbn1cblxuLyoqXG4gKiBNYWtlIGFuIGFycmF5IG9mIHNtYWxsZXIgYXJyYXlzIGZyb20gYW4gYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5LjwqPn0gYXJyYXkgQW4gYXJyYXkgdG8gdGFrZSBjaHVua3MgZnJvbS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIFRoZSBudW1iZXIgb2YgaXRlbXMgcGVyIGNodW5rLlxuICogQHJldHVybiB7QXJyYXkuPEFycmF5LjwqPj59XG4gKi9cbmZ1bmN0aW9uIGNodW5rKGFycmF5LCBzaXplKSB7XG4gIGlmICghc2l6ZSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBudW1BcnJheXMgPSBNYXRoLmNlaWwoYXJyYXkubGVuZ3RoIC8gc2l6ZSk7XG4gIHZhciBjaHVua2VkID0gbmV3IEFycmF5KG51bUFycmF5cyk7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBsdXNwbHVzXG4gIGZvciAodmFyIGkgPSAwLCBpbmRleCA9IDA7IGkgPCBudW1BcnJheXM7IGluZGV4ICs9IHNpemUsIGkrKykge1xuICAgIGNodW5rZWRbaV0gPSBhcnJheS5zbGljZShpbmRleCwgaW5kZXggKyBzaXplKTtcbiAgfVxuXG4gIHJldHVybiBjaHVua2VkO1xufVxuXG4vKipcbiAqIFRha2VzIGEgbnVtYmVyIGFuZCBjbGFtcHMgaXQgdG8gd2l0aGluIHRoZSBwcm92aWRlZCBib3VuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGlucHV0IG51bWJlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmltdW0gdmFsdWUgdG8gcmV0dXJuLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSB2YWx1ZSB0byByZXR1cm4uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbnB1dCBudW1iZXIgaWYgaXQgaXMgd2l0aGluIGJvdW5kcywgb3IgdGhlIG5lYXJlc3RcbiAqICAgICBudW1iZXIgd2l0aGluIHRoZSBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNsYW1wKHZhbHVlLCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIG1pbiksIG1heCk7XG59XG5cbi8qKlxuICogR2l2ZW4gYW4gYXJyYXkgb2YgbnVtYmVycyAoYGFycmApLCBmaW5kIHRoZSBpdGVtIGluIHRoZSBhcnJheSBjbG9zZXN0XG4gKiB0byBhIGdpdmVuIG51bWJlciAoYG51bWApLlxuICpcbiAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSBhcnIgQW4gYXJyYXkgb2YgbnVtYmVycy5cbiAqIEBwYXJhbSAge251bWJlcn0gbnVtIENsb3NlIG51bWJlciB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm4gez9udW1iZXJ9IFRoZSBjbG9zZXN0IG51bWJlciBpbiB0aGUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNsb3Nlc3QoYXJyLCBudW0pIHtcbiAgdmFyIGNsb3Nlc3QgPSBudWxsO1xuXG4gIGFyci5yZWR1Y2UoZnVuY3Rpb24gKGNsb3Nlc3REaWZmLCB2YWx1ZSkge1xuICAgIHZhciBkaWZmID0gTWF0aC5hYnModmFsdWUgLSBudW0pO1xuICAgIGlmIChkaWZmIDwgY2xvc2VzdERpZmYpIHtcbiAgICAgIGNsb3Nlc3QgPSB2YWx1ZTtcbiAgICAgIHJldHVybiBkaWZmO1xuICAgIH1cblxuICAgIHJldHVybiBjbG9zZXN0RGlmZjtcbiAgfSwgSW5maW5pdHkpO1xuXG4gIHJldHVybiBjbG9zZXN0O1xufVxuXG4vKipcbiAqIEdpdmVuIGFuIGFycmF5IG9mIG51bWJlcnMgKGBhcnJgKSwgZmluZCB0aGUgaXRlbSBpbiB0aGUgYXJyYXkgY2xvc2VzdFxuICogdG8gYSBnaXZlbiBudW1iZXIgKGBudW1gKSwgd2hpbGUgYWxzbyBncmVhdGVyIHRoYW4gKGBudW1gKS5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gYXJyIEFuIGFycmF5IG9mIG51bWJlcnMuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IG51bSBDbG9zZSBudW1iZXIgdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJuIHs/bnVtYmVyfSBUaGUgY2xvc2VzdCBudW1iZXIgaW4gdGhlIGFycmF5LlxuICovXG5mdW5jdGlvbiBjbG9zZXN0R3JlYXRlclRoYW4oYXJyLCBudW0pIHtcbiAgcmV0dXJuIGNsb3Nlc3QoYXJyLmZpbHRlcihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPiBudW07XG4gIH0pLCBudW0pO1xufVxuXG4vKipcbiAqIEdpdmVuIGFuIGFycmF5IG9mIG51bWJlcnMgKGBhcnJgKSwgZmluZCB0aGUgaXRlbSBpbiB0aGUgYXJyYXkgY2xvc2VzdFxuICogdG8gYSBnaXZlbiBudW1iZXIgKGBudW1gKSwgd2hpbGUgYWxzbyBsZXNzIHRoYW4gKGBudW1gKS5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gYXJyIEFuIGFycmF5IG9mIG51bWJlcnMuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IG51bSBDbG9zZSBudW1iZXIgdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJuIHs/bnVtYmVyfSBUaGUgY2xvc2VzdCBudW1iZXIgaW4gdGhlIGFycmF5LlxuICovXG5mdW5jdGlvbiBjbG9zZXN0TGVzc1RoYW4oYXJyLCBudW0pIHtcbiAgcmV0dXJuIGNsb3Nlc3QoYXJyLmZpbHRlcihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPCBudW07XG4gIH0pLCBudW0pO1xufVxuXG52YXIgQ29vcmRpbmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENsYXNzIGZvciByZXByZXNlbnRpbmcgY29vcmRpbmF0ZXMgYW5kIHBvc2l0aW9ucy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdIExlZnQsIGRlZmF1bHRzIHRvIDAuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSBUb3AsIGRlZmF1bHRzIHRvIDAuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gQ29vcmRpbmF0ZSgpIHtcbiAgICB2YXIgeCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICB2YXIgeSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDb29yZGluYXRlKTtcblxuICAgIC8qKlxuICAgICAqIFgtdmFsdWVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMueCA9IHg7XG5cbiAgICAvKipcbiAgICAgKiBZLXZhbHVlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnkgPSB5O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBkdXBsaWNhdGUgb2YgdGhpcyBjb29yZGluYXRlLlxuICAgKiBAcmV0dXJuIHtDb29yZGluYXRlfVxuICAgKi9cblxuXG4gIENvb3JkaW5hdGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBDb29yZGluYXRlKHRoaXMueCwgdGhpcy55KTtcbiAgfTtcblxuICAvKipcbiAgICogU2NhbGVzIHRoaXMgY29vcmRpbmF0ZSBieSB0aGUgZ2l2ZW4gc2NhbGUgZmFjdG9ycy4gVGhlIHggYW5kIHkgdmFsdWVzIGFyZVxuICAgKiBzY2FsZWQgYnkge0Bjb2RlIHN4fSBhbmQge0Bjb2RlIG9wdFN5fSByZXNwZWN0aXZlbHkuICBJZiB7QGNvZGUgb3B0U3l9XG4gICAqIGlzIG5vdCBnaXZlbiwgdGhlbiB7QGNvZGUgc3h9IGlzIHVzZWQgZm9yIGJvdGggeCBhbmQgeS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN4IFRoZSBzY2FsZSBmYWN0b3IgdG8gdXNlIGZvciB0aGUgeCBkaW1lbnNpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0U3kgVGhlIHNjYWxlIGZhY3RvciB0byB1c2UgZm9yIHRoZSB5IGRpbWVuc2lvbi5cbiAgICogQHJldHVybiB7IUNvb3JkaW5hdGV9IFRoaXMgY29vcmRpbmF0ZSBhZnRlciBzY2FsaW5nLlxuICAgKi9cblxuXG4gIENvb3JkaW5hdGUucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24gc2NhbGUoc3gpIHtcbiAgICB2YXIgb3B0U3kgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHN4O1xuXG4gICAgdGhpcy54ICo9IHN4O1xuICAgIHRoaXMueSAqPSBvcHRTeTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVHJhbnNsYXRlcyB0aGlzIGJveCBieSB0aGUgZ2l2ZW4gb2Zmc2V0cy4gSWYgYSB7QGNvZGUgQ29vcmRpbmF0ZX1cbiAgICogaXMgZ2l2ZW4sIHRoZW4gdGhlIHggYW5kIHkgdmFsdWVzIGFyZSB0cmFuc2xhdGVkIGJ5IHRoZSBjb29yZGluYXRlJ3MgeCBhbmQgeS5cbiAgICogT3RoZXJ3aXNlLCB4IGFuZCB5IGFyZSB0cmFuc2xhdGVkIGJ5IHtAY29kZSB0eH0gYW5kIHtAY29kZSBvcHRfdHl9XG4gICAqIHJlc3BlY3RpdmVseS5cbiAgICogQHBhcmFtIHtudW1iZXJ8Q29vcmRpbmF0ZX0gdHggVGhlIHZhbHVlIHRvIHRyYW5zbGF0ZSB4IGJ5IG9yIHRoZVxuICAgKiAgICAgdGhlIGNvb3JkaW5hdGUgdG8gdHJhbnNsYXRlIHRoaXMgY29vcmRpbmF0ZSBieS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFt0eV0gVGhlIHZhbHVlIHRvIHRyYW5zbGF0ZSB5IGJ5LlxuICAgKiBAcmV0dXJuIHshQ29vcmRpbmF0ZX0gVGhpcyBjb29yZGluYXRlIGFmdGVyIHRyYW5zbGF0aW5nLlxuICAgKi9cblxuXG4gIENvb3JkaW5hdGUucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIHRyYW5zbGF0ZSh0eCwgdHkpIHtcbiAgICBpZiAodHggaW5zdGFuY2VvZiBDb29yZGluYXRlKSB7XG4gICAgICB0aGlzLnggKz0gdHgueDtcbiAgICAgIHRoaXMueSArPSB0eC55O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnggKz0gdHg7XG4gICAgICB0aGlzLnkgKz0gdHk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbXBhcmVzIGNvb3JkaW5hdGVzIGZvciBlcXVhbGl0eS5cbiAgICogQHBhcmFtIHtDb29yZGluYXRlfSBhIEEgQ29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtDb29yZGluYXRlfSBiIEEgQ29vcmRpbmF0ZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZmYgdGhlIGNvb3JkaW5hdGVzIGFyZSBlcXVhbCwgb3IgaWYgYm90aCBhcmUgbnVsbC5cbiAgICovXG5cblxuICBDb29yZGluYXRlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICghYSB8fCAhYikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBhLnggPT09IGIueCAmJiBhLnkgPT09IGIueTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gY29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7IUNvb3JkaW5hdGV9IGEgQSBDb29yZGluYXRlLlxuICAgKiBAcGFyYW0geyFDb29yZGluYXRlfSBiIEEgQ29vcmRpbmF0ZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgZGlzdGFuY2UgYmV0d2VlbiB7QGNvZGUgYX0gYW5kIHtAY29kZSBifS5cbiAgICovXG5cblxuICBDb29yZGluYXRlLmRpc3RhbmNlID0gZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICAgIHZhciBkeCA9IGEueCAtIGIueDtcbiAgICB2YXIgZHkgPSBhLnkgLSBiLnk7XG4gICAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0d28gY29vcmRpbmF0ZXMgYXMgYSBuZXcgQ29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHshQ29vcmRpbmF0ZX0gYSBBIENvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7IUNvb3JkaW5hdGV9IGIgQSBDb29yZGluYXRlLlxuICAgKiBAcmV0dXJuIHshQ29vcmRpbmF0ZX0gQSBDb29yZGluYXRlIHJlcHJlc2VudGluZyB0aGUgZGlmZmVyZW5jZVxuICAgKiAgICAgYmV0d2VlbiB7QGNvZGUgYX0gYW5kIHtAY29kZSBifS5cbiAgICovXG5cblxuICBDb29yZGluYXRlLmRpZmZlcmVuY2UgPSBmdW5jdGlvbiBkaWZmZXJlbmNlKGEsIGIpIHtcbiAgICByZXR1cm4gbmV3IENvb3JkaW5hdGUoYS54IC0gYi54LCBhLnkgLSBiLnkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdW0gb2YgdHdvIGNvb3JkaW5hdGVzIGFzIGEgbmV3IENvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7IUNvb3JkaW5hdGV9IGEgQSBDb29yZGluYXRlLlxuICAgKiBAcGFyYW0geyFDb29yZGluYXRlfSBiIEEgQ29vcmRpbmF0ZS5cbiAgICogQHJldHVybiB7IUNvb3JkaW5hdGV9IEEgQ29vcmRpbmF0ZSByZXByZXNlbnRpbmcgdGhlIHN1bSBvZiB0aGUgdHdvIGNvb3JkaW5hdGVzLlxuICAgKi9cblxuXG4gIENvb3JkaW5hdGUuc3VtID0gZnVuY3Rpb24gc3VtKGEsIGIpIHtcbiAgICByZXR1cm4gbmV3IENvb3JkaW5hdGUoYS54ICsgYi54LCBhLnkgKyBiLnkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHR3byBjb29yZGluYXRlcyBhcyBhIG5ldyBDb29yZGluYXRlLlxuICAgKiBAcGFyYW0geyFDb29yZGluYXRlfSBhIEEgQ29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHshQ29vcmRpbmF0ZX0gYiBBIENvb3JkaW5hdGUuXG4gICAqIEByZXR1cm4geyFDb29yZGluYXRlfSBBIENvb3JkaW5hdGUgcmVwcmVzZW50aW5nIHRoZSBwcm9kdWN0IG9mIHRoZSB0d28gY29vcmRpbmF0ZXMuXG4gICAqL1xuXG5cbiAgQ29vcmRpbmF0ZS5wcm9kdWN0ID0gZnVuY3Rpb24gcHJvZHVjdChhLCBiKSB7XG4gICAgcmV0dXJuIG5ldyBDb29yZGluYXRlKGEueCAqIGIueCwgYS55ICogYi55KTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcXVvdGllbnQgb2YgdHdvIGNvb3JkaW5hdGVzIGFzIGEgbmV3IENvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7IUNvb3JkaW5hdGV9IGEgQSBDb29yZGluYXRlLlxuICAgKiBAcGFyYW0geyFDb29yZGluYXRlfSBiIEEgQ29vcmRpbmF0ZS5cbiAgICogQHJldHVybiB7IUNvb3JkaW5hdGV9IEEgQ29vcmRpbmF0ZSByZXByZXNlbnRpbmcgdGhlIHF1b3RpZW50IG9mIHRoZSB0d28gY29vcmRpbmF0ZXMuXG4gICAqL1xuXG5cbiAgQ29vcmRpbmF0ZS5xdW90aWVudCA9IGZ1bmN0aW9uIHF1b3RpZW50KGEsIGIpIHtcbiAgICByZXR1cm4gbmV3IENvb3JkaW5hdGUoYS54IC8gYi54LCBhLnkgLyBiLnkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTY2FsZXMgdGhpcyBjb29yZGluYXRlIGJ5IHRoZSBnaXZlbiBzY2FsZSBmYWN0b3JzLiBUaGlzIGRvZXMgbm90IGFmZmVjdCB0aGVcbiAgICogcHJvcGVyaXRlcyBvZiB0aGUgY29vcmRpbmF0ZSBwYXJhbWV0ZXIuXG4gICAqIEBwYXJhbSB7IUNvb3JkaW5hdGV9IGEgQSBDb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3ggVGhlIHNjYWxlIGZhY3RvciB0byB1c2UgZm9yIHRoZSB4IGRpbWVuc2lvbi5cbiAgICogQHBhcmFtIHtudW1iZXI9fSBvcHRTeSBUaGUgc2NhbGUgZmFjdG9yIHRvIHVzZSBmb3IgdGhlIHkgZGltZW5zaW9uLlxuICAgKiBAcmV0dXJuIHshQ29vcmRpbmF0ZX0gVGhpcyBjb29yZGluYXRlIGFmdGVyIHNjYWxpbmcuXG4gICAqL1xuXG5cbiAgQ29vcmRpbmF0ZS5zY2FsZSA9IGZ1bmN0aW9uIHNjYWxlKGEsIHN4KSB7XG4gICAgdmFyIG9wdFN5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBzeDtcblxuICAgIHJldHVybiBuZXcgQ29vcmRpbmF0ZShhLnggKiBzeCwgYS55ICogb3B0U3kpO1xuICB9O1xuXG4gIHJldHVybiBDb29yZGluYXRlO1xufSgpO1xuXG4vKipcbiAqIEZhbGxiYWNrIHRvIGEgc3BlY2lmaWVkIGRlZmF1bHQgaWYgYW4gaW5wdXQgaXMgdW5kZWZpbmVkIG9yIG51bGwuXG4gKiBAcGFyYW0geyp9IG9iaiBUaGUgaW5wdXQgdG8gdGVzdC5cbiAqIEBwYXJhbSB7Kn0gZGVmYXVsdFZhbHVlIFRoZSBmYWxsYmFjayBpZiB0aGUgaW5wdXQgaXMgdW5kZWZpbmVkLlxuICogQHBhcmFtIHtib29sZWFuPX0gdGVzdCBJZiBkZWZpbmVkLCBgdGVzdGAgd2lsbCBiZSB1c2VkIHRvIGRldGVybWluZSB3aGljaFxuICogICAgIHZhbHVlIHNob3VsZCBiZSB1c2VkLlxuICogQHJldHVybiB7Kn0gVGhlIHNhbml0aXplZCBvdXRwdXQsIGVpdGhlciBgb2JqYCBvciBgZGVmYXVsdFZhbHVlYC5cbiAqL1xuZnVuY3Rpb24gZGVmYXVsdHNUbyhvYmosIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgdGVzdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogaXNEZWZpbmVkKG9iaik7XG5cbiAgcmV0dXJuIHRlc3QgPyBvYmogOiBkZWZhdWx0VmFsdWU7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgd2luZG93IGxvYWQgZXZlbnQgaXMgZmlyZWQsIG9yXG4gKiBvbmUgd2hpY2ggcmVzb2x2ZXMgaW1tZWRpYXRlbHkgaWYgdGhhdCBoYXMgYWxyZWFkeSBoYXBwZW5lZC5cbiAqIEB0eXBlIHtQcm9taXNlPHZvaWQ+fVxuICovXG52YXIgZG9tTG9hZGVkID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgcmVzb2x2ZSgpO1xuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gY29tcGxldGUoKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIGNvbXBsZXRlKTtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcbiAgfVxufSk7XG5cbi8qKlxuICogUmV0dXJucyBhIHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgRE9NQ29udGVudExvYWRlZCBldmVudCBpcyBmaXJlZCwgb3JcbiAqIG9uZSB3aGljaCByZXNvbHZlcyBpbW1lZGlhdGVseSBpZiB0aGF0IGhhcyBhbHJlYWR5IGhhcHBlbmVkLlxuICogQHR5cGUge1Byb21pc2U8dm9pZD59XG4gKi9cbnZhciBkb21SZWFkeSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2ludGVyYWN0aXZlJykge1xuICAgIHJlc29sdmUoKTtcbiAgfSBlbHNlIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24gcmVhZHkoKSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgcmVhZHkpO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9XG59KTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hpY2ggZWxlbWVudCBpbiBhbiBhcnJheSBpcyB0aGUgdGFsbGVzdC5cbiAqIEBwYXJhbSB7QXJyYXlMaWtlPEhUTUxFbGVtZW50Pn0gZWxlbWVudHMgQXJyYXktbGlrZSBvZiBlbGVtZW50cy5cbiAqIEByZXR1cm4ge251bWJlcn0gSGVpZ2h0IG9mIHRoZSB0YWxsZXN0IGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGdldFRhbGxlc3QoZWxlbWVudHMpIHtcbiAgdmFyIHRhbGxlc3QgPSAwO1xuXG4gIGZvciAodmFyIGkgPSBlbGVtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChlbGVtZW50c1tpXS5vZmZzZXRIZWlnaHQgPiB0YWxsZXN0KSB7XG4gICAgICB0YWxsZXN0ID0gZWxlbWVudHNbaV0ub2Zmc2V0SGVpZ2h0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YWxsZXN0O1xufVxuXG4vKipcbiAqIFNldCB0aGUgaGVpZ2h0IG9mIGV2ZXJ5IGVsZW1lbnQgaW4gYW4gYXJyYXkgdG8gYSB2YWx1ZS5cbiAqIEBwYXJhbSB7QXJyYXlMaWtlPEhUTUxFbGVtZW50Pn0gZWxlbWVudHMgQXJyYXktbGlrZSBvZiBlbGVtZW50cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBoZWlnaHQgSGVpZ2h0IHZhbHVlIHRvIHNldC5cbiAqL1xuZnVuY3Rpb24gc2V0QWxsSGVpZ2h0cyhlbGVtZW50cywgaGVpZ2h0KSB7XG4gIGZvciAodmFyIGkgPSBlbGVtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGVsZW1lbnRzW2ldLnN0eWxlLmhlaWdodCA9IGhlaWdodDtcbiAgfVxufVxuXG4vKipcbiAqIEZvciBncm91cHMgb2YgZWxlbWVudHMgd2hpY2ggc2hvdWxkIGJlIHRoZSBzYW1lIGhlaWdodC4gVXNpbmcgdGhpcyBtZXRob2RcbiAqIHdpbGwgY3JlYXRlIGZhciBsZXNzIHN0eWxlIHJlY2FsY3VsYXRpb25zIGFuZCBsYXlvdXRzLlxuICogQHBhcmFtIHtBcnJheUxpa2UuPEhUTUxFbGVtZW50PnxBcnJheUxpa2UuPEFycmF5TGlrZS48SFRNTEVsZW1lbnQ+Pn0gZ3JvdXBzIEFuXG4gKiAgICAgYXJyYXktbGlrZSBjb2xsZWN0aW9uIG9mIGFuIGFycmF5LWxpa2UgY29sbGVjdGlvbiBvZiBlbGVtZW50cy5cbiAqIEByZXR1cm4ge251bWJlcnxBcnJheS48bnVtYmVyPn0gQW4gYXJyYXkgY29udGFpbmluZyB0aGUgcGl4ZWwgdmFsdWUgb2YgdGhlXG4gKiAgICAgdGFsbGVzdCBlbGVtZW50IGZvciBlYWNoIGdyb3VwLCBvciBqdXN0IGEgbnVtYmVyIGlmIGl0J3Mgb25lIGdyb3VwLlxuICovXG5mdW5jdGlvbiBldmVuSGVpZ2h0cyhncm91cHMpIHtcbiAgdmFyIGxpc3QgPSBBcnJheS5mcm9tKGdyb3Vwcyk7XG5cbiAgLy8gSWYgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGxpc3QgaXMgYW4gZWxlbWVudCwgdGhlbiBpdCBuZWVkcyB0byBiZSB3cmFwcGVkXG4gIC8vIGluIGFuIGFycmF5IHNvIHRoZSByZXN0IG9mIHRoZSBtZXRob2RzIHdpbGwgd29yay5cbiAgdmFyIGlzR3JvdXAgPSB0cnVlO1xuICBpZiAobGlzdFswXSAmJiBsaXN0WzBdLm5vZGVUeXBlKSB7XG4gICAgaXNHcm91cCA9IGZhbHNlO1xuICAgIGxpc3QgPSBbbGlzdF07XG4gIH1cblxuICAvLyBGaXJzdCwgcmVzZXQgdGhlIGhlaWdodCBmb3IgZXZlcnkgZWxlbWVudC5cbiAgLy8gVGhpcyBpcyBkb25lIGZpcnN0LCBvdGhlcndpc2Ugd2UgZGlydHkgdGhlIERPTSBvbiBlYWNoIGxvb3AhXG4gIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudHMpIHtcbiAgICBzZXRBbGxIZWlnaHRzKGVsZW1lbnRzLCAnJyk7XG4gIH0pO1xuXG4gIC8vIE5vdywgbWVhc3VyZSBoZWlnaHRzIGluIGVhY2ggZ3JvdXAgYW5kIHNhdmUgdGhlIHRhbGxlc3QgdmFsdWUuIEluc3RlYWQgb2ZcbiAgLy8gc2V0dGluZyB0aGUgaGVpZ2h0IHZhbHVlIGZvciB0aGUgZW50aXJlIGdyb3VwLCBzYXZlIGl0LiBJZiBpdCB3ZXJlIHNldCxcbiAgLy8gdGhlIG5leHQgaXRlcmF0aW9uIGluIHRoZSBsb29wIHdvdWxkIGhhdmUgdG8gcmVjYWxjdWxhdGUgc3R5bGVzIGluIHRoZSBET01cbiAgdmFyIHRhbGxlc3RzID0gbGlzdC5tYXAoZnVuY3Rpb24gKGVsZW1lbnRzKSB7XG4gICAgcmV0dXJuIGdldFRhbGxlc3QoZWxlbWVudHMpO1xuICB9KTtcblxuICAvLyBMYXN0bHksIHNldCB0aGVtIGFsbC5cbiAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50cywgaSkge1xuICAgIHNldEFsbEhlaWdodHMoZWxlbWVudHMsIHRhbGxlc3RzW2ldICsgJ3B4Jyk7XG4gIH0pO1xuXG4gIGlmIChpc0dyb3VwKSB7XG4gICAgcmV0dXJuIHRhbGxlc3RzO1xuICB9XG4gIHJldHVybiB0YWxsZXN0c1swXTtcbn1cblxuZnVuY3Rpb24gb25UcmFuc2l0aW9uRW5kKGVsZW0sIGZuKSB7XG4gIHZhciBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB3aW5kb3c7XG4gIHZhciBwcm9wZXJ0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcbiAgdmFyIHRpbWVvdXQgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IG51bGw7XG5cbiAgdmFyIGVsZW1lbnQgPSBnZXRFbGVtZW50KGVsZW0pO1xuXG4gIHZhciBjYWxsYmFjayA9IGZuLmJpbmQoY29udGV4dCk7XG4gIHZhciB0aW1lcklkID0gdm9pZCAwO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zaXRpb25FdmVudHx7dGFyZ2V0OiBFbGVtZW50LCBjdXJyZW50VGFyZ2V0OiBFbGVtZW50fX0gZXZ0IEV2ZW50IG9iamVjdC5cbiAgICovXG5cbiAgZnVuY3Rpb24gdHJhbnNpdGlvbkVuZGVkKGV2dCkge1xuICAgIC8vIFNvbWUgb3RoZXIgZWxlbWVudCdzIHRyYW5zaXRpb24gZXZlbnQgY291bGQgaGF2ZSBidWJibGVkIHVwIHRvIHRoaXMuXG4gICAgLy8gb3JcbiAgICAvLyBJZiB0aGUgb3B0aW9uYWwgcHJvcGVydHkgZXhpc3RzIGFuZCBpdCdzIG5vdCB0aGUgcHJvcGVydHkgd2hpY2ggd2FzXG4gICAgLy8gdHJhbnNpdGlvbmVkLCBleGl0IG91dCBvZiB0aGUgZnVuY3Rpb24gYW5kIGNvbnRpbnVlIHdhaXRpbmcgZm9yIHRoZVxuICAgIC8vIHJpZ2h0IHRyYW5zaXRpb24gcHJvcGVydHkuXG4gICAgaWYgKCFpc093bkV2ZW50KGV2dCkgfHwgIWlzU2FtZVRyYW5zaXRpb25Qcm9wZXJ0eShldnQsIHByb3BlcnR5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBmcm9tIGFjdGl2ZSB0cmFuc2l0aW9ucy5cbiAgICBjbGVhclRyYW5zaXRpb24odHJhbnNpdGlvbklkKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZVxuXG4gICAgLy8gSWYgdGhlIGJyb3dzZXIgaGFzIHRyYW5zaXRpb25zLCB0aGVyZSB3aWxsIGJlIGEgbGlzdGVuZXIgYm91bmQgdG8gdGhlXG4gICAgLy8gYHRyYW5zaXRpb25lbmRgIGV2ZW50IHdoaWNoIG5lZWRzIHRvIGJlIHJlbW92ZWQuXG4gICAgaWYgKE9kb0RldmljZS5IQVNfVFJBTlNJVElPTlMpIHtcbiAgICAgIGV2dC5jdXJyZW50VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRzLlRSQU5TSVRJT05FTkQsIHRyYW5zaXRpb25FbmRlZCk7XG4gICAgfVxuXG4gICAgLy8gRG9uZSFcbiAgICBjYWxsYmFjayhldnQpO1xuICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgfVxuXG4gIGlmIChPZG9EZXZpY2UuSEFTX1RSQU5TSVRJT05TKSB7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50cy5UUkFOU0lUSU9ORU5ELCB0cmFuc2l0aW9uRW5kZWQpO1xuXG4gICAgLy8gU29tZXRpbWVzIHRoZSB0cmFuc2l0aW9uIGVuZCBldmVudCBkb2Vzbid0IGZpcmUsIHVzdWFsbHkgd2hlblxuICAgIC8vIHByb3BlcnRpZXMgZG9uJ3QgY2hhbmdlIG9yIHdoZW4gaU9TIGRlY2lkZXMgdG8ganVzdCBzbmFwIGluc3RlYWQgb2ZcbiAgICAvLyB0cmFuc2l0aW9uLiBUbyBnZXQgYXJvdW5kIHRoaXMsIGEgdGltZXIgaXMgc2V0IHdoaWNoIHdpbGwgdHJpZ2dlciB0aGVcbiAgICAvLyBmYWtlIGV2ZW50LlxuICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyYW5zaXRpb25FbmRlZChnZXRGYWtlRXZlbnQoZWxlbWVudCkpO1xuICAgICAgfSwgdGltZW91dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFB1c2ggdG8gdGhlIGVuZCBvZiB0aGUgcXVldWUgd2l0aCBhIGZha2UgZXZlbnQgd2hpY2ggd2lsbCBwYXNzIHRoZSBjaGVja3NcbiAgICAvLyBpbnNpZGUgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyYW5zaXRpb25FbmRlZChnZXRGYWtlRXZlbnQoZWxlbWVudCkpO1xuICAgIH0sIDApO1xuICB9XG5cbiAgLy8gU2F2ZSB0aGlzIGFjdGl2ZSB0cmFuc2l0aW9uIGVuZCBsaXN0ZW5lciBzbyBpdCBjYW4gYmUgY2FuY2VsZWQuXG4gIHZhciB0cmFuc2l0aW9uSWQgPSBzYXZlVHJhbnNpdGlvbihlbGVtZW50LCB0aW1lcklkLCB0cmFuc2l0aW9uRW5kZWQpO1xuXG4gIC8vIFJldHVybiBpZCB1c2VkIHRvIGNhbmNlbCB0aGUgdHJhbnNpdGlvbiBlbmQgbGlzdGVuZXIsIHNpbWlsYXIgdG8gc2V0VGltZW91dFxuICAvLyBhbmQgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLlxuICByZXR1cm4gdHJhbnNpdGlvbklkO1xufVxuXG4vKipcbiAqIEZhZGUgb3V0IGFuIGVsZW1lbnQgYW5kIHRoZW4gc2V0IHZpc2liaWx0eSBoaWRkZW4gb24gaXQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW0gRWxlbWVudCB0byBmYWRlLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNPdXRdIFdoZXRoZXIgdG8gZmFkZSBvdXQgb3IgaW4uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm49bm9vcF0gQ2FsbGJhY2sgZnVuY3Rpb24gd2hlbiBmYWRlZCBvdXQuXG4gKiBAcGFyYW0ge1dpbmRvd3xIVE1MRWxlbWVudH0gW2NvbnRleHQ9d2luZG93XSBDb250ZXh0IGZvciB0aGUgY2FsbGJhY2suXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbnZpc2libGU9ZmFsc2VdIFdoZXRoZXIgdG8gYWRkIHZpc2liaWxpdHk6aGlkZGVuIHRvIHRoZVxuICogICAgIGVsZW1lbnQgb25jZSBpdCBoYXMgZmFkZWQgb3V0LiBEZWZhdWx0cyB0byBmYWxzZS5cbiAqIEByZXR1cm4ge251bWJlcn0gaWQgdXNlZCB0byBjYW5jZWwgdGhlIHRyYW5zaXRpb24gZW5kIGxpc3RlbmVyLlxuICovXG5mdW5jdGlvbiBmYWRlRWxlbWVudChlbGVtLCBpc091dCkge1xuICB2YXIgZm4gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG5vb3A7XG4gIHZhciBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB3aW5kb3c7XG4gIHZhciBpbnZpc2libGUgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IGZhbHNlO1xuXG4gIHZhciBlbGVtZW50ID0gZ2V0RWxlbWVudChlbGVtKTtcblxuICAvLyBCaW5kIHRoZSBjb250ZXh0IHRvIHRoZSBjYWxsYmFjayBoZXJlIHNvIHRoYXQgdGhlIGNvbnRleHQgYW5kIGZ1bmN0aW9uXG4gIC8vIHJlZmVyZW5jZXMgY2FuIGJlIGdhcmJhZ2UgY29sbGVjdGVkIGFuZCB0aGUgb25seSB0aGluZ3MgbGVmdCBhcmUgYGNhbGxiYWNrYFxuICAvLyBhbmQgYGludmlzaWJsZWAuXG4gIHZhciBjYWxsYmFjayA9IGZuLmJpbmQoY29udGV4dCk7XG5cbiAgLy8gTWFrZSBzdXJlIHRoZSB0cmFuc2l0aW9uIHdpbGwgYWN0dWFsbHkgaGFwcGVuLlxuICAvLyBpc0luIGFuZCBoYXMgYGluYCBhbmQgYGZhZGVgIGNsYXNzZXMgb3JcbiAgLy8gaXNJbiBidXQgZG9lc24ndCBoYXZlIGBmYWRlYCBvclxuICAvLyBpc091dCBhbmQgaGFzIGBmYWRlYCwgYnV0IGRvZXNuJ3QgaGF2ZSBgaW5gIGNsYXNzLlxuICB2YXIgaGFzSW4gPSBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDbGFzc2VzLklOKTtcbiAgdmFyIGhhc0ZhZGUgPSBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDbGFzc2VzLkZBREUpO1xuICBpZiAoIWlzT3V0ICYmIGhhc0luICYmIGhhc0ZhZGUgfHwgIWlzT3V0ICYmICFoYXNGYWRlIHx8IGlzT3V0ICYmICFoYXNJbiAmJiBoYXNGYWRlKSB7XG4gICAgdmFyIGZha2VFdmVudCA9IGdldEZha2VFdmVudChlbGVtZW50KTtcblxuICAgIC8vIFRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYXN5bmMuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsYmFjayhmYWtlRXZlbnQpO1xuICAgIH0sIDApO1xuXG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJuYWwgY2FsbGJhY2sgd2hlbiB0aGUgZWxlbWVudCBoYXMgZmluaXNoZWQgaXRzIHRyYW5zaXRpb24uXG4gICAqIEBwYXJhbSB7e3RhcmdldDogRWxlbWVudCwgY3VycmVudFRhcmdldDogRWxlbWVudH19IGV2dCBFdmVudCBvYmplY3QuXG4gICAqL1xuICBmdW5jdGlvbiBmYWRlZChldnQpIHtcbiAgICAvLyBFbGVtZW50IGhhcyBmYWRlZCBvdXQsIGFkZCBpbnZpc2libGUgY2xhc3MuXG4gICAgaWYgKGlzT3V0ICYmIGludmlzaWJsZSkge1xuICAgICAgZXZ0LmN1cnJlbnRUYXJnZXQuY2xhc3NMaXN0LmFkZChDbGFzc2VzLklOVklTSUJMRSk7XG4gICAgfVxuXG4gICAgY2FsbGJhY2soZXZ0KTtcbiAgfVxuXG4gIC8vIEZhZGluZyBpbiwgcmVtb3ZlIGludmlzaWJsZSBjbGFzcy5cbiAgaWYgKCFpc091dCAmJiBpbnZpc2libGUpIHtcbiAgICBlbGVtLmNsYXNzTGlzdC5yZW1vdmUoQ2xhc3Nlcy5JTlZJU0lCTEUpO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIGl0IGhhcyB0aGUgXCJmYWRlXCIgY2xhc3MuIEl0IHdvbid0IGRvIGFueXRoaW5nIGlmIGl0IGFscmVhZHkgZG9lcy5cbiAgZWxlbS5jbGFzc0xpc3QuYWRkKENsYXNzZXMuRkFERSk7XG5cbiAgLy8gUmVtb3ZlIChvciBhZGQpIHRoZSBcImluXCIgY2xhc3Mgd2hpY2ggdHJpZ2dlcnMgdGhlIHRyYW5zaXRpb24uXG4gIC8vIElmIHRoZSBlbGVtZW50IGhhZCBuZWl0aGVyIG9mIHRoZXNlIGNsYXNzZXMsIGFkZGluZyB0aGUgXCJmYWRlXCIgY2xhc3NcbiAgLy8gd2lsbCB0cmlnZ2VyIHRoZSB0cmFuc2l0aW9uLlxuICBlbGVtLmNsYXNzTGlzdC50b2dnbGUoQ2xhc3Nlcy5JTiwgIWlzT3V0KTtcblxuICByZXR1cm4gb25UcmFuc2l0aW9uRW5kKGVsZW0sIGZhZGVkLCBudWxsLCAnb3BhY2l0eScpO1xufVxuXG4vKipcbiAqIEZhZGUgaW4gYW4gZWxlbWVudCBhbmQgb3B0aW9uYWxseSByZW1vdmUgYSBjbGFzcyB3aGljaCBzZXRzIHZpc2liaWxpdHlcbiAqIHRvIGhpZGRlbi5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbSBFbGVtZW50IHRvIGZhZGUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm49bm9vcF0gQ2FsbGJhY2sgZnVuY3Rpb24gd2hlbiBmYWRlZCBvdXQuXG4gKiBAcGFyYW0ge1dpbmRvd3xIVE1MRWxlbWVudH0gW2NvbnRleHQ9d2luZG93XSBDb250ZXh0IGZvciB0aGUgY2FsbGJhY2suXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbnZpc2libGU9ZmFsc2VdIFdoZXRoZXIgdG8gYWRkIHZpc2liaWxpdHk6aGlkZGVuIHRvIHRoZVxuICogICAgIGVsZW1lbnQgb25jZSBpdCBoYXMgZmFkZWQuIERlZmF1bHRzIHRvIGZhbHNlLlxuICovXG5mdW5jdGlvbiBmYWRlSW5FbGVtZW50KGVsZW0sIGZuLCBjb250ZXh0LCBpbnZpc2libGUpIHtcbiAgcmV0dXJuIGZhZGVFbGVtZW50KGVsZW0sIGZhbHNlLCBmbiwgY29udGV4dCwgaW52aXNpYmxlKTtcbn1cblxuLyoqXG4gKiBGYWRlIGluIGFuIGVsZW1lbnQgYW5kIG9wdGlvbmFsbHkgYWRkIGEgY2xhc3Mgd2hpY2ggc2V0cyB2aXNpYmlsaXR5XG4gKiB0byBoaWRkZW4uXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW0gRWxlbWVudCB0byBmYWRlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuPW5vb3BdIENhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gZmFkZWQgb3V0LlxuICogQHBhcmFtIHtXaW5kb3d8SFRNTEVsZW1lbnR9IFtjb250ZXh0PXdpbmRvd10gQ29udGV4dCBmb3IgdGhlIGNhbGxiYWNrLlxuICogQHBhcmFtIHtib29sZWFufSBbaW52aXNpYmxlPWZhbHNlXSBXaGV0aGVyIHRvIGFkZCB2aXNpYmlsaXR5OmhpZGRlbiB0byB0aGVcbiAqICAgICBlbGVtZW50IG9uY2UgaXQgaGFzIGZhZGVkLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAqL1xuZnVuY3Rpb24gZmFkZU91dEVsZW1lbnQoZWxlbSwgZm4sIGNvbnRleHQsIGludmlzaWJsZSkge1xuICByZXR1cm4gZmFkZUVsZW1lbnQoZWxlbSwgdHJ1ZSwgZm4sIGNvbnRleHQsIGludmlzaWJsZSk7XG59XG5cbi8qKlxuICogRm9yY2UgdGhlIHBhZ2UgdG8gYmUgcmVwYWludGVkLlxuICovXG5mdW5jdGlvbiBmb3JjZVJlZHJhdygpIHtcbiAgdmFyIHRlbXBTdHlsZVNoZWV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0ZW1wU3R5bGVTaGVldCk7XG4gIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGVtcFN0eWxlU2hlZXQpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGhlaWdodCBhbmQgd2l0aCBvZiBhbiBlbGVtZW50IHdoZW4gdGhlIGRpc3BsYXkgaXMgbm90IG5vbmUuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gZ2V0IHNpemUgb2YuXG4gKiBAcmV0dXJuIHshe3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gT2JqZWN0IHdpdGggd2lkdGgvaGVpZ2h0LlxuICovXG5mdW5jdGlvbiBnZXRTaXplKGVsZW1lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogZWxlbWVudC5vZmZzZXRXaWR0aCxcbiAgICBoZWlnaHQ6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0XG4gIH07XG59XG5cbi8qKlxuICogUGFyc2Ugc3RyaW5nIHRvIHJldHVybiBudW1lcmljYWwgdmFsdWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgU3RyaW5nIG9mIG51bWJlclxuICogQHJldHVybiB7bnVtYmVyfSBOdW1lcmljYWwgdmFsdWUgb3IgMCBpZiBwYXJzZUZsb2F0IHJldHVybnMgTmFOXG4gKi9cbmZ1bmN0aW9uIGdldEZsb2F0KHZhbHVlKSB7XG4gIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKSB8fCAwO1xufVxuXG5mdW5jdGlvbiBnZXRCb3goZWxlbWVudCwgcHJvcGVydHkpIHtcbiAgdmFyIHByb3BzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG4gIHJldHVybiBuZXcgQm94KGdldEZsb2F0KHByb3BzW3Byb3BlcnR5ICsgJ1RvcCddKSwgZ2V0RmxvYXQocHJvcHNbcHJvcGVydHkgKyAnUmlnaHQnXSksIGdldEZsb2F0KHByb3BzW3Byb3BlcnR5ICsgJ0JvdHRvbSddKSwgZ2V0RmxvYXQocHJvcHNbcHJvcGVydHkgKyAnTGVmdCddKSk7XG59XG5cbmZ1bmN0aW9uIGdldE1hcmdpbkJveChlbGVtZW50KSB7XG4gIHJldHVybiBnZXRCb3goZWxlbWVudCwgJ21hcmdpbicpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNpemUgKHdpZHRoIG9yIGhlaWdodCkgb2YgYSBsaXN0IG9mIGVsZW1lbnRzLCBpbmNsdWRpbmcgbWFyZ2lucy5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnRbXX0gZWxlbWVudHMgQW4gYXJyYXkgb2YgY2hpbGQgZWxlbWVudHMgKG5vdCBhIE5vZGVMaXN0KS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaW1lbnNpb24gYCd3aWR0aCdgIG9yIGAnaGVpZ2h0J2AuXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldEVsZW1lbnRzU2l6ZShlbGVtZW50cywgZGltZW5zaW9uKSB7XG4gIHJldHVybiBlbGVtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIGVsKSB7XG4gICAgdmFyIG91dGVyU2l6ZSA9IGdldFNpemUoZWwpW2RpbWVuc2lvbl07XG4gICAgdmFyIG1hcmdpbnMgPSBnZXRNYXJnaW5Cb3goZWwpO1xuICAgIHZhciBtYXJnaW5TaXplID0gZGltZW5zaW9uID09PSAnaGVpZ2h0JyA/IG1hcmdpbnMudG9wICsgbWFyZ2lucy5ib3R0b20gOiBtYXJnaW5zLmxlZnQgKyBtYXJnaW5zLnJpZ2h0O1xuXG4gICAgcmV0dXJuIG1lbW8gKyBvdXRlclNpemUgKyBtYXJnaW5TaXplO1xuICB9LCAwKTtcbn1cblxuLyoqXG4gKiBEZXRlY3RzIHRoZSB2ZXJzaW9uIG9mIGlPUyBvcGVyYXRpbmcgc3lzdGVtLlxuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJBZ2VudCBUaGUgdXNlciBhZ2VudCBzdHJpbmcuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGlPUyB2ZXJzaW9uLiBpT1MgOC40LjAsIGZvciBleGFtcGxlLCB3aWxsIHJldHVybiBgODQwYC5cbiAqL1xuZnVuY3Rpb24gZ2V0SU9TVmVyc2lvbih1c2VyQWdlbnQpIHtcbiAgdmFyIGlvc1VzZXJBZ2VudCA9IHVzZXJBZ2VudC5tYXRjaCgvT1NcXHMrKFtcXGRfXSspL2kpO1xuICB2YXIgaW9zVmVyc2lvbiA9IGlvc1VzZXJBZ2VudFsxXS5zcGxpdCgnXycpO1xuXG4gIC8vIFRoZSBpT1MgdWEgc3RyaW5nIGRvZXNuJ3QgaW5jbHVkZSB0aGUgcGF0Y2ggdmVyc2lvbiBpZiBpdCdzIHplcm8uXG4gIGlmIChpb3NWZXJzaW9uLmxlbmd0aCA9PT0gMikge1xuICAgIGlvc1ZlcnNpb25bMl0gPSAnMCc7XG4gIH1cblxuICByZXR1cm4gcGFyc2VJbnQoaW9zVmVyc2lvbi5yZWR1Y2UoZnVuY3Rpb24gKHN0ciwgbnVtYmVyKSB7XG4gICAgcmV0dXJuIHN0ciArIG51bWJlcjtcbiAgfSwgJycpLCAxMCk7XG59XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSBudGggc2libGluZyBvZiBhbiBlbGVtZW50LCBvciBudWxsIGlmIHRoZSB3b3VsZCBiZSBudGggc2libGluZ1xuICogZG9lcyBub3QgZXhpc3QuIEhlYWRzIHVwISBUaGlzIGZ1bmN0aW9uIGV4Y2x1ZGVzIHRleHQgbm9kZXMuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgRWxlbWVudCB0byBzdGFydCBsb29raW5nIGZyb20uXG4gKiBAcGFyYW0ge251bWJlcn0gbiBBbiBpbnRlZ2VyIHJlcHJlc2VudGluZyB0aGUgZGVzaXJlZCBlbGVtZW50IHJlbGF0aXZlIHRvXG4gKiAgICAgYG5vZGVgLiBGb3IgZXhhbXBsZSwgYDJgIHdvdWxkIGxvb2sgZm9yIGBub2RlLm5leHRTaWJsaW5nLm5leHRTaWJsaW5nYC5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdElzRm9yd2FyZCBXaGV0aGVyIHRvIGxvb2sgZm9yd2FyZHMgb3IgYmFja3dhcmRzLiBEZWZhdWx0IGlzIHRydWUuXG4gKiBAcmV0dXJuIHs/RWxlbWVudH0gVGhlIG50aCBzaWJsaW5nIG9yIG51bGwuXG4gKi9cbmZ1bmN0aW9uIGdldE50aFNpYmxpbmcobm9kZSwgbiwgb3B0SXNGb3J3YXJkKSB7XG4gIHZhciBpc0ZvcndhcmQgPSBvcHRJc0ZvcndhcmQgIT09IGZhbHNlO1xuICB2YXIgc2libGluZ0NvdW50ID0gMDtcbiAgdmFyIHNpYmxpbmcgPSBub2RlO1xuICBkbyB7XG4gICAgc2libGluZyA9IGlzRm9yd2FyZCA/IHNpYmxpbmcubmV4dEVsZW1lbnRTaWJsaW5nIDogc2libGluZy5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgIHNpYmxpbmdDb3VudCArPSAxO1xuICB9IHdoaWxlIChzaWJsaW5nICYmIHNpYmxpbmdDb3VudCA8IG4pO1xuICByZXR1cm4gc2libGluZztcbn1cblxuLyoqXG4gKiBQYXJzZSBhIHZhbHVlIGFzIGEgbnVtYmVyLiBJZiBpdCdzIG5vdCBudW1lcmljLCB0aGVuIHRoZSBkZWZhdWx0IHZhbHVlIHdpbGxcbiAqIGJlIHJldHVybmVkLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgb3B0aW9uLlxuICogQHBhcmFtIHsqfSBkZWZhdWx0VmFsdWUgVGhlIGZhbGxiYWNrIHZhbHVlLlxuICogQHJldHVybiB7Kn0gSWYgdmFsdWUgaXMgbnVtZXJpYywgdmFsdWUsIGVsc2UgZGVmYXVsdFZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXROdW1iZXJPcHRpb24odmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgbnVtYmVyID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gIHJldHVybiBkZWZhdWx0c1RvKG51bWJlciwgZGVmYXVsdFZhbHVlLCAhTnVtYmVyLmlzTmFOKG51bWJlcikpO1xufVxuXG5mdW5jdGlvbiBnZXRQYWRkaW5nQm94KGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldEJveChlbGVtZW50LCAncGFkZGluZycpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55dGhpbmcuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbn1cblxuLyoqXG4gKiBQYXJzZSBhIHZhbHVlIGFzIGEgc3RyaW5nLiBJZiBpdCdzIG5vdCBhIHN0cmluZywgdGhlbiB0aGUgZGVmYXVsdCB2YWx1ZVxuICogd2lsbCBiZSByZXR1cm5lZC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIG9wdGlvbi5cbiAqIEBwYXJhbSB7Kn0gZGVmYXVsdFZhbHVlIFRoZSBmYWxsYmFjayB2YWx1ZS5cbiAqIEByZXR1cm4geyp9IElmIHZhbHVlIGlzIGEgc3RyaW5nLCB2YWx1ZSwgZWxzZSBkZWZhdWx0VmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFN0cmluZ09wdGlvbih2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIHJldHVybiBkZWZhdWx0c1RvKHZhbHVlLCBkZWZhdWx0VmFsdWUsIGlzU3RyaW5nKHZhbHVlKSk7XG59XG5cbi8qKlxuICogUGFyc2UgYSB2YWx1ZSBhcyBhIHBlcmNlbnRhZ2UuIElmIGl0J3MgYSBzdHJpbmcgd2l0aCAnJScgaW4gaXQsIGl0IHdpbGxcbiAqIGJlIHBhcnNlZCBhcyBhIHN0cmluZywgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgcGFyc2VkIGFzIGEgbnVtYmVyLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgb3B0aW9uLlxuICogQHBhcmFtIHsqfSBkZWZhdWx0VmFsdWUgVGhlIGZhbGxiYWNrIHZhbHVlLlxuICogQHJldHVybiB7Kn1cbiAqL1xuZnVuY3Rpb24gZ2V0UGVyY2VudGFnZU9wdGlvbih2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkgJiYgdmFsdWUuaW5kZXhPZignJScpID4gLTEpIHtcbiAgICByZXR1cm4gZ2V0U3RyaW5nT3B0aW9uKHZhbHVlLCBkZWZhdWx0VmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIGdldE51bWJlck9wdGlvbih2YWx1ZSwgZGVmYXVsdFZhbHVlKTtcbn1cblxuLyoqXG4gKiBSaXBwZWQgZnJvbTogZ29vZy50ZXN0aW5nLmVkaXRvci5kb20uZ2V0UmVsYXRpdmVEZXB0aF8uXG4gKlxuICogUmV0dXJucyB0aGUgZGVwdGggb2YgdGhlIGdpdmVuIG5vZGUgcmVsYXRpdmUgdG8gdGhlIGdpdmVuIHBhcmVudCBub2RlLCBvciAtMVxuICogaWYgdGhlIGdpdmVuIG5vZGUgaXMgbm90IGEgZGVzY2VuZGFudCBvZiB0aGUgZ2l2ZW4gcGFyZW50IG5vZGUuIEUuZy4gaWZcbiAqIG5vZGUgPT0gcGFyZW50Tm9kZSByZXR1cm5zIDAsIGlmIG5vZGUucGFyZW50Tm9kZSA9PSBwYXJlbnROb2RlIHJldHVybnMgMSxcbiAqIGV0Yy5cbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHdob3NlIGRlcHRoIHRvIGdldC5cbiAqIEBwYXJhbSB7Tm9kZX0gcGFyZW50Tm9kZSBOb2RlIHJlbGF0aXZlIHRvIHdoaWNoIHRoZSBkZXB0aCBzaG91bGQgYmVcbiAqICAgICBjYWxjdWxhdGVkLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgZGVwdGggb2YgdGhlIGdpdmVuIG5vZGUgcmVsYXRpdmUgdG8gdGhlIGdpdmVuIHBhcmVudFxuICogICAgIG5vZGUsIG9yIC0xIGlmIHRoZSBnaXZlbiBub2RlIGlzIG5vdCBhIGRlc2NlbmRhbnQgb2YgdGhlIGdpdmVuIHBhcmVudFxuICogICAgIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGdldFJlbGF0aXZlRGVwdGgobm9kZSwgcGFyZW50Tm9kZSkge1xuICB2YXIgZGVwdGggPSAwO1xuICB2YXIgY2hpbGQgPSBub2RlO1xuICB3aGlsZSAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgPT09IHBhcmVudE5vZGUpIHtcbiAgICAgIHJldHVybiBkZXB0aDtcbiAgICB9XG5cbiAgICBjaGlsZCA9IGNoaWxkLnBhcmVudE5vZGU7XG4gICAgZGVwdGggKz0gMTtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBTZXQgYW4gaWQgb24gYW4gZWxlbWVudCBpZiBvbmUgZG9lc24ndCBleGlzdC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIGdpdmUgYW4gaWQuXG4gKiBAcGFyYW0ge3N0cmluZ3xmdW5jdGlvbigpOiBzdHJpbmd9IGZuIFJldHVybnMgYW4gaWQgdG8gc2V0LlxuICovXG5mdW5jdGlvbiBnaXZlSWQoZWxlbWVudCwgZm4pIHtcbiAgaWYgKCFlbGVtZW50LmlkKSB7XG4gICAgZWxlbWVudC5pZCA9IHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyA/IGZuKCkgOiBmbjtcbiAgfVxufVxuXG4vKipcbiAqIERldGVjdHMgdGhlIG5hdGl2ZSBBbmRyb2lkIE9wZXJhdGluZyBTeXN0ZW0uXG4gKiBAcGFyYW0ge3N0cmluZ30gdXNlckFnZW50IFRoZSB1c2VyIGFnZW50IHN0cmluZy5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzQW5kcm9pZE9TKHVzZXJBZ2VudCkge1xuICByZXR1cm4gdXNlckFnZW50LmluY2x1ZGVzKCdNb3ppbGxhLzUuMCcpICYmIHVzZXJBZ2VudC5pbmNsdWRlcygnQW5kcm9pZCAnKTtcbn1cblxuLyoqXG4gKiBDaGVjayBmb3IgTWljcm9zb2Z0IEVkZ2Ugc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJBZ2VudCBUaGUgdXNlciBhZ2VudCBzdHJpbmcuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0VkZ2UodXNlckFnZW50KSB7XG4gIHJldHVybiB1c2VyQWdlbnQuaW5jbHVkZXMoJ0VkZ2UvJyk7XG59XG5cbi8qKlxuICogRGV0ZWN0cyBhbGwgR29vZ2xlIENocm9tZSBicm93c2Vycy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1c2VyQWdlbnQgVGhlIHVzZXIgYWdlbnQgc3RyaW5nLlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNDaHJvbWUodXNlckFnZW50KSB7XG4gIHJldHVybiAhaXNFZGdlKHVzZXJBZ2VudCkgJiYgdXNlckFnZW50LmluY2x1ZGVzKCdDaHJvbWUnKTtcbn1cblxuLyoqXG4gKiBXaGV0aGVyIHRoZSBnaXZlIHVzZXIgYWdlbnQgaXMgZnJvbSB0aGUgc3RvY2sgQW5kcm9pZCBicm93c2VyLlxuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJBZ2VudCBVc2VyIGFnZW50IHN0cmluZy5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTmF0aXZlQW5kcm9pZCh1c2VyQWdlbnQpIHtcbiAgcmV0dXJuIGlzQW5kcm9pZE9TKHVzZXJBZ2VudCkgJiYgIWlzQ2hyb21lKHVzZXJBZ2VudCk7XG59XG5cbi8qKlxuICogRGV0ZWN0cyB0aGUgaU9TIG9wZXJhdGluZyBzeXN0ZW0uXG4gKiBAcGFyYW0ge3N0cmluZ30gdXNlckFnZW50ICBUaGUgdXNlciBhZ2VudCBzdHJpbmcuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0lPUyh1c2VyQWdlbnQpIHtcbiAgcmV0dXJuICgvKGlQYWR8aVBob25lfGlQb2QpL2cudGVzdCh1c2VyQWdlbnQpXG4gICk7XG59XG5cbi8qKlxuICogVXNlciBhZ2VudCB0ZXN0IGZvciBJT1MuIERldGVybWluZXMgd2hldGhlciBjdXJyZW50IHZlcnNpb24gaXMgPCA4LiBWZXJzaW9uIDhcbiAqIGFuZCBoaWdoZXIgYWxsb3cgamF2YXNjcmlwdCBleGVjdXRpb24gd2hpbGUgc2Nyb2xsaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJBZ2VudCBUaGUgdXNlciBhZ2VudCBzdHJpbmcuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBoYXNTY3JvbGxFdmVudHModXNlckFnZW50KSB7XG4gIGlmIChpc0lPUyh1c2VyQWdlbnQpKSB7XG4gICAgcmV0dXJuIGdldElPU1ZlcnNpb24odXNlckFnZW50KSA+PSA4MDA7XG4gIH1cbiAgcmV0dXJuICFpc05hdGl2ZUFuZHJvaWQodXNlckFnZW50KTtcbn1cblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgamF2YXNjcmlwdCBzdHlsZSBzdHJpbmcgdG8gYSBjc3Mgb25lLiBGb3IgZXhhbXBsZTpcbiAqIE1vekJveFNpemluZyAtPiAtbW96LWJveC1zaXppbmcuXG4gKiBAcGFyYW0ge3N0cmluZ3xmYWxzZX0gc3RyIFRoZSBzdHJpbmcgdG8gaHlwaGVuYXRlLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgaHlwaGVuYXRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZShzdHIpIHtcbiAgLy8gQ2F0Y2ggYm9vbGVhbnMuXG4gIGlmICghc3RyKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgLy8gVHVybiBNb3pCb3hTaXppbmcgaW50byAtbW96LWJveC1zaXppbmcuXG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFtBLVpdKS9nLCBmdW5jdGlvbiAoc3RyLCBtMSkge1xuICAgIHJldHVybiAnLScgKyBtMS50b0xvd2VyQ2FzZSgpO1xuICB9KS5yZXBsYWNlKC9ebXMtLywgJy1tcy0nKTtcbn1cblxuLyoqXG4gKiBDaGVjayBmb3IgTWljcm9zb2Z0IEludGVybmV0IEV4cGxvcmVyIHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1c2VyQWdlbnQgVGhlIHVzZXIgYWdlbnQgc3RyaW5nLlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNJRSh1c2VyQWdlbnQpIHtcbiAgcmV0dXJuIHVzZXJBZ2VudC5pbmNsdWRlcygnVHJpZGVudC8nKTtcbn1cblxuLyoqXG4gKiBFeGVjdXRlIGEgY2FsbGJhY2sgd2hlbiBhIGNzcyBhbmltYXRpb24gZmluaXNoZXMuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW0gVGhlIGVsZW1lbnQgd2hpY2ggYXMgYW4gYW5pbWF0aW9uIG9uIGl0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dD13aW5kb3ddIE9wdGlvbmFsIGNvbnRleHQgZm9yIHRoZSBjYWxsYmFjay5cbiAqL1xuZnVuY3Rpb24gb25BbmltYXRpb25FbmQoZWxlbSwgZm4pIHtcbiAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHdpbmRvdztcblxuICB2YXIgZWxlbWVudCA9IGdldEVsZW1lbnQoZWxlbSk7XG5cbiAgdmFyIGNhbGxiYWNrID0gZm4uYmluZChjb250ZXh0KTtcblxuICBmdW5jdGlvbiBhbmltYXRpb25FbmRlZChldnQpIHtcbiAgICAvLyBFbnN1cmUgdGhlIGBhbmltYXRpb25lbmRgIGV2ZW50IHdhcyBmcm9tIHRoZSBlbGVtZW50IHNwZWNpZmllZC5cbiAgICAvLyBEaWZmaWN1bHQgdG8gdGVzdCB3aXRob3V0IHRyYWNraW5nIGNhbGxiYWNrcy5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICghaXNPd25FdmVudChldnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIHRoZSBsaXN0ZW5lciBpZiBpdCB3YXMgYm91bmQuXG4gICAgaWYgKE9kb0RldmljZS5IQVNfQ1NTX0FOSU1BVElPTlMpIHtcbiAgICAgIGV2dC5jdXJyZW50VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRzLkFOSU1BVElPTkVORCwgYW5pbWF0aW9uRW5kZWQpO1xuICAgIH1cblxuICAgIGNhbGxiYWNrKGV2dCk7XG4gIH1cblxuICBpZiAoT2RvRGV2aWNlLkhBU19DU1NfQU5JTUFUSU9OUykge1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudHMuQU5JTUFUSU9ORU5ELCBhbmltYXRpb25FbmRlZCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2FsbGJhY2sgaXMgZXhwZWN0ZWQgdG8gYmUgYXN5bmMsIHNvIHB1c2ggaXQgdG8gdGhlIGVuZCBvZiB0aGUgcXVldWUuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBhbmltYXRpb25FbmRlZChnZXRGYWtlRXZlbnQoZWxlbWVudCkpO1xuICAgIH0sIDApO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSBhbiBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXkuPCo+fSBhcnIgQW4gYXJyYXkuXG4gKiBAcGFyYW0geyp9IGl0ZW0gVGhpbmcgdG8gcmVtb3ZlIGZyb20gdGhlIGFycmF5LlxuICogQHJldHVybiB7Pyp9IFRoZSBpdGVtIHdoaWNoIHdhcyByZW1vdmVkIG9yIG51bGwuXG4gKi9cbmZ1bmN0aW9uIHB1bGwoYXJyLCBpdGVtKSB7XG4gIHZhciBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBhcnIuc3BsaWNlKGluZGV4LCAxKTtcbiAgcmV0dXJuIGl0ZW07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHJhbmRvbSBzdHJpbmcgZm9yIElEcywgZXRjLlxuICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvODA4NDI0OC85OTU1MjlcbiAqIEByZXR1cm4ge3N0cmluZ30gUmFuZG9tIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gcmFuZG9tKCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDcpO1xufVxuXG52YXIgUmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENsYXNzIGZvciByZXByZXNlbnRpbmcgcmVjdGFuZ3VsYXIgcmVnaW9ucy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggTGVmdC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgVG9wLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdyBXaWR0aC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGggSGVpZ2h0LlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIFJlY3QoeCwgeSwgdywgaCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFJlY3QpO1xuXG4gICAgLyoqXG4gICAgICogTGVmdFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZWZ0ID0geDtcblxuICAgIC8qKlxuICAgICAqIFRvcFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50b3AgPSB5O1xuXG4gICAgLyoqXG4gICAgICogV2lkdGhcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMud2lkdGggPSB3O1xuXG4gICAgLyoqXG4gICAgICogSGVpZ2h0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmhlaWdodCA9IGg7XG4gIH1cblxuICAvKipcbiAgICogUmlnaHRcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG5cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHR3byByZWN0YW5nbGVzIGludGVyc2VjdC4gVHdvIHJlY3RhbmdsZXMgaW50ZXJzZWN0IGlmIHRoZXlcbiAgICogdG91Y2ggYXQgYWxsLCBmb3IgZXhhbXBsZSwgdHdvIHplcm8gd2lkdGggYW5kIGhlaWdodCByZWN0YW5nbGVzIHdvdWxkXG4gICAqIGludGVyc2VjdCBpZiB0aGV5IGhhZCB0aGUgc2FtZSB0b3AgYW5kIGxlZnQuXG4gICAqIEBwYXJhbSB7UmVjdH0gYSBBIFJlY3RhbmdsZS5cbiAgICogQHBhcmFtIHtSZWN0fSBiIEEgUmVjdGFuZ2xlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIGEgYW5kIGIgaW50ZXJzZWN0LlxuICAgKi9cbiAgUmVjdC5pbnRlcnNlY3RzID0gZnVuY3Rpb24gaW50ZXJzZWN0cyhhLCBiKSB7XG4gICAgcmV0dXJuIGEubGVmdCA8PSBiLnJpZ2h0ICYmIGIubGVmdCA8PSBhLnJpZ2h0ICYmIGEudG9wIDw9IGIuYm90dG9tICYmIGIudG9wIDw9IGEuYm90dG9tO1xuICB9O1xuXG4gIGNyZWF0ZUNsYXNzKFJlY3QsIFt7XG4gICAga2V5OiBcInJpZ2h0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZWZ0ICsgdGhpcy53aWR0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCb3R0b21cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYm90dG9tXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b3AgKyB0aGlzLmhlaWdodDtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFJlY3Q7XG59KCk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwgY2hpbGRyZW4gZnJvbSBhIHBhcmVudCBub2RlLlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFBhcmVudCBub2RlLlxuICovXG5mdW5jdGlvbiByZW1vdmVDaGlsZHJlbihlbGVtZW50KSB7XG4gIGVsZW1lbnQudGV4dENvbnRlbnQgPSAnJztcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUhhc2goaGFzaCkge1xuICBpZiAodHlwZW9mIGhhc2ggIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIG11c3QgYmUgb2YgdHlwZSBzdHJpbmcnKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaGFzaC5yZXBsYWNlKC9eIy8sICcnKTtcbiAgfVxufVxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIGJyb3dzZXIncyBoYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV3SGFzaCBOZXcgaGFzaCwgd2l0aG91dCBgI2BcbiAqL1xuZnVuY3Rpb24gc2V0SGFzaChuZXdIYXNoKSB7XG4gIHZhciBoYXNoID0gbm9ybWFsaXplSGFzaChuZXdIYXNoKTtcbiAgdmFyIHN0ID0gdm9pZCAwO1xuXG4gIC8vIFdoZW4gcmVzZXR0aW5nIHRoZSBoYXNoIHdpdGggYCcnYCwgdGhlIHBhZ2Ugd2lsbCBzY3JvbGwgYmFjayB0byB0aGUgdG9wLFxuICAvLyBzbyB3ZSBjYWNoZSB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb24uXG4gIGlmICghaGFzaCkge1xuICAgIHN0ID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICB9XG5cbiAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBoYXNoO1xuXG4gIC8vIFNjcm9sbCBiYWNrIHRvIHRoZSBwb3NpdGlvbiBmcm9tIGJlZm9yZS5cbiAgaWYgKCFoYXNoKSB7XG4gICAgd2luZG93LnNjcm9sbFRvKDAsIHN0KTtcbiAgfVxufVxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHVzZXIncyBoaXN0b3J5IHdpdGggbmV3IGhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXdIYXNoIE5ldyBoYXNoLCB3aXRob3V0IGAjYFxuICovXG5mdW5jdGlvbiByZXBsYWNlV2l0aEhhc2gobmV3SGFzaCkge1xuICB2YXIgaGFzaCA9IG5vcm1hbGl6ZUhhc2gobmV3SGFzaCk7XG4gIGlmICh3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUpIHtcbiAgICBoYXNoID0gbm9ybWFsaXplSGFzaChoYXNoKTtcblxuICAgIC8vIElmIHJlc2V0dGluZyB0aGUgaGFzaCwgdGhlIHdob2xlIHBhdGggaXMgbmVlZGVkLiBgJydgIGRvZXNuJ3Qgd29yay5cbiAgICBpZiAoaGFzaCkge1xuICAgICAgaGFzaCA9ICcjJyArIGhhc2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhc2ggPSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoO1xuICAgIH1cblxuICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSh7fSwgbnVsbCwgaGFzaCk7XG4gIH0gZWxzZSB7XG4gICAgc2V0SGFzaChoYXNoKTtcbiAgfVxufVxuXG4vKipcbiAqIFNjcm9sbCB0aGUgcGFnZSB0byBhIGRlc3RpbmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtwb3NpdGlvbl0gRW5kIHNjcm9sbCBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZHVyYXRpb25dIER1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb246dm9pZH0gW2NhbGxiYWNrXSBPcHRpb25hbCBjYWxsYmFjay5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24obnVtYmVyKTpudW1iZXJ9IFtlYXNpbmddIEVhc2luZyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2Nyb2xsVG8oKSB7XG4gIHZhciBwb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgdmFyIGR1cmF0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiA0MDA7XG4gIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbm9vcDtcbiAgdmFyIGVhc2luZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuXG4gIHZhciBvcHRpb25zID0ge1xuICAgIHN0YXJ0OiB3aW5kb3cucGFnZVlPZmZzZXQsXG4gICAgZW5kOiBwb3NpdGlvbixcbiAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgc3RlcDogZnVuY3Rpb24gc3RlcChzY3JvbGxUb3ApIHtcbiAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCBzY3JvbGxUb3ApO1xuICAgIH1cbiAgfTtcblxuICAvLyBBdm9pZCBzZXR0aW5nIGBlYXNpbmdgIHRvIGB1bmRlZmluZWRgLlxuICBpZiAodHlwZW9mIGVhc2luZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdGlvbnMuZWFzaW5nID0gZWFzaW5nO1xuICB9XG5cbiAgdmFyIGFuaW0gPSBuZXcgU3RlcHBlcihvcHRpb25zKTtcbiAgYW5pbS5vbmZpbmlzaCA9IGNhbGxiYWNrO1xuICByZXR1cm4gYW5pbTtcbn1cblxuLyoqXG4gKiBTd2FwcyBlbGVtZW50MSB3aXRoIGVsZW1lbnQyIGluIHRoZSBET00uXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsbTEgZmlyc3QgZWxlbWVudC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxtMiBzZWNvbmQgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gc3dhcEVsZW1lbnRzKGVsbTEsIGVsbTIpIHtcbiAgaWYgKCFlbG0xIHx8ICFlbG0yKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBhcmVudDEgPSBlbG0xLnBhcmVudE5vZGU7XG4gIHZhciBuZXh0MSA9IGVsbTEubmV4dFNpYmxpbmc7XG4gIHZhciBwYXJlbnQyID0gZWxtMi5wYXJlbnROb2RlO1xuICB2YXIgbmV4dDIgPSBlbG0yLm5leHRTaWJsaW5nO1xuXG4gIHBhcmVudDEuaW5zZXJ0QmVmb3JlKGVsbTIsIG5leHQxKTtcbiAgcGFyZW50Mi5pbnNlcnRCZWZvcmUoZWxtMSwgbmV4dDIpO1xufVxuXG52YXIgVGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBBIHNpbXBsZSB0aW1lciBjbGFzcy4gVGhlIHRpbWVyIGRvZXMgbm90IHN0YXJ0IGF1dG9tYXRpY2FsbHkgd2hlblxuICAgKiBpbml0aWFsaXplZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQ2FsbGJhY2sgZm9yIHdoZW4gdGhlIHRpbWVyIGV4cGlyZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWxheSBUaW1lciBsZW5ndGggaW4gbWlsbGlzZWNvbmRzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjb250aW51b3VzXSBJZiB0cnVlLCB0aGUgdGltZXIgd2lsbCBhdXRvbWF0aWNhbGx5XG4gICAqICAgICByZXN0YXJ0IGl0c2VsZiB3aGVuIGl0IGV4cGlyZXMuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gVGltZXIoZm4sIGRlbGF5KSB7XG4gICAgdmFyIGNvbnRpbnVvdXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRpbWVyKTtcblxuICAgIHRoaXMudGltZXJJZCA9IG51bGw7XG4gICAgdGhpcy5zdGFydFRpbWUgPSBudWxsO1xuICAgIHRoaXMuaXNQYXVzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmlzVGlja2luZyA9IGZhbHNlO1xuICAgIHRoaXMuaXNDb250aW51b3VzID0gY29udGludW91cztcbiAgICB0aGlzLmRlbGF5ID0gZGVsYXk7XG4gICAgdGhpcy5yZW1haW5pbmcgPSBkZWxheTtcbiAgICB0aGlzLmZuID0gZm47XG5cbiAgICB0aGlzLnJlc3VtZSA9IHRoaXMuc3RhcnQ7XG4gICAgdGhpcy5wYXVzZSA9IHRoaXMuc3RvcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydHMgdGlja2luZyB0aGUgdGltZXIuXG4gICAqIEByZXR1cm4ge251bWJlcnxib29sZWFufSBUaGUgcmVtYWluaW5nIHRpbWUgb3IgZmFsc2UgaWYgdGhlIHRpbWVyIGlzXG4gICAqICAgICBhbHJlYWR5IHRpY2tpbmcuXG4gICAqL1xuXG5cbiAgVGltZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmICh0aGlzLmlzVGlja2luZykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLnRpbWVySWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmZuKCk7XG5cbiAgICAgIC8vIElmIHRoZSB0aW1lciB3YXNuJ3Qgc3RvcHBlZCBpbiB0aGUgY2FsbGJhY2sgYW5kIHRoaXMgaXMgYSBjb250aW51b3VzXG4gICAgICAvLyB0aW1lciwgc3RhcnQgaXQgYWdhaW4uXG4gICAgICBpZiAoIV90aGlzLmlzUGF1c2VkICYmIF90aGlzLmlzQ29udGludW91cykge1xuICAgICAgICBfdGhpcy5yZXN0YXJ0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy5yZXNldCgpO1xuICAgICAgfVxuICAgIH0sIHRoaXMucmVtYWluaW5nKTtcbiAgICB0aGlzLmlzVGlja2luZyA9IHRydWU7XG4gICAgdGhpcy5pc1BhdXNlZCA9IGZhbHNlO1xuICAgIHJldHVybiB0aGlzLnJlbWFpbmluZztcbiAgfTtcblxuICAvKipcbiAgICogUGF1c2VzIHRoZSB0aW1lci4gUmVzdW1pbmcgd2lsbCBjb250aW51ZSBpdCB3aXRoIHRoZSByZW1haW5pbmcgdGltZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaW1lIHJlbWFpbmluZy5cbiAgICovXG5cblxuICBUaW1lci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgdGhpcy5jbGVhcigpO1xuICAgIHRoaXMucmVtYWluaW5nIC09IERhdGUubm93KCkgLSB0aGlzLnN0YXJ0VGltZTtcbiAgICB0aGlzLmlzUGF1c2VkID0gdHJ1ZTtcbiAgICB0aGlzLmlzVGlja2luZyA9IGZhbHNlO1xuICAgIHJldHVybiB0aGlzLnJlbWFpbmluZztcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB0aW1lIHJlbWFpbmluZyB0byBpbml0aWFsIGRlbGF5IGFuZCBjbGVhcnMgdGltZXIuXG4gICAqL1xuXG5cbiAgVGltZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgdGhpcy5yZW1haW5pbmcgPSB0aGlzLmRlbGF5O1xuICAgIHRoaXMuY2xlYXIoKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVzZXRzIHRoZSB0aW1lciB0byB0aGUgb3JpZ2luYWwgZGVsYXksIGNsZWFycyB0aGUgY3VycmVudCB0aW1lciwgYW5kXG4gICAqIHN0YXJ0cyB0aGUgdGltZXIgYWdhaW4uXG4gICAqL1xuXG5cbiAgVGltZXIucHJvdG90eXBlLnJlc3RhcnQgPSBmdW5jdGlvbiByZXN0YXJ0KCkge1xuICAgIHRoaXMucmVzZXQoKTtcbiAgICB0aGlzLnJlc3VtZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhcnMgdGltZXIuXG4gICAqL1xuXG5cbiAgVGltZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJJZCk7XG4gICAgdGhpcy5pc1BhdXNlZCA9IGZhbHNlO1xuICAgIHRoaXMuaXNUaWNraW5nID0gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlc3Ryb3kgdGhlIHRpbWVyLlxuICAgKi9cblxuXG4gIFRpbWVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgdGhpcy5mbiA9IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIFRpbWVyO1xufSgpO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIG9mZnNldCBpbmRleCBmb3IgYSBjaXJjdWxhciBsaXN0LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFN0YXJ0aW5nIGluZGV4LlxuICogQHBhcmFtIHtudW1iZXJ9IGRpc3BsYWNlbWVudCBPZmZzZXQgZnJvbSB0aGUgc3RhcnRpbmcgaW5kZXguIENhbiBiZSBuZWdhdGl2ZVxuICogICAgIG9yIHBvc2l0aXZlLiBGb3IgZXhhbXBsZSwgLTIgb3IgMi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggTGVuZ3RoIG9mIHRoZSBsaXN0LlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW5kZXggb2YgdGhlIHJlbGF0aXZlIGRpc3BsYWNlbWVudCwgd3JhcHBpbmcgYXJvdW5kXG4gKiAgICAgdGhlIGVuZCBvZiB0aGUgbGlzdCB0byB0aGUgc3RhcnQgd2hlbiB0aGUgZGlzcGxhY2VtZW50IGlzIGxhcmdlciB0aGFuXG4gKiAgICAgd2hhdCdzIGxlZnQgaW4gdGhlIGxpc3QuXG4gKi9cbmZ1bmN0aW9uIHdyYXBBcm91bmRMaXN0KGluZGV4LCBkaXNwbGFjZW1lbnQsIGxlbmd0aCkge1xuICByZXR1cm4gKGluZGV4ICsgZGlzcGxhY2VtZW50ICsgbGVuZ3RoICogMTApICUgbGVuZ3RoO1xufVxuXG5leHBvcnQgeyBnZXRUcmFuc2l0aW9ucywgQ2xhc3NlcyBhcyBhbmltYXRpb25DbGFzc2VzLCBTdGVwcGVyLCBCb3gsIGNhbmNlbFRyYW5zaXRpb25FbmQsIGNhcGl0YWxpemUsIGNhdXNlTGF5b3V0LCBjaHVuaywgY2xhbXAsIGNsb3Nlc3RHcmVhdGVyVGhhbiwgY2xvc2VzdExlc3NUaGFuLCBjbG9zZXN0LCBDb29yZGluYXRlLCBkZWZhdWx0c1RvLCBkb21Mb2FkZWQsIGRvbVJlYWR5LCBldmVuSGVpZ2h0cywgZXZlbnRzLCBmYWRlSW5FbGVtZW50LCBmYWRlT3V0RWxlbWVudCwgZm9yY2VSZWRyYXcsIGdldEVsZW1lbnRzU2l6ZSwgZ2V0SU9TVmVyc2lvbiwgZ2V0TWFyZ2luQm94LCBnZXROdGhTaWJsaW5nLCBnZXROdW1iZXJPcHRpb24sIGdldFBhZGRpbmdCb3gsIGdldFBlcmNlbnRhZ2VPcHRpb24sIGdldFJlbGF0aXZlRGVwdGgsIGdldFNpemUsIGdldFN0cmluZ09wdGlvbiwgZ2l2ZUlkLCBoYXNTY3JvbGxFdmVudHMsIGh5cGhlbmF0ZSwgaXNBbmRyb2lkT1MsIGlzQ2hyb21lLCBpc0RlZmluZWQsIGlzRWRnZSwgaXNJRSwgaXNJT1MsIGlzTmF0aXZlQW5kcm9pZCwgaXNTdHJpbmcsIG5vb3AsIG9uQW5pbWF0aW9uRW5kLCBvblRyYW5zaXRpb25FbmQsIHB1bGwsIHJhbmRvbSBhcyByYW5kb21TdHJpbmcsIFJlY3QsIHJlbW92ZUNoaWxkcmVuLCByZXBsYWNlV2l0aEhhc2gsIHNjcm9sbFRvIGFzIHNjcm9sbFRvVG9wLCBzY3JvbGxUbywgc2V0SGFzaCwgc3dhcEVsZW1lbnRzLCBUaW1lciwgd3JhcEFyb3VuZExpc3QgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9kby1oZWxwZXJzLmVzbS5qcy5tYXBcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@odopod/odo-helpers/dist/odo-helpers.esm.js\n");

/***/ }),

/***/ "./node_modules/@odopod/odo-pointer/dist/odo-pointer.esm.js":
/*!******************************************************************!*\
  !*** ./node_modules/@odopod/odo-pointer/dist/odo-pointer.esm.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @odopod/odo-helpers */ \"./node_modules/@odopod/odo-helpers/dist/odo-helpers.esm.js\");\n/* harmony import */ var tiny_emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tiny-emitter */ \"./node_modules/tiny-emitter/index.js\");\n/* harmony import */ var tiny_emitter__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(tiny_emitter__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _odopod_odo_device__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @odopod/odo-device */ \"./node_modules/@odopod/odo-device/dist/odo-device.esm.js\");\n\n\n\n\n/** @enum {string} */\nvar Direction = {\n  RIGHT: 'right',\n  LEFT: 'left',\n  UP: 'up',\n  DOWN: 'down',\n  NONE: 'no_movement'\n};\n\n/** @enum {string} */\nvar Axis = {\n  X: 'x',\n  Y: 'y',\n  BOTH: 'xy'\n};\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nfunction isXAxis(axis) {\n  return axis === Axis.X;\n}\n\nfunction isYAxis(axis) {\n  return axis === Axis.Y;\n}\n\nfunction isBothAxis(axis) {\n  return axis === Axis.BOTH;\n}\n\nfunction hasDirection(direction) {\n  return direction !== Direction.NONE;\n}\n\nfunction finiteOrZero(velocity) {\n  return Number.isFinite(velocity) ? velocity : 0;\n}\n\n/**\n * Calculate the velocity between two points.\n *\n * @param {number} deltaTime Change in time.\n * @param {number} deltaX Change in x.\n * @param {number} deltaY Change in y.\n * @return {Coordinate} Velocity of the drag.\n */\n\nfunction getVelocity(deltaTime, deltaX, deltaY) {\n  return new _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"Coordinate\"](finiteOrZero(deltaX / deltaTime), finiteOrZero(deltaY / deltaTime));\n}\n\nfunction getTheDirection(value1, value2, isGreater, isLess, isEqual) {\n  if (value1 - value2 > 0) {\n    return isGreater;\n  } else if (value1 - value2 < 0) {\n    return isLess;\n  }\n\n  return isEqual;\n}\n\n/**\n * angle to direction define.\n * @param {Coordinate} coord1 The starting coordinate.\n * @param {Coordinate} coord2 The ending coordinate.\n * @return {string} Direction constant.\n */\nfunction getDirection(coord1, coord2) {\n  if (Math.abs(coord1.x - coord2.x) >= Math.abs(coord1.y - coord2.y)) {\n    return getTheDirection(coord1.x, coord2.x, Direction.LEFT, Direction.RIGHT, Direction.NONE);\n  }\n\n  return getTheDirection(coord1.y, coord2.y, Direction.UP, Direction.DOWN, Direction.NONE);\n}\n\nfunction isOnAxis(axis, direction) {\n  var isXAndLeftOrRight = isXAxis(axis) && (direction === Direction.LEFT || direction === Direction.RIGHT);\n\n  var isYAndUpOrDown = isYAxis(axis) && (direction === Direction.UP || direction === Direction.DOWN);\n\n  var isBothAndNotNone = isBothAxis(axis) && hasDirection(direction);\n\n  return isXAndLeftOrRight || isYAndUpOrDown || isBothAndNotNone;\n}\n\nfunction didMoveOnAxis(axis, direction, deltaX, deltaY) {\n  // X axis and deltaX > 0\n  return isXAxis(axis) && Math.abs(deltaX) > 0 ||\n\n  // Y axis and deltaY > 0\n  isYAxis(axis) && Math.abs(deltaY) > 0 ||\n\n  // Both axis, as long as it actually moved.\n  isBothAxis(axis) && hasDirection(direction);\n}\n\nfunction getAxisDirection(axis, start, end) {\n  var _start = Object.assign({}, start);\n  var _end = Object.assign({}, end);\n\n  if (isXAxis(axis)) {\n    _start.y = 0;\n    _end.y = 0;\n  } else if (isYAxis(axis)) {\n    _start.x = 0;\n    _end.x = 0;\n  }\n\n  return getDirection(_start, _end);\n}\n\nvar PointerEvent = function () {\n  /**\n   * Object representing a drag event.\n   * @param {Object} options Options object.\n   * @param {string} options.type Event type.\n   * @param {Element} options.target Element the event is happening on.\n   * @param {Coordinate} options.delta Total movement of the pointer (with friction\n   *     already applied to it).\n   * @param {Coordinate} options.currentVelocity Calculated velocity since the last interval.\n   * @constructor\n   */\n  function PointerEvent(options) {\n    classCallCheck(this, PointerEvent);\n\n    this.type = options.type;\n\n    /**\n     * @type {Element}\n     */\n    this.target = options.target;\n\n    /**\n     * @type {Element}\n     */\n    this.currentTarget = options.currentTarget;\n\n    /**\n     * Starting location of the pointer.\n     * @type {Coordinate}\n     */\n    this.start = options.start;\n\n    /**\n     * Ending location of the pointer.\n     * @type {Coordinate}\n     */\n    this.end = options.end;\n\n    /**\n     * Change in position since the start of the drag.\n     * @type {Coordinate}\n     */\n    this.delta = options.delta;\n\n    /**\n     * Time elapsed from mouse/touch down to mouse/touch up.\n     * @type {number}\n     */\n    this.deltaTime = options.deltaTime;\n\n    /**\n     * Velocity of the whole drag.\n     * @type {Coordinate}\n     */\n    this.velocity = getVelocity(this.deltaTime, this.delta.x, this.delta.y);\n\n    /**\n     * The velocity in the last 100 milliseconds.\n     * @type {Coordinate}\n     */\n    this.currentVelocity = options.currentVelocity;\n\n    /**\n     * Distance dragged.\n     * @type {number}\n     */\n    this.distance = _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"Coordinate\"].distance(options.start, options.end);\n\n    /**\n     * Direction of drag.\n     * @type {Direction}\n     */\n    this.direction = getDirection(options.start, options.end);\n\n    /**\n     * Whether the drag direction is on the axis of the draggable element.\n     * @type {boolean}\n     */\n    this.isDirectionOnAxis = isOnAxis(options.axis, this.direction);\n\n    /**\n     * Whether the draggable element moved along the dragging axis at all.\n     * @type {boolean}\n     */\n    this.didMoveOnAxis = didMoveOnAxis(options.axis, this.direction, this.delta.x, this.delta.y);\n\n    /**\n     * Direction of drag which excludes directions not on its axis.\n     * @type {Direction}\n     */\n    this.axisDirection = getAxisDirection(options.axis, options.start, options.end);\n\n    /** @type {{pixel: Coordinate, percent: Coordinate}} */\n    this.position = options.position;\n\n    /** @type {boolean} Whether `preventDefault` has been called. */\n    this.defaultPrevented = false;\n  }\n\n  PointerEvent.prototype.preventDefault = function preventDefault() {\n    this.defaultPrevented = true;\n  };\n\n  return PointerEvent;\n}();\n\n/**\n * @fileoverview An abstraction for pointer, mouse, and touch events.\n *\n * @author Glen Cheney <glen@odopod.com>\n */\n\nvar Pointer = function (_TinyEmitter) {\n  inherits(Pointer, _TinyEmitter);\n\n  /**\n   * An abstraction layer for adding pointer events and calculating drag values.\n   * @param {HTMLElement} element Element to watch.\n   * @param {PointerOptions} options Options object.\n   * @throws {TypeError} Throws when the element parameter isn't an element.\n   */\n  function Pointer(element) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    classCallCheck(this, Pointer);\n\n    var _this = possibleConstructorReturn(this, _TinyEmitter.call(this));\n\n    if (!element || element.nodeType !== 1) {\n      throw new TypeError('OdoPointer requires an element.');\n    }\n\n    /**\n     * @type {PointerOptions}\n     */\n    _this.options = Object.assign({}, Pointer.Defaults, options);\n\n    /**\n     * The draggable element.\n     * @type {HTMLElement}\n     * @private\n     */\n    _this.element = element;\n\n    /**\n     * Starting location of the drag.\n     * @type {Coordinate}\n     */\n    _this.pageStart = new _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"Coordinate\"]();\n\n    /**\n     * Current position of mouse or touch relative to the document.\n     * @type {Coordinate}\n     */\n    _this.page = new _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"Coordinate\"]();\n\n    /**\n     * Current position of drag relative to target's parent.\n     * @type {Coordinate}\n     */\n    _this.delta = new _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"Coordinate\"]();\n\n    /**\n     * Used to track the current velocity. It is updated when the velocity is.\n     * @type {Coordinate}\n     * @private\n     */\n    _this._lastPosition = new _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"Coordinate\"]();\n\n    /**\n     * Friction to apply to dragging. A value of zero would result in no dragging,\n     * 0.5 would result in the draggable element moving half as far as the user\n     * dragged, and 1 is a 1:1 ratio with user movement.\n     * @type {number}\n     */\n    _this._friction = 1;\n\n    /**\n     * Flag indicating dragging has happened. It is set on dragmove and reset\n     * after the draggableend event has been dispatched.\n     * @type {boolean}\n     */\n    _this.hasDragged = false;\n\n    /**\n     * Whether the user is locked in place within the draggable element. This\n     * is set to true when `preventDefault` is called on the move event.\n     * @type {boolean}\n     * @private\n     */\n    _this._isLocked = false;\n\n    /**\n     * Whether dragging is enabled internally. If the user attempts to scroll\n     * in the opposite direction of the draggable element, this is set to true\n     * and no more drag move events are counted until the user releases and\n     * starts dragging again.\n     * @type {boolean}\n     * @private\n     */\n    _this._isDeactivated = false;\n\n    /**\n     * Whether dragging is currently enabled.\n     * @type {boolean}\n     * @private\n     */\n    _this._enabled = true;\n\n    /**\n     * Id from setInterval to update the velocity.\n     * @type {number}\n     * @private\n     */\n    _this._velocityTrackerId = null;\n\n    /**\n     * Time in milliseconds when the drag started.\n     * @type {number}\n     */\n    _this.startTime = 0;\n\n    /**\n     * Length of the drag in milliseconds.\n     * @type {number}\n     */\n    _this.deltaTime = 0;\n\n    /**\n     * Used to keep track of the current velocity, it's updated with every velocity update.\n     * @type {number}\n     * @private\n     */\n    _this._lastTime = 0;\n\n    /**\n     * The current velocity of the drag.\n     * @type {Coordinate}\n     */\n    _this.velocity = new _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"Coordinate\"]();\n\n    /**\n     * Whether the velocity has been tracked at least once during the drag.\n     * @type {boolean}\n     */\n    _this._hasTrackedVelocity = false;\n\n    /**\n     * The element to which the move and up events will be bound to. If a pointer\n     * is being used inside a modal which stops events from bubbling to the body,\n     * this property should be changed to an element which *will* receive the events.\n     * @type {Document|Element}\n     */\n    _this.dragEventTarget = document;\n\n    var touchAction = Pointer.TouchActionSupport[_this.options.axis];\n\n    /**\n     * Whether the browser supports the `touch-action` property associated with\n     * the axis.\n     * @type {boolean}\n     */\n    _this._isTouchActionSupported = !!touchAction;\n\n    // If the browser supports the touch action property, add it.\n    if (_this.options.preventEventDefault && _this._isTouchActionSupported) {\n      _this.element.style[touchAction] = Pointer.TouchAction[_this.options.axis];\n    } else if (_this.options.preventEventDefault && _odopod_odo_device__WEBPACK_IMPORTED_MODULE_2__[\"default\"].HAS_TOUCH_EVENTS) {\n      window.addEventListener(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"events\"].TOUCHMOVE, _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"noop\"]);\n    }\n\n    _this.listen();\n    return _this;\n  }\n\n  Pointer.prototype.listen = function listen() {\n    this._onStart = this._handleDragStart.bind(this);\n\n    if (_odopod_odo_device__WEBPACK_IMPORTED_MODULE_2__[\"default\"].HAS_POINTER_EVENTS) {\n      this.element.addEventListener(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"events\"].POINTERDOWN, this._onStart);\n    } else {\n      this.element.addEventListener(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"events\"].MOUSEDOWN, this._onStart);\n\n      if (_odopod_odo_device__WEBPACK_IMPORTED_MODULE_2__[\"default\"].HAS_TOUCH_EVENTS) {\n        this.element.addEventListener(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"events\"].TOUCHSTART, this._onStart);\n      }\n    }\n\n    // Prevent images, links, etc from being dragged around.\n    // http://www.html5rocks.com/en/tutorials/dnd/basics/\n    this.element.addEventListener(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"events\"].DRAGSTART, Pointer._preventDefault);\n  };\n\n  /**\n   * Get whether dragger is enabled.\n   * @return {boolean} Whether dragger is enabled.\n   */\n\n\n  /**\n   * @return {boolean} Whether the draggable axis is the x direction.\n   */\n  Pointer.prototype.isXAxis = function isXAxis() {\n    return this.options.axis === Pointer.Axis.X;\n  };\n\n  /**\n   * @return {boolean} Whether the draggable axis is the y direction.\n   */\n\n\n  Pointer.prototype.isYAxis = function isYAxis() {\n    return this.options.axis === Pointer.Axis.Y;\n  };\n\n  /**\n   * @return {boolean} Whether the draggable axis is for both axis.\n   */\n\n\n  Pointer.prototype.isBothAxis = function isBothAxis() {\n    return this.options.axis === Pointer.Axis.BOTH;\n  };\n\n  /**\n   * Retrieve the friction value.\n   * @return {number}\n   */\n\n\n  /**\n   * Apply a friction value to a coordinate, reducing its value.\n   * This modifies the coordinate given to it.\n   * @param {Coordinate} coordinate The coordinate to scale.\n   * @return {Coordinate} Position multiplied by friction.\n   */\n  Pointer.prototype.applyFriction = function applyFriction(coordinate) {\n    return coordinate.scale(this.friction);\n  };\n\n  /**\n   * If draggable is enabled and it's a left click with the mouse,\n   * dragging can start.\n   * @param {TouchEvent|MouseEvent|PointerEvent} evt Event object.\n   * @return {boolean}\n   * @private\n   */\n\n\n  Pointer.prototype._canStartDrag = function _canStartDrag(evt) {\n    return this.isEnabled && (Pointer.isTouchEvent(evt) || evt.button === 0);\n  };\n\n  /**\n   * Whether drag move should happen or exit early.\n   * @return {boolean}\n   * @private\n   */\n\n\n  Pointer.prototype._canContinueDrag = function _canContinueDrag() {\n    return this.isEnabled && !this._isDeactivated;\n  };\n\n  /**\n   * Drag start handler.\n   * @param {TouchEvent|MouseEvent|PointerEvent} evt The drag event object.\n   * @private\n   */\n\n\n  Pointer.prototype._handleDragStart = function _handleDragStart(evt) {\n    // Clear any active tracking interval.\n    clearInterval(this._velocityTrackerId);\n\n    // Must be left click to drag.\n    if (!this._canStartDrag(evt)) {\n      return;\n    }\n\n    this._setDragStartValues(Pointer._getPageCoordinate(evt));\n\n    // Give a hook to others\n    var isPrevented = this._emitEvent(this._createEvent(Pointer.EventType.START, evt));\n\n    if (!isPrevented) {\n      this._addDragHandlers(evt.type);\n\n      // Every interval, calculate the current velocity of the drag.\n      this._velocityTrackerId = setInterval(this._trackVelocity.bind(this), Pointer.VELOCITY_INTERVAL);\n    }\n  };\n\n  /**\n   * Drag move, after applyDraggableElementPosition has happened\n   * @param {TouchEvent|MouseEvent|PointerEvent} evt The dragger event.\n   * @private\n   */\n\n\n  Pointer.prototype._handleDragMove = function _handleDragMove(evt) {\n    if (!this._canContinueDrag()) {\n      return;\n    }\n\n    this._setDragMoveValues(Pointer._getPageCoordinate(evt));\n\n    var isPrevented = this._emitEvent(this._createEvent(Pointer.EventType.MOVE, evt));\n\n    // Abort if the developer prevented default on the custom event or if the\n    // browser supports touch-action (which will do the \"locking\" for us).\n    if (!isPrevented && this.options.preventEventDefault && !this._isTouchActionSupported) {\n      this._finishDragMove(evt);\n    }\n  };\n\n  /**\n   * Finish the drag move function.\n   * @param {TouchEvent|MouseEvent|PointerEvent} evt Event object.\n   * @private\n   */\n\n\n  Pointer.prototype._finishDragMove = function _finishDragMove(evt) {\n    // Possibly lock the user to only dragging.\n    this._maybeLock();\n\n    // Possibly stop draggable from affecting the element.\n    this._maybeDeactivate();\n\n    // Locked into dragging.\n    if (this._isLocked) {\n      evt.preventDefault();\n    }\n\n    // Disregard drags and velocity.\n    if (this._isDeactivated) {\n      clearInterval(this._velocityTrackerId);\n      this.velocity.x = 0;\n      this.velocity.y = 0;\n    }\n  };\n\n  /**\n   * Dragging ended.\n   * @private\n   */\n\n\n  Pointer.prototype._handleDragEnd = function _handleDragEnd(evt) {\n    clearInterval(this._velocityTrackerId);\n    this.deltaTime = Date.now() - this.startTime;\n\n    // If this was a quick drag, the velocity might not have been tracked once.\n    if (!this._hasTrackedVelocity) {\n      this._trackVelocity();\n    }\n\n    // Prevent mouse events from occurring after touchend.\n    this._removeDragHandlers();\n\n    var endEvent = this._createEvent(Pointer.EventType.END, evt);\n    endEvent.isCancelEvent = Pointer._isCancelEvent(evt);\n\n    // Emit an event.\n    var isPrevented = this._emitEvent(endEvent);\n\n    if (isPrevented) {\n      evt.preventDefault();\n    }\n\n    this.hasDragged = false;\n    this._isDeactivated = false;\n    this._isLocked = false;\n  };\n\n  /**\n   * Set the starting values for dragging.\n   * @param {Coordinate} pagePosition The page position coordinate.\n   * @private\n   */\n\n\n  Pointer.prototype._setDragStartValues = function _setDragStartValues(pagePosition) {\n    this.pageStart = pagePosition;\n    this.page = pagePosition;\n    this._lastPosition = pagePosition;\n    this.delta = new _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"Coordinate\"]();\n    this.velocity = new _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"Coordinate\"]();\n    this._hasTrackedVelocity = false;\n\n    this.startTime = Date.now();\n    this._lastTime = Date.now();\n    this.deltaTime = 0;\n  };\n\n  /**\n   * Set the values for dragging during a drag move.\n   * @param {Coordinate} pagePosition The page position coordinate.\n   * @private\n   */\n\n\n  Pointer.prototype._setDragMoveValues = function _setDragMoveValues(pagePosition) {\n    // Get the distance since the last move.\n    var lastDelta = _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"Coordinate\"].difference(pagePosition, this.page);\n\n    // Apply friction to the distance since last move.\n    this.applyFriction(lastDelta);\n\n    // Update the total delta value.\n    this.delta.translate(lastDelta);\n\n    this.page = pagePosition;\n    this.deltaTime = Date.now() - this.startTime;\n    this.hasDragged = true;\n  };\n\n  /**\n   * Once the user has moved past the lock threshold, keep it locked.\n   * @private\n   */\n\n\n  Pointer.prototype._maybeLock = function _maybeLock() {\n    if (!this._isLocked) {\n      // Prevent scrolling if the user has moved past the locking threshold.\n      this._isLocked = this._shouldLock(this.delta);\n    }\n  };\n\n  /**\n   * Once the user has moved past the drag threshold, keep it deactivated.\n   * @private\n   */\n\n\n  Pointer.prototype._maybeDeactivate = function _maybeDeactivate() {\n    if (!this._isDeactivated) {\n      // Disable dragging if the user is attempting to go the opposite direction\n      // of the draggable element.\n      this._isDeactivated = this._shouldDeactivate(this.delta);\n    }\n  };\n\n  /**\n   * @param {Coordinate} delta Amount the pointer has moved since it started.\n   * @return {boolean} Whether Draggable should lock the user into draggable only.\n   * @private\n   */\n\n\n  Pointer.prototype._shouldLock = function _shouldLock(delta) {\n    var pastX = this.isXAxis() && Math.abs(delta.x) > Pointer.LOCK_THRESHOLD;\n    var pastY = this.isYAxis() && Math.abs(delta.y) > Pointer.LOCK_THRESHOLD;\n    return this.isBothAxis() || pastX || pastY;\n  };\n\n  /**\n   * @param {Coordinate} delta Amount the pointer has moved since it started.\n   * @return {boolean} Whether Draggable should stop affecting the draggable element.\n   * @private\n   */\n\n\n  Pointer.prototype._shouldDeactivate = function _shouldDeactivate(delta) {\n    var pastX = this.isXAxis() && Math.abs(delta.y) > Pointer.DRAG_THRESHOLD;\n    var pastY = this.isYAxis() && Math.abs(delta.x) > Pointer.DRAG_THRESHOLD;\n    return !this._isLocked && (this.isBothAxis() || pastX || pastY);\n  };\n\n  /**\n   * Make a new event with data.\n   * @param {Pointer.EventType} type Event type.\n   * @param {Event} evt Native event object.\n   * @return {!Pointer.Event}\n   * @private\n   */\n\n\n  Pointer.prototype._createEvent = function _createEvent(type, evt) {\n    return new Pointer.Event({\n      type: type,\n      pointerId: this.id,\n      currentTarget: this.element,\n      target: evt.target,\n      axis: this.options.axis,\n      deltaTime: this.deltaTime,\n      delta: this.delta,\n      start: this.pageStart,\n      end: this.page,\n      currentVelocity: this.velocity\n    });\n  };\n\n  /**\n   * Binds events to the document for move, end, and cancel (if cancel events\n   * exist for the device).\n   * @param {string} startType The type of event which started the drag. It\n   *     is important that the mouse events are not bound when a touch event\n   *     is triggered otherwise the events could be doubled.\n   * @private\n   */\n\n\n  Pointer.prototype._addDragHandlers = function _addDragHandlers(startType) {\n    var target = this.dragEventTarget;\n    this._onMove = this._handleDragMove.bind(this);\n    this._onEnd = this._handleDragEnd.bind(this);\n\n    switch (startType) {\n      case _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"events\"].POINTERDOWN:\n        target.addEventListener(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"events\"].POINTERMOVE, this._onMove);\n        target.addEventListener(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"events\"].POINTERUP, this._onEnd);\n        target.addEventListener(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"events\"].POINTERCANCEL, this._onEnd);\n        break;\n      case _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"events\"].MOUSEDOWN:\n        target.addEventListener(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"events\"].MOUSEMOVE, this._onMove);\n        target.addEventListener(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"events\"].MOUSEUP, this._onEnd);\n        break;\n      case _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"events\"].TOUCHSTART:\n        target.addEventListener(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"events\"].TOUCHMOVE, this._onMove);\n        target.addEventListener(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"events\"].TOUCHEND, this._onEnd);\n        target.addEventListener(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"events\"].TOUCHCANCEL, this._onEnd);\n        break;\n      // no default\n    }\n  };\n\n  /**\n   * Removes the events bound during drag start. The draggable namespace can be\n   * used to remove all of them because the drag start event is still bound\n   * to the actual element.\n   */\n\n\n  Pointer.prototype._removeDragHandlers = function _removeDragHandlers() {\n    var target = this.dragEventTarget;\n    target.removeEventListener(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"events\"].POINTERMOVE, this._onMove);\n    target.removeEventListener(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"events\"].POINTERUP, this._onEnd);\n    target.removeEventListener(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"events\"].POINTERCANCEL, this._onEnd);\n    target.removeEventListener(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"events\"].MOUSEMOVE, this._onMove);\n    target.removeEventListener(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"events\"].MOUSEUP, this._onEnd);\n    target.removeEventListener(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"events\"].TOUCHMOVE, this._onMove);\n    target.removeEventListener(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"events\"].TOUCHEND, this._onEnd);\n    target.removeEventListener(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"events\"].TOUCHCANCEL, this._onEnd);\n  };\n\n  /**\n   * Every 100 milliseconds, calculate the current velocity with a moving average.\n   * http://ariya.ofilabs.com/2013/11/javascript-kinetic-scrolling-part-2.html\n   * @private\n   */\n\n\n  Pointer.prototype._trackVelocity = function _trackVelocity() {\n    var now = Date.now();\n    var elapsed = now - this._lastTime;\n    var delta = _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"Coordinate\"].difference(this.page, this._lastPosition);\n    this.applyFriction(delta);\n    this._lastTime = now;\n    this._lastPosition = this.page;\n\n    // velocity = delta / time.\n    // Clamp the velocity to avoid outliers.\n    var maxVelocity = Pointer.MAX_VELOCITY;\n    this.velocity.x = Object(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"clamp\"])(delta.x / elapsed, -maxVelocity, maxVelocity);\n    this.velocity.y = Object(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"clamp\"])(delta.y / elapsed, -maxVelocity, maxVelocity);\n\n    this._hasTrackedVelocity = true;\n  };\n\n  /**\n   * Determine whether the draggable event has enough velocity to be\n   * considered a swipe.\n   * @param {Object} velocity Object with x and y properties for velocity.\n   * @param {number} [threshold] Threshold to check against. Defaults to the swipe\n   *     velocity constant. Must be zero or a positive number.\n   * @return {boolean}\n   */\n\n\n  Pointer.prototype.hasVelocity = function hasVelocity(velocity) {\n    var threshold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Pointer.SWIPE_VELOCITY;\n\n    if (this.isYAxis()) {\n      return Math.abs(velocity.y) > threshold;\n    }\n\n    if (this.isXAxis()) {\n      return Math.abs(velocity.x) > threshold;\n    }\n\n    // Otherwise check both axis for velocity.\n    return Math.abs(velocity.x) > threshold || Math.abs(velocity.y) > threshold;\n  };\n\n  /**\n   * Emits a event on this instance.\n   * @param {PointerEvent} event Event object with data.\n   * @return {boolean} Whether preventDefault was called on the event.\n   */\n\n\n  Pointer.prototype._emitEvent = function _emitEvent(event) {\n    this.emit(event.type, event);\n    return event.defaultPrevented;\n  };\n\n  /**\n   * Remove event listeners and element references.\n   */\n\n\n  Pointer.prototype.dispose = function dispose() {\n    clearInterval(this._velocityTrackerId);\n    this._removeDragHandlers();\n\n    // Remove pointer/mouse/touch events.\n    this.element.removeEventListener(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"events\"].POINTERDOWN, this._onStart);\n    this.element.removeEventListener(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"events\"].MOUSEDOWN, this._onStart);\n    this.element.removeEventListener(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"events\"].TOUCHSTART, this._onStart);\n\n    if (this._isTouchActionSupported) {\n      this.element.style[Pointer.TouchActionSupport[this.options.axis]] = '';\n    } else if (this.options.preventEventDefault && _odopod_odo_device__WEBPACK_IMPORTED_MODULE_2__[\"default\"].HAS_TOUCH_EVENTS) {\n      window.removeEventListener(_odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"events\"].TOUCHMOVE, _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"noop\"]);\n    }\n\n    this.element = null;\n    this.dragEventTarget = null;\n  };\n\n  /**\n   * Whether the event is from a touch.\n   * @param {object} evt Event object.\n   * @return {boolean}\n   */\n\n\n  Pointer.isTouchEvent = function isTouchEvent(evt) {\n    return !!evt.changedTouches;\n  };\n\n  /**\n   * Whether the event is from a pointer cancel or touch cancel.\n   * @param {TouchEvent|MouseEvent|PointerEvent} evt Event object.\n   * @return {boolean}\n   * @private\n   */\n\n\n  Pointer._isCancelEvent = function _isCancelEvent(evt) {\n    return evt.type === _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"events\"].POINTERCANCEL || evt.type === _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"events\"].TOUCHCANCEL;\n  };\n\n  /**\n   * Retrieve the page x and page y based on an event. It normalizes\n   * touch events, mouse events, and pointer events.\n   * @param {TouchEvent|MouseEvent|PointerEvent} evt Event object.\n   * @return {!Coordinate} The pageX and pageY of the press.\n   * @private\n   */\n\n\n  Pointer._getPageCoordinate = function _getPageCoordinate(evt) {\n    var pagePoints = void 0;\n\n    // Use the first touch for the pageX and pageY.\n    if (Pointer.isTouchEvent(evt)) {\n      pagePoints = evt.changedTouches[0]; // eslint-disable-line prefer-destructuring\n    } else {\n      pagePoints = evt;\n    }\n\n    return new _odopod_odo_helpers__WEBPACK_IMPORTED_MODULE_0__[\"Coordinate\"](pagePoints.pageX, pagePoints.pageY);\n  };\n\n  Pointer._preventDefault = function _preventDefault(evt) {\n    evt.preventDefault();\n  };\n\n  createClass(Pointer, [{\n    key: 'isEnabled',\n    get: function get$$1() {\n      return this._enabled;\n    }\n\n    /**\n     * Set whether dragger is enabled.\n     * @param {boolean} enabled Whether dragger is enabled.\n     */\n    ,\n    set: function set$$1(enabled) {\n      this._enabled = enabled;\n    }\n  }, {\n    key: 'friction',\n    get: function get$$1() {\n      return this._friction;\n    }\n\n    /**\n     * Set the friction value.\n     * @param {number} friction A number between [1, 0].\n     */\n    ,\n    set: function set$$1(friction) {\n      this._friction = friction;\n    }\n  }]);\n  return Pointer;\n}(tiny_emitter__WEBPACK_IMPORTED_MODULE_1___default.a);\n\n/** @enum {string} */\n\n\nPointer.Direction = Direction;\n\n/** @enum {string} */\nPointer.Axis = Axis;\n\n/** @enum {string} */\nPointer.EventType = {\n  START: 'odopointer:start',\n  MOVE: 'odopointer:move',\n  END: 'odopointer:end'\n};\n\n/** @enum {string|boolean} */\nPointer.TouchActionSupport = {\n  x: _odopod_odo_device__WEBPACK_IMPORTED_MODULE_2__[\"default\"].prefixed('touchAction', 'pan-y'),\n  y: _odopod_odo_device__WEBPACK_IMPORTED_MODULE_2__[\"default\"].prefixed('touchAction', 'pan-x'),\n  xy: _odopod_odo_device__WEBPACK_IMPORTED_MODULE_2__[\"default\"].prefixed('touchAction', 'none')\n};\n\n/** @enum {string} */\nPointer.TouchAction = {\n  x: 'pan-y',\n  y: 'pan-x',\n  xy: 'none'\n};\n\n/**\n * @typedef {{axis: Axis, preventEventDefault: boolean}} PointerOptions\n */\n\n/** @type {PointerOptions} */\nPointer.Defaults = {\n  axis: 'xy',\n  preventEventDefault: true\n};\n\n/**\n * The current velocity property will be clamped to this value (pixels/millisecond).\n * @const {number}\n */\nPointer.MAX_VELOCITY = 12;\n\n/**\n * When the pointer is down, an interval starts to track the current velocity.\n * @const {number}\n */\nPointer.VELOCITY_INTERVAL = 100;\n\n/**\n * Velocity required for a movement to be considered a swipe.\n * @const {number}\n */\nPointer.SWIPE_VELOCITY = 0.6;\n\n/**\n * The scroll/drag amount (pixels) required on the draggable axis before\n * stopping further page scrolling/movement.\n * @const {number}\n */\nPointer.LOCK_THRESHOLD = 6;\n\n/**\n * The scroll/drag amount (pixels) required on the opposite draggable axis\n * before dragging is deactivated for the rest of the interaction.\n * @const {number}\n */\nPointer.DRAG_THRESHOLD = 5;\n\nPointer.Event = PointerEvent;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Pointer);\n//# sourceMappingURL=odo-pointer.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG9kb3BvZC9vZG8tcG9pbnRlci9kaXN0L29kby1wb2ludGVyLmVzbS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ab2RvcG9kL29kby1wb2ludGVyL2Rpc3Qvb2RvLXBvaW50ZXIuZXNtLmpzP2Y4NzMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29vcmRpbmF0ZSwgY2xhbXAsIGV2ZW50cywgbm9vcCB9IGZyb20gJ0BvZG9wb2Qvb2RvLWhlbHBlcnMnO1xuaW1wb3J0IFRpbnlFbWl0dGVyIGZyb20gJ3RpbnktZW1pdHRlcic7XG5pbXBvcnQgT2RvRGV2aWNlIGZyb20gJ0BvZG9wb2Qvb2RvLWRldmljZSc7XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xudmFyIERpcmVjdGlvbiA9IHtcbiAgUklHSFQ6ICdyaWdodCcsXG4gIExFRlQ6ICdsZWZ0JyxcbiAgVVA6ICd1cCcsXG4gIERPV046ICdkb3duJyxcbiAgTk9ORTogJ25vX21vdmVtZW50J1xufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG52YXIgQXhpcyA9IHtcbiAgWDogJ3gnLFxuICBZOiAneScsXG4gIEJPVEg6ICd4eSdcbn07XG5cbnZhciBjbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG52YXIgY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7XG5cbnZhciBpbmhlcml0cyA9IGZ1bmN0aW9uIChzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn07XG5cbnZhciBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcbiAgaWYgKCFzZWxmKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG59O1xuXG5mdW5jdGlvbiBpc1hBeGlzKGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09IEF4aXMuWDtcbn1cblxuZnVuY3Rpb24gaXNZQXhpcyhheGlzKSB7XG4gIHJldHVybiBheGlzID09PSBBeGlzLlk7XG59XG5cbmZ1bmN0aW9uIGlzQm90aEF4aXMoYXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gQXhpcy5CT1RIO1xufVxuXG5mdW5jdGlvbiBoYXNEaXJlY3Rpb24oZGlyZWN0aW9uKSB7XG4gIHJldHVybiBkaXJlY3Rpb24gIT09IERpcmVjdGlvbi5OT05FO1xufVxuXG5mdW5jdGlvbiBmaW5pdGVPclplcm8odmVsb2NpdHkpIHtcbiAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZSh2ZWxvY2l0eSkgPyB2ZWxvY2l0eSA6IDA7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSB2ZWxvY2l0eSBiZXR3ZWVuIHR3byBwb2ludHMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhVGltZSBDaGFuZ2UgaW4gdGltZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVggQ2hhbmdlIGluIHguXG4gKiBAcGFyYW0ge251bWJlcn0gZGVsdGFZIENoYW5nZSBpbiB5LlxuICogQHJldHVybiB7Q29vcmRpbmF0ZX0gVmVsb2NpdHkgb2YgdGhlIGRyYWcuXG4gKi9cblxuZnVuY3Rpb24gZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCBkZWx0YVgsIGRlbHRhWSkge1xuICByZXR1cm4gbmV3IENvb3JkaW5hdGUoZmluaXRlT3JaZXJvKGRlbHRhWCAvIGRlbHRhVGltZSksIGZpbml0ZU9yWmVybyhkZWx0YVkgLyBkZWx0YVRpbWUpKTtcbn1cblxuZnVuY3Rpb24gZ2V0VGhlRGlyZWN0aW9uKHZhbHVlMSwgdmFsdWUyLCBpc0dyZWF0ZXIsIGlzTGVzcywgaXNFcXVhbCkge1xuICBpZiAodmFsdWUxIC0gdmFsdWUyID4gMCkge1xuICAgIHJldHVybiBpc0dyZWF0ZXI7XG4gIH0gZWxzZSBpZiAodmFsdWUxIC0gdmFsdWUyIDwgMCkge1xuICAgIHJldHVybiBpc0xlc3M7XG4gIH1cblxuICByZXR1cm4gaXNFcXVhbDtcbn1cblxuLyoqXG4gKiBhbmdsZSB0byBkaXJlY3Rpb24gZGVmaW5lLlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZDEgVGhlIHN0YXJ0aW5nIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkMiBUaGUgZW5kaW5nIGNvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IERpcmVjdGlvbiBjb25zdGFudC5cbiAqL1xuZnVuY3Rpb24gZ2V0RGlyZWN0aW9uKGNvb3JkMSwgY29vcmQyKSB7XG4gIGlmIChNYXRoLmFicyhjb29yZDEueCAtIGNvb3JkMi54KSA+PSBNYXRoLmFicyhjb29yZDEueSAtIGNvb3JkMi55KSkge1xuICAgIHJldHVybiBnZXRUaGVEaXJlY3Rpb24oY29vcmQxLngsIGNvb3JkMi54LCBEaXJlY3Rpb24uTEVGVCwgRGlyZWN0aW9uLlJJR0hULCBEaXJlY3Rpb24uTk9ORSk7XG4gIH1cblxuICByZXR1cm4gZ2V0VGhlRGlyZWN0aW9uKGNvb3JkMS55LCBjb29yZDIueSwgRGlyZWN0aW9uLlVQLCBEaXJlY3Rpb24uRE9XTiwgRGlyZWN0aW9uLk5PTkUpO1xufVxuXG5mdW5jdGlvbiBpc09uQXhpcyhheGlzLCBkaXJlY3Rpb24pIHtcbiAgdmFyIGlzWEFuZExlZnRPclJpZ2h0ID0gaXNYQXhpcyhheGlzKSAmJiAoZGlyZWN0aW9uID09PSBEaXJlY3Rpb24uTEVGVCB8fCBkaXJlY3Rpb24gPT09IERpcmVjdGlvbi5SSUdIVCk7XG5cbiAgdmFyIGlzWUFuZFVwT3JEb3duID0gaXNZQXhpcyhheGlzKSAmJiAoZGlyZWN0aW9uID09PSBEaXJlY3Rpb24uVVAgfHwgZGlyZWN0aW9uID09PSBEaXJlY3Rpb24uRE9XTik7XG5cbiAgdmFyIGlzQm90aEFuZE5vdE5vbmUgPSBpc0JvdGhBeGlzKGF4aXMpICYmIGhhc0RpcmVjdGlvbihkaXJlY3Rpb24pO1xuXG4gIHJldHVybiBpc1hBbmRMZWZ0T3JSaWdodCB8fCBpc1lBbmRVcE9yRG93biB8fCBpc0JvdGhBbmROb3ROb25lO1xufVxuXG5mdW5jdGlvbiBkaWRNb3ZlT25BeGlzKGF4aXMsIGRpcmVjdGlvbiwgZGVsdGFYLCBkZWx0YVkpIHtcbiAgLy8gWCBheGlzIGFuZCBkZWx0YVggPiAwXG4gIHJldHVybiBpc1hBeGlzKGF4aXMpICYmIE1hdGguYWJzKGRlbHRhWCkgPiAwIHx8XG5cbiAgLy8gWSBheGlzIGFuZCBkZWx0YVkgPiAwXG4gIGlzWUF4aXMoYXhpcykgJiYgTWF0aC5hYnMoZGVsdGFZKSA+IDAgfHxcblxuICAvLyBCb3RoIGF4aXMsIGFzIGxvbmcgYXMgaXQgYWN0dWFsbHkgbW92ZWQuXG4gIGlzQm90aEF4aXMoYXhpcykgJiYgaGFzRGlyZWN0aW9uKGRpcmVjdGlvbik7XG59XG5cbmZ1bmN0aW9uIGdldEF4aXNEaXJlY3Rpb24oYXhpcywgc3RhcnQsIGVuZCkge1xuICB2YXIgX3N0YXJ0ID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhcnQpO1xuICB2YXIgX2VuZCA9IE9iamVjdC5hc3NpZ24oe30sIGVuZCk7XG5cbiAgaWYgKGlzWEF4aXMoYXhpcykpIHtcbiAgICBfc3RhcnQueSA9IDA7XG4gICAgX2VuZC55ID0gMDtcbiAgfSBlbHNlIGlmIChpc1lBeGlzKGF4aXMpKSB7XG4gICAgX3N0YXJ0LnggPSAwO1xuICAgIF9lbmQueCA9IDA7XG4gIH1cblxuICByZXR1cm4gZ2V0RGlyZWN0aW9uKF9zdGFydCwgX2VuZCk7XG59XG5cbnZhciBQb2ludGVyRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBPYmplY3QgcmVwcmVzZW50aW5nIGEgZHJhZyBldmVudC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnR5cGUgRXZlbnQgdHlwZS5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBvcHRpb25zLnRhcmdldCBFbGVtZW50IHRoZSBldmVudCBpcyBoYXBwZW5pbmcgb24uXG4gICAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gb3B0aW9ucy5kZWx0YSBUb3RhbCBtb3ZlbWVudCBvZiB0aGUgcG9pbnRlciAod2l0aCBmcmljdGlvblxuICAgKiAgICAgYWxyZWFkeSBhcHBsaWVkIHRvIGl0KS5cbiAgICogQHBhcmFtIHtDb29yZGluYXRlfSBvcHRpb25zLmN1cnJlbnRWZWxvY2l0eSBDYWxjdWxhdGVkIHZlbG9jaXR5IHNpbmNlIHRoZSBsYXN0IGludGVydmFsLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIFBvaW50ZXJFdmVudChvcHRpb25zKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9pbnRlckV2ZW50KTtcblxuICAgIHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMudGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQ7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7RWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBvcHRpb25zLmN1cnJlbnRUYXJnZXQ7XG5cbiAgICAvKipcbiAgICAgKiBTdGFydGluZyBsb2NhdGlvbiBvZiB0aGUgcG9pbnRlci5cbiAgICAgKiBAdHlwZSB7Q29vcmRpbmF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLnN0YXJ0ID0gb3B0aW9ucy5zdGFydDtcblxuICAgIC8qKlxuICAgICAqIEVuZGluZyBsb2NhdGlvbiBvZiB0aGUgcG9pbnRlci5cbiAgICAgKiBAdHlwZSB7Q29vcmRpbmF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLmVuZCA9IG9wdGlvbnMuZW5kO1xuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIGluIHBvc2l0aW9uIHNpbmNlIHRoZSBzdGFydCBvZiB0aGUgZHJhZy5cbiAgICAgKiBAdHlwZSB7Q29vcmRpbmF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLmRlbHRhID0gb3B0aW9ucy5kZWx0YTtcblxuICAgIC8qKlxuICAgICAqIFRpbWUgZWxhcHNlZCBmcm9tIG1vdXNlL3RvdWNoIGRvd24gdG8gbW91c2UvdG91Y2ggdXAuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmRlbHRhVGltZSA9IG9wdGlvbnMuZGVsdGFUaW1lO1xuXG4gICAgLyoqXG4gICAgICogVmVsb2NpdHkgb2YgdGhlIHdob2xlIGRyYWcuXG4gICAgICogQHR5cGUge0Nvb3JkaW5hdGV9XG4gICAgICovXG4gICAgdGhpcy52ZWxvY2l0eSA9IGdldFZlbG9jaXR5KHRoaXMuZGVsdGFUaW1lLCB0aGlzLmRlbHRhLngsIHRoaXMuZGVsdGEueSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmVsb2NpdHkgaW4gdGhlIGxhc3QgMTAwIG1pbGxpc2Vjb25kcy5cbiAgICAgKiBAdHlwZSB7Q29vcmRpbmF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLmN1cnJlbnRWZWxvY2l0eSA9IG9wdGlvbnMuY3VycmVudFZlbG9jaXR5O1xuXG4gICAgLyoqXG4gICAgICogRGlzdGFuY2UgZHJhZ2dlZC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZGlzdGFuY2UgPSBDb29yZGluYXRlLmRpc3RhbmNlKG9wdGlvbnMuc3RhcnQsIG9wdGlvbnMuZW5kKTtcblxuICAgIC8qKlxuICAgICAqIERpcmVjdGlvbiBvZiBkcmFnLlxuICAgICAqIEB0eXBlIHtEaXJlY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5kaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24ob3B0aW9ucy5zdGFydCwgb3B0aW9ucy5lbmQpO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgZHJhZyBkaXJlY3Rpb24gaXMgb24gdGhlIGF4aXMgb2YgdGhlIGRyYWdnYWJsZSBlbGVtZW50LlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaXNEaXJlY3Rpb25PbkF4aXMgPSBpc09uQXhpcyhvcHRpb25zLmF4aXMsIHRoaXMuZGlyZWN0aW9uKTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGRyYWdnYWJsZSBlbGVtZW50IG1vdmVkIGFsb25nIHRoZSBkcmFnZ2luZyBheGlzIGF0IGFsbC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmRpZE1vdmVPbkF4aXMgPSBkaWRNb3ZlT25BeGlzKG9wdGlvbnMuYXhpcywgdGhpcy5kaXJlY3Rpb24sIHRoaXMuZGVsdGEueCwgdGhpcy5kZWx0YS55KTtcblxuICAgIC8qKlxuICAgICAqIERpcmVjdGlvbiBvZiBkcmFnIHdoaWNoIGV4Y2x1ZGVzIGRpcmVjdGlvbnMgbm90IG9uIGl0cyBheGlzLlxuICAgICAqIEB0eXBlIHtEaXJlY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5heGlzRGlyZWN0aW9uID0gZ2V0QXhpc0RpcmVjdGlvbihvcHRpb25zLmF4aXMsIG9wdGlvbnMuc3RhcnQsIG9wdGlvbnMuZW5kKTtcblxuICAgIC8qKiBAdHlwZSB7e3BpeGVsOiBDb29yZGluYXRlLCBwZXJjZW50OiBDb29yZGluYXRlfX0gKi9cbiAgICB0aGlzLnBvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbjtcblxuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gV2hldGhlciBgcHJldmVudERlZmF1bHRgIGhhcyBiZWVuIGNhbGxlZC4gKi9cbiAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIFBvaW50ZXJFdmVudC5wcm90b3R5cGUucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICB9O1xuXG4gIHJldHVybiBQb2ludGVyRXZlbnQ7XG59KCk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBBbiBhYnN0cmFjdGlvbiBmb3IgcG9pbnRlciwgbW91c2UsIGFuZCB0b3VjaCBldmVudHMuXG4gKlxuICogQGF1dGhvciBHbGVuIENoZW5leSA8Z2xlbkBvZG9wb2QuY29tPlxuICovXG5cbnZhciBQb2ludGVyID0gZnVuY3Rpb24gKF9UaW55RW1pdHRlcikge1xuICBpbmhlcml0cyhQb2ludGVyLCBfVGlueUVtaXR0ZXIpO1xuXG4gIC8qKlxuICAgKiBBbiBhYnN0cmFjdGlvbiBsYXllciBmb3IgYWRkaW5nIHBvaW50ZXIgZXZlbnRzIGFuZCBjYWxjdWxhdGluZyBkcmFnIHZhbHVlcy5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHdhdGNoLlxuICAgKiBAcGFyYW0ge1BvaW50ZXJPcHRpb25zfSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0LlxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IFRocm93cyB3aGVuIHRoZSBlbGVtZW50IHBhcmFtZXRlciBpc24ndCBhbiBlbGVtZW50LlxuICAgKi9cbiAgZnVuY3Rpb24gUG9pbnRlcihlbGVtZW50KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFBvaW50ZXIpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVGlueUVtaXR0ZXIuY2FsbCh0aGlzKSk7XG5cbiAgICBpZiAoIWVsZW1lbnQgfHwgZWxlbWVudC5ub2RlVHlwZSAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT2RvUG9pbnRlciByZXF1aXJlcyBhbiBlbGVtZW50LicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtQb2ludGVyT3B0aW9uc31cbiAgICAgKi9cbiAgICBfdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgUG9pbnRlci5EZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZHJhZ2dhYmxlIGVsZW1lbnQuXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBTdGFydGluZyBsb2NhdGlvbiBvZiB0aGUgZHJhZy5cbiAgICAgKiBAdHlwZSB7Q29vcmRpbmF0ZX1cbiAgICAgKi9cbiAgICBfdGhpcy5wYWdlU3RhcnQgPSBuZXcgQ29vcmRpbmF0ZSgpO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBwb3NpdGlvbiBvZiBtb3VzZSBvciB0b3VjaCByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQuXG4gICAgICogQHR5cGUge0Nvb3JkaW5hdGV9XG4gICAgICovXG4gICAgX3RoaXMucGFnZSA9IG5ldyBDb29yZGluYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHBvc2l0aW9uIG9mIGRyYWcgcmVsYXRpdmUgdG8gdGFyZ2V0J3MgcGFyZW50LlxuICAgICAqIEB0eXBlIHtDb29yZGluYXRlfVxuICAgICAqL1xuICAgIF90aGlzLmRlbHRhID0gbmV3IENvb3JkaW5hdGUoKTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gdHJhY2sgdGhlIGN1cnJlbnQgdmVsb2NpdHkuIEl0IGlzIHVwZGF0ZWQgd2hlbiB0aGUgdmVsb2NpdHkgaXMuXG4gICAgICogQHR5cGUge0Nvb3JkaW5hdGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdGhpcy5fbGFzdFBvc2l0aW9uID0gbmV3IENvb3JkaW5hdGUoKTtcblxuICAgIC8qKlxuICAgICAqIEZyaWN0aW9uIHRvIGFwcGx5IHRvIGRyYWdnaW5nLiBBIHZhbHVlIG9mIHplcm8gd291bGQgcmVzdWx0IGluIG5vIGRyYWdnaW5nLFxuICAgICAqIDAuNSB3b3VsZCByZXN1bHQgaW4gdGhlIGRyYWdnYWJsZSBlbGVtZW50IG1vdmluZyBoYWxmIGFzIGZhciBhcyB0aGUgdXNlclxuICAgICAqIGRyYWdnZWQsIGFuZCAxIGlzIGEgMToxIHJhdGlvIHdpdGggdXNlciBtb3ZlbWVudC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIF90aGlzLl9mcmljdGlvbiA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBGbGFnIGluZGljYXRpbmcgZHJhZ2dpbmcgaGFzIGhhcHBlbmVkLiBJdCBpcyBzZXQgb24gZHJhZ21vdmUgYW5kIHJlc2V0XG4gICAgICogYWZ0ZXIgdGhlIGRyYWdnYWJsZWVuZCBldmVudCBoYXMgYmVlbiBkaXNwYXRjaGVkLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIF90aGlzLmhhc0RyYWdnZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIHVzZXIgaXMgbG9ja2VkIGluIHBsYWNlIHdpdGhpbiB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQuIFRoaXNcbiAgICAgKiBpcyBzZXQgdG8gdHJ1ZSB3aGVuIGBwcmV2ZW50RGVmYXVsdGAgaXMgY2FsbGVkIG9uIHRoZSBtb3ZlIGV2ZW50LlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RoaXMuX2lzTG9ja2VkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGRyYWdnaW5nIGlzIGVuYWJsZWQgaW50ZXJuYWxseS4gSWYgdGhlIHVzZXIgYXR0ZW1wdHMgdG8gc2Nyb2xsXG4gICAgICogaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiBvZiB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQsIHRoaXMgaXMgc2V0IHRvIHRydWVcbiAgICAgKiBhbmQgbm8gbW9yZSBkcmFnIG1vdmUgZXZlbnRzIGFyZSBjb3VudGVkIHVudGlsIHRoZSB1c2VyIHJlbGVhc2VzIGFuZFxuICAgICAqIHN0YXJ0cyBkcmFnZ2luZyBhZ2Fpbi5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF90aGlzLl9pc0RlYWN0aXZhdGVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGRyYWdnaW5nIGlzIGN1cnJlbnRseSBlbmFibGVkLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RoaXMuX2VuYWJsZWQgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogSWQgZnJvbSBzZXRJbnRlcnZhbCB0byB1cGRhdGUgdGhlIHZlbG9jaXR5LlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdGhpcy5fdmVsb2NpdHlUcmFja2VySWQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGltZSBpbiBtaWxsaXNlY29uZHMgd2hlbiB0aGUgZHJhZyBzdGFydGVkLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgX3RoaXMuc3RhcnRUaW1lID0gMDtcblxuICAgIC8qKlxuICAgICAqIExlbmd0aCBvZiB0aGUgZHJhZyBpbiBtaWxsaXNlY29uZHMuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBfdGhpcy5kZWx0YVRpbWUgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBrZWVwIHRyYWNrIG9mIHRoZSBjdXJyZW50IHZlbG9jaXR5LCBpdCdzIHVwZGF0ZWQgd2l0aCBldmVyeSB2ZWxvY2l0eSB1cGRhdGUuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF90aGlzLl9sYXN0VGltZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCB2ZWxvY2l0eSBvZiB0aGUgZHJhZy5cbiAgICAgKiBAdHlwZSB7Q29vcmRpbmF0ZX1cbiAgICAgKi9cbiAgICBfdGhpcy52ZWxvY2l0eSA9IG5ldyBDb29yZGluYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSB2ZWxvY2l0eSBoYXMgYmVlbiB0cmFja2VkIGF0IGxlYXN0IG9uY2UgZHVyaW5nIHRoZSBkcmFnLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIF90aGlzLl9oYXNUcmFja2VkVmVsb2NpdHkgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBlbGVtZW50IHRvIHdoaWNoIHRoZSBtb3ZlIGFuZCB1cCBldmVudHMgd2lsbCBiZSBib3VuZCB0by4gSWYgYSBwb2ludGVyXG4gICAgICogaXMgYmVpbmcgdXNlZCBpbnNpZGUgYSBtb2RhbCB3aGljaCBzdG9wcyBldmVudHMgZnJvbSBidWJibGluZyB0byB0aGUgYm9keSxcbiAgICAgKiB0aGlzIHByb3BlcnR5IHNob3VsZCBiZSBjaGFuZ2VkIHRvIGFuIGVsZW1lbnQgd2hpY2ggKndpbGwqIHJlY2VpdmUgdGhlIGV2ZW50cy5cbiAgICAgKiBAdHlwZSB7RG9jdW1lbnR8RWxlbWVudH1cbiAgICAgKi9cbiAgICBfdGhpcy5kcmFnRXZlbnRUYXJnZXQgPSBkb2N1bWVudDtcblxuICAgIHZhciB0b3VjaEFjdGlvbiA9IFBvaW50ZXIuVG91Y2hBY3Rpb25TdXBwb3J0W190aGlzLm9wdGlvbnMuYXhpc107XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBgdG91Y2gtYWN0aW9uYCBwcm9wZXJ0eSBhc3NvY2lhdGVkIHdpdGhcbiAgICAgKiB0aGUgYXhpcy5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBfdGhpcy5faXNUb3VjaEFjdGlvblN1cHBvcnRlZCA9ICEhdG91Y2hBY3Rpb247XG5cbiAgICAvLyBJZiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgdG91Y2ggYWN0aW9uIHByb3BlcnR5LCBhZGQgaXQuXG4gICAgaWYgKF90aGlzLm9wdGlvbnMucHJldmVudEV2ZW50RGVmYXVsdCAmJiBfdGhpcy5faXNUb3VjaEFjdGlvblN1cHBvcnRlZCkge1xuICAgICAgX3RoaXMuZWxlbWVudC5zdHlsZVt0b3VjaEFjdGlvbl0gPSBQb2ludGVyLlRvdWNoQWN0aW9uW190aGlzLm9wdGlvbnMuYXhpc107XG4gICAgfSBlbHNlIGlmIChfdGhpcy5vcHRpb25zLnByZXZlbnRFdmVudERlZmF1bHQgJiYgT2RvRGV2aWNlLkhBU19UT1VDSF9FVkVOVFMpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGV2ZW50cy5UT1VDSE1PVkUsIG5vb3ApO1xuICAgIH1cblxuICAgIF90aGlzLmxpc3RlbigpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIFBvaW50ZXIucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbigpIHtcbiAgICB0aGlzLl9vblN0YXJ0ID0gdGhpcy5faGFuZGxlRHJhZ1N0YXJ0LmJpbmQodGhpcyk7XG5cbiAgICBpZiAoT2RvRGV2aWNlLkhBU19QT0lOVEVSX0VWRU5UUykge1xuICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRzLlBPSU5URVJET1dOLCB0aGlzLl9vblN0YXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRzLk1PVVNFRE9XTiwgdGhpcy5fb25TdGFydCk7XG5cbiAgICAgIGlmIChPZG9EZXZpY2UuSEFTX1RPVUNIX0VWRU5UUykge1xuICAgICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudHMuVE9VQ0hTVEFSVCwgdGhpcy5fb25TdGFydCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUHJldmVudCBpbWFnZXMsIGxpbmtzLCBldGMgZnJvbSBiZWluZyBkcmFnZ2VkIGFyb3VuZC5cbiAgICAvLyBodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9kbmQvYmFzaWNzL1xuICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50cy5EUkFHU1RBUlQsIFBvaW50ZXIuX3ByZXZlbnREZWZhdWx0KTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHdoZXRoZXIgZHJhZ2dlciBpcyBlbmFibGVkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIGRyYWdnZXIgaXMgZW5hYmxlZC5cbiAgICovXG5cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgZHJhZ2dhYmxlIGF4aXMgaXMgdGhlIHggZGlyZWN0aW9uLlxuICAgKi9cbiAgUG9pbnRlci5wcm90b3R5cGUuaXNYQXhpcyA9IGZ1bmN0aW9uIGlzWEF4aXMoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5heGlzID09PSBQb2ludGVyLkF4aXMuWDtcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgZHJhZ2dhYmxlIGF4aXMgaXMgdGhlIHkgZGlyZWN0aW9uLlxuICAgKi9cblxuXG4gIFBvaW50ZXIucHJvdG90eXBlLmlzWUF4aXMgPSBmdW5jdGlvbiBpc1lBeGlzKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYXhpcyA9PT0gUG9pbnRlci5BeGlzLlk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGRyYWdnYWJsZSBheGlzIGlzIGZvciBib3RoIGF4aXMuXG4gICAqL1xuXG5cbiAgUG9pbnRlci5wcm90b3R5cGUuaXNCb3RoQXhpcyA9IGZ1bmN0aW9uIGlzQm90aEF4aXMoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5heGlzID09PSBQb2ludGVyLkF4aXMuQk9USDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmUgdGhlIGZyaWN0aW9uIHZhbHVlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIEFwcGx5IGEgZnJpY3Rpb24gdmFsdWUgdG8gYSBjb29yZGluYXRlLCByZWR1Y2luZyBpdHMgdmFsdWUuXG4gICAqIFRoaXMgbW9kaWZpZXMgdGhlIGNvb3JkaW5hdGUgZ2l2ZW4gdG8gaXQuXG4gICAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBUaGUgY29vcmRpbmF0ZSB0byBzY2FsZS5cbiAgICogQHJldHVybiB7Q29vcmRpbmF0ZX0gUG9zaXRpb24gbXVsdGlwbGllZCBieSBmcmljdGlvbi5cbiAgICovXG4gIFBvaW50ZXIucHJvdG90eXBlLmFwcGx5RnJpY3Rpb24gPSBmdW5jdGlvbiBhcHBseUZyaWN0aW9uKGNvb3JkaW5hdGUpIHtcbiAgICByZXR1cm4gY29vcmRpbmF0ZS5zY2FsZSh0aGlzLmZyaWN0aW9uKTtcbiAgfTtcblxuICAvKipcbiAgICogSWYgZHJhZ2dhYmxlIGlzIGVuYWJsZWQgYW5kIGl0J3MgYSBsZWZ0IGNsaWNrIHdpdGggdGhlIG1vdXNlLFxuICAgKiBkcmFnZ2luZyBjYW4gc3RhcnQuXG4gICAqIEBwYXJhbSB7VG91Y2hFdmVudHxNb3VzZUV2ZW50fFBvaW50ZXJFdmVudH0gZXZ0IEV2ZW50IG9iamVjdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQb2ludGVyLnByb3RvdHlwZS5fY2FuU3RhcnREcmFnID0gZnVuY3Rpb24gX2NhblN0YXJ0RHJhZyhldnQpIHtcbiAgICByZXR1cm4gdGhpcy5pc0VuYWJsZWQgJiYgKFBvaW50ZXIuaXNUb3VjaEV2ZW50KGV2dCkgfHwgZXZ0LmJ1dHRvbiA9PT0gMCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgZHJhZyBtb3ZlIHNob3VsZCBoYXBwZW4gb3IgZXhpdCBlYXJseS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQb2ludGVyLnByb3RvdHlwZS5fY2FuQ29udGludWVEcmFnID0gZnVuY3Rpb24gX2NhbkNvbnRpbnVlRHJhZygpIHtcbiAgICByZXR1cm4gdGhpcy5pc0VuYWJsZWQgJiYgIXRoaXMuX2lzRGVhY3RpdmF0ZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIERyYWcgc3RhcnQgaGFuZGxlci5cbiAgICogQHBhcmFtIHtUb3VjaEV2ZW50fE1vdXNlRXZlbnR8UG9pbnRlckV2ZW50fSBldnQgVGhlIGRyYWcgZXZlbnQgb2JqZWN0LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBvaW50ZXIucHJvdG90eXBlLl9oYW5kbGVEcmFnU3RhcnQgPSBmdW5jdGlvbiBfaGFuZGxlRHJhZ1N0YXJ0KGV2dCkge1xuICAgIC8vIENsZWFyIGFueSBhY3RpdmUgdHJhY2tpbmcgaW50ZXJ2YWwuXG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLl92ZWxvY2l0eVRyYWNrZXJJZCk7XG5cbiAgICAvLyBNdXN0IGJlIGxlZnQgY2xpY2sgdG8gZHJhZy5cbiAgICBpZiAoIXRoaXMuX2NhblN0YXJ0RHJhZyhldnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fc2V0RHJhZ1N0YXJ0VmFsdWVzKFBvaW50ZXIuX2dldFBhZ2VDb29yZGluYXRlKGV2dCkpO1xuXG4gICAgLy8gR2l2ZSBhIGhvb2sgdG8gb3RoZXJzXG4gICAgdmFyIGlzUHJldmVudGVkID0gdGhpcy5fZW1pdEV2ZW50KHRoaXMuX2NyZWF0ZUV2ZW50KFBvaW50ZXIuRXZlbnRUeXBlLlNUQVJULCBldnQpKTtcblxuICAgIGlmICghaXNQcmV2ZW50ZWQpIHtcbiAgICAgIHRoaXMuX2FkZERyYWdIYW5kbGVycyhldnQudHlwZSk7XG5cbiAgICAgIC8vIEV2ZXJ5IGludGVydmFsLCBjYWxjdWxhdGUgdGhlIGN1cnJlbnQgdmVsb2NpdHkgb2YgdGhlIGRyYWcuXG4gICAgICB0aGlzLl92ZWxvY2l0eVRyYWNrZXJJZCA9IHNldEludGVydmFsKHRoaXMuX3RyYWNrVmVsb2NpdHkuYmluZCh0aGlzKSwgUG9pbnRlci5WRUxPQ0lUWV9JTlRFUlZBTCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBEcmFnIG1vdmUsIGFmdGVyIGFwcGx5RHJhZ2dhYmxlRWxlbWVudFBvc2l0aW9uIGhhcyBoYXBwZW5lZFxuICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR8TW91c2VFdmVudHxQb2ludGVyRXZlbnR9IGV2dCBUaGUgZHJhZ2dlciBldmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQb2ludGVyLnByb3RvdHlwZS5faGFuZGxlRHJhZ01vdmUgPSBmdW5jdGlvbiBfaGFuZGxlRHJhZ01vdmUoZXZ0KSB7XG4gICAgaWYgKCF0aGlzLl9jYW5Db250aW51ZURyYWcoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3NldERyYWdNb3ZlVmFsdWVzKFBvaW50ZXIuX2dldFBhZ2VDb29yZGluYXRlKGV2dCkpO1xuXG4gICAgdmFyIGlzUHJldmVudGVkID0gdGhpcy5fZW1pdEV2ZW50KHRoaXMuX2NyZWF0ZUV2ZW50KFBvaW50ZXIuRXZlbnRUeXBlLk1PVkUsIGV2dCkpO1xuXG4gICAgLy8gQWJvcnQgaWYgdGhlIGRldmVsb3BlciBwcmV2ZW50ZWQgZGVmYXVsdCBvbiB0aGUgY3VzdG9tIGV2ZW50IG9yIGlmIHRoZVxuICAgIC8vIGJyb3dzZXIgc3VwcG9ydHMgdG91Y2gtYWN0aW9uICh3aGljaCB3aWxsIGRvIHRoZSBcImxvY2tpbmdcIiBmb3IgdXMpLlxuICAgIGlmICghaXNQcmV2ZW50ZWQgJiYgdGhpcy5vcHRpb25zLnByZXZlbnRFdmVudERlZmF1bHQgJiYgIXRoaXMuX2lzVG91Y2hBY3Rpb25TdXBwb3J0ZWQpIHtcbiAgICAgIHRoaXMuX2ZpbmlzaERyYWdNb3ZlKGV2dCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBGaW5pc2ggdGhlIGRyYWcgbW92ZSBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtUb3VjaEV2ZW50fE1vdXNlRXZlbnR8UG9pbnRlckV2ZW50fSBldnQgRXZlbnQgb2JqZWN0LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBvaW50ZXIucHJvdG90eXBlLl9maW5pc2hEcmFnTW92ZSA9IGZ1bmN0aW9uIF9maW5pc2hEcmFnTW92ZShldnQpIHtcbiAgICAvLyBQb3NzaWJseSBsb2NrIHRoZSB1c2VyIHRvIG9ubHkgZHJhZ2dpbmcuXG4gICAgdGhpcy5fbWF5YmVMb2NrKCk7XG5cbiAgICAvLyBQb3NzaWJseSBzdG9wIGRyYWdnYWJsZSBmcm9tIGFmZmVjdGluZyB0aGUgZWxlbWVudC5cbiAgICB0aGlzLl9tYXliZURlYWN0aXZhdGUoKTtcblxuICAgIC8vIExvY2tlZCBpbnRvIGRyYWdnaW5nLlxuICAgIGlmICh0aGlzLl9pc0xvY2tlZCkge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgLy8gRGlzcmVnYXJkIGRyYWdzIGFuZCB2ZWxvY2l0eS5cbiAgICBpZiAodGhpcy5faXNEZWFjdGl2YXRlZCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl92ZWxvY2l0eVRyYWNrZXJJZCk7XG4gICAgICB0aGlzLnZlbG9jaXR5LnggPSAwO1xuICAgICAgdGhpcy52ZWxvY2l0eS55ID0gMDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIERyYWdnaW5nIGVuZGVkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBvaW50ZXIucHJvdG90eXBlLl9oYW5kbGVEcmFnRW5kID0gZnVuY3Rpb24gX2hhbmRsZURyYWdFbmQoZXZ0KSB7XG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLl92ZWxvY2l0eVRyYWNrZXJJZCk7XG4gICAgdGhpcy5kZWx0YVRpbWUgPSBEYXRlLm5vdygpIC0gdGhpcy5zdGFydFRpbWU7XG5cbiAgICAvLyBJZiB0aGlzIHdhcyBhIHF1aWNrIGRyYWcsIHRoZSB2ZWxvY2l0eSBtaWdodCBub3QgaGF2ZSBiZWVuIHRyYWNrZWQgb25jZS5cbiAgICBpZiAoIXRoaXMuX2hhc1RyYWNrZWRWZWxvY2l0eSkge1xuICAgICAgdGhpcy5fdHJhY2tWZWxvY2l0eSgpO1xuICAgIH1cblxuICAgIC8vIFByZXZlbnQgbW91c2UgZXZlbnRzIGZyb20gb2NjdXJyaW5nIGFmdGVyIHRvdWNoZW5kLlxuICAgIHRoaXMuX3JlbW92ZURyYWdIYW5kbGVycygpO1xuXG4gICAgdmFyIGVuZEV2ZW50ID0gdGhpcy5fY3JlYXRlRXZlbnQoUG9pbnRlci5FdmVudFR5cGUuRU5ELCBldnQpO1xuICAgIGVuZEV2ZW50LmlzQ2FuY2VsRXZlbnQgPSBQb2ludGVyLl9pc0NhbmNlbEV2ZW50KGV2dCk7XG5cbiAgICAvLyBFbWl0IGFuIGV2ZW50LlxuICAgIHZhciBpc1ByZXZlbnRlZCA9IHRoaXMuX2VtaXRFdmVudChlbmRFdmVudCk7XG5cbiAgICBpZiAoaXNQcmV2ZW50ZWQpIHtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIHRoaXMuaGFzRHJhZ2dlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2lzRGVhY3RpdmF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9pc0xvY2tlZCA9IGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHN0YXJ0aW5nIHZhbHVlcyBmb3IgZHJhZ2dpbmcuXG4gICAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gcGFnZVBvc2l0aW9uIFRoZSBwYWdlIHBvc2l0aW9uIGNvb3JkaW5hdGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUG9pbnRlci5wcm90b3R5cGUuX3NldERyYWdTdGFydFZhbHVlcyA9IGZ1bmN0aW9uIF9zZXREcmFnU3RhcnRWYWx1ZXMocGFnZVBvc2l0aW9uKSB7XG4gICAgdGhpcy5wYWdlU3RhcnQgPSBwYWdlUG9zaXRpb247XG4gICAgdGhpcy5wYWdlID0gcGFnZVBvc2l0aW9uO1xuICAgIHRoaXMuX2xhc3RQb3NpdGlvbiA9IHBhZ2VQb3NpdGlvbjtcbiAgICB0aGlzLmRlbHRhID0gbmV3IENvb3JkaW5hdGUoKTtcbiAgICB0aGlzLnZlbG9jaXR5ID0gbmV3IENvb3JkaW5hdGUoKTtcbiAgICB0aGlzLl9oYXNUcmFja2VkVmVsb2NpdHkgPSBmYWxzZTtcblxuICAgIHRoaXMuc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLl9sYXN0VGltZSA9IERhdGUubm93KCk7XG4gICAgdGhpcy5kZWx0YVRpbWUgPSAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHZhbHVlcyBmb3IgZHJhZ2dpbmcgZHVyaW5nIGEgZHJhZyBtb3ZlLlxuICAgKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IHBhZ2VQb3NpdGlvbiBUaGUgcGFnZSBwb3NpdGlvbiBjb29yZGluYXRlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBvaW50ZXIucHJvdG90eXBlLl9zZXREcmFnTW92ZVZhbHVlcyA9IGZ1bmN0aW9uIF9zZXREcmFnTW92ZVZhbHVlcyhwYWdlUG9zaXRpb24pIHtcbiAgICAvLyBHZXQgdGhlIGRpc3RhbmNlIHNpbmNlIHRoZSBsYXN0IG1vdmUuXG4gICAgdmFyIGxhc3REZWx0YSA9IENvb3JkaW5hdGUuZGlmZmVyZW5jZShwYWdlUG9zaXRpb24sIHRoaXMucGFnZSk7XG5cbiAgICAvLyBBcHBseSBmcmljdGlvbiB0byB0aGUgZGlzdGFuY2Ugc2luY2UgbGFzdCBtb3ZlLlxuICAgIHRoaXMuYXBwbHlGcmljdGlvbihsYXN0RGVsdGEpO1xuXG4gICAgLy8gVXBkYXRlIHRoZSB0b3RhbCBkZWx0YSB2YWx1ZS5cbiAgICB0aGlzLmRlbHRhLnRyYW5zbGF0ZShsYXN0RGVsdGEpO1xuXG4gICAgdGhpcy5wYWdlID0gcGFnZVBvc2l0aW9uO1xuICAgIHRoaXMuZGVsdGFUaW1lID0gRGF0ZS5ub3coKSAtIHRoaXMuc3RhcnRUaW1lO1xuICAgIHRoaXMuaGFzRHJhZ2dlZCA9IHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIE9uY2UgdGhlIHVzZXIgaGFzIG1vdmVkIHBhc3QgdGhlIGxvY2sgdGhyZXNob2xkLCBrZWVwIGl0IGxvY2tlZC5cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQb2ludGVyLnByb3RvdHlwZS5fbWF5YmVMb2NrID0gZnVuY3Rpb24gX21heWJlTG9jaygpIHtcbiAgICBpZiAoIXRoaXMuX2lzTG9ja2VkKSB7XG4gICAgICAvLyBQcmV2ZW50IHNjcm9sbGluZyBpZiB0aGUgdXNlciBoYXMgbW92ZWQgcGFzdCB0aGUgbG9ja2luZyB0aHJlc2hvbGQuXG4gICAgICB0aGlzLl9pc0xvY2tlZCA9IHRoaXMuX3Nob3VsZExvY2sodGhpcy5kZWx0YSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBPbmNlIHRoZSB1c2VyIGhhcyBtb3ZlZCBwYXN0IHRoZSBkcmFnIHRocmVzaG9sZCwga2VlcCBpdCBkZWFjdGl2YXRlZC5cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQb2ludGVyLnByb3RvdHlwZS5fbWF5YmVEZWFjdGl2YXRlID0gZnVuY3Rpb24gX21heWJlRGVhY3RpdmF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuX2lzRGVhY3RpdmF0ZWQpIHtcbiAgICAgIC8vIERpc2FibGUgZHJhZ2dpbmcgaWYgdGhlIHVzZXIgaXMgYXR0ZW1wdGluZyB0byBnbyB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uXG4gICAgICAvLyBvZiB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQuXG4gICAgICB0aGlzLl9pc0RlYWN0aXZhdGVkID0gdGhpcy5fc2hvdWxkRGVhY3RpdmF0ZSh0aGlzLmRlbHRhKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gZGVsdGEgQW1vdW50IHRoZSBwb2ludGVyIGhhcyBtb3ZlZCBzaW5jZSBpdCBzdGFydGVkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIERyYWdnYWJsZSBzaG91bGQgbG9jayB0aGUgdXNlciBpbnRvIGRyYWdnYWJsZSBvbmx5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBvaW50ZXIucHJvdG90eXBlLl9zaG91bGRMb2NrID0gZnVuY3Rpb24gX3Nob3VsZExvY2soZGVsdGEpIHtcbiAgICB2YXIgcGFzdFggPSB0aGlzLmlzWEF4aXMoKSAmJiBNYXRoLmFicyhkZWx0YS54KSA+IFBvaW50ZXIuTE9DS19USFJFU0hPTEQ7XG4gICAgdmFyIHBhc3RZID0gdGhpcy5pc1lBeGlzKCkgJiYgTWF0aC5hYnMoZGVsdGEueSkgPiBQb2ludGVyLkxPQ0tfVEhSRVNIT0xEO1xuICAgIHJldHVybiB0aGlzLmlzQm90aEF4aXMoKSB8fCBwYXN0WCB8fCBwYXN0WTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtDb29yZGluYXRlfSBkZWx0YSBBbW91bnQgdGhlIHBvaW50ZXIgaGFzIG1vdmVkIHNpbmNlIGl0IHN0YXJ0ZWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgRHJhZ2dhYmxlIHNob3VsZCBzdG9wIGFmZmVjdGluZyB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUG9pbnRlci5wcm90b3R5cGUuX3Nob3VsZERlYWN0aXZhdGUgPSBmdW5jdGlvbiBfc2hvdWxkRGVhY3RpdmF0ZShkZWx0YSkge1xuICAgIHZhciBwYXN0WCA9IHRoaXMuaXNYQXhpcygpICYmIE1hdGguYWJzKGRlbHRhLnkpID4gUG9pbnRlci5EUkFHX1RIUkVTSE9MRDtcbiAgICB2YXIgcGFzdFkgPSB0aGlzLmlzWUF4aXMoKSAmJiBNYXRoLmFicyhkZWx0YS54KSA+IFBvaW50ZXIuRFJBR19USFJFU0hPTEQ7XG4gICAgcmV0dXJuICF0aGlzLl9pc0xvY2tlZCAmJiAodGhpcy5pc0JvdGhBeGlzKCkgfHwgcGFzdFggfHwgcGFzdFkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNYWtlIGEgbmV3IGV2ZW50IHdpdGggZGF0YS5cbiAgICogQHBhcmFtIHtQb2ludGVyLkV2ZW50VHlwZX0gdHlwZSBFdmVudCB0eXBlLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldnQgTmF0aXZlIGV2ZW50IG9iamVjdC5cbiAgICogQHJldHVybiB7IVBvaW50ZXIuRXZlbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUG9pbnRlci5wcm90b3R5cGUuX2NyZWF0ZUV2ZW50ID0gZnVuY3Rpb24gX2NyZWF0ZUV2ZW50KHR5cGUsIGV2dCkge1xuICAgIHJldHVybiBuZXcgUG9pbnRlci5FdmVudCh7XG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgcG9pbnRlcklkOiB0aGlzLmlkLFxuICAgICAgY3VycmVudFRhcmdldDogdGhpcy5lbGVtZW50LFxuICAgICAgdGFyZ2V0OiBldnQudGFyZ2V0LFxuICAgICAgYXhpczogdGhpcy5vcHRpb25zLmF4aXMsXG4gICAgICBkZWx0YVRpbWU6IHRoaXMuZGVsdGFUaW1lLFxuICAgICAgZGVsdGE6IHRoaXMuZGVsdGEsXG4gICAgICBzdGFydDogdGhpcy5wYWdlU3RhcnQsXG4gICAgICBlbmQ6IHRoaXMucGFnZSxcbiAgICAgIGN1cnJlbnRWZWxvY2l0eTogdGhpcy52ZWxvY2l0eVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBCaW5kcyBldmVudHMgdG8gdGhlIGRvY3VtZW50IGZvciBtb3ZlLCBlbmQsIGFuZCBjYW5jZWwgKGlmIGNhbmNlbCBldmVudHNcbiAgICogZXhpc3QgZm9yIHRoZSBkZXZpY2UpLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RhcnRUeXBlIFRoZSB0eXBlIG9mIGV2ZW50IHdoaWNoIHN0YXJ0ZWQgdGhlIGRyYWcuIEl0XG4gICAqICAgICBpcyBpbXBvcnRhbnQgdGhhdCB0aGUgbW91c2UgZXZlbnRzIGFyZSBub3QgYm91bmQgd2hlbiBhIHRvdWNoIGV2ZW50XG4gICAqICAgICBpcyB0cmlnZ2VyZWQgb3RoZXJ3aXNlIHRoZSBldmVudHMgY291bGQgYmUgZG91YmxlZC5cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQb2ludGVyLnByb3RvdHlwZS5fYWRkRHJhZ0hhbmRsZXJzID0gZnVuY3Rpb24gX2FkZERyYWdIYW5kbGVycyhzdGFydFR5cGUpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy5kcmFnRXZlbnRUYXJnZXQ7XG4gICAgdGhpcy5fb25Nb3ZlID0gdGhpcy5faGFuZGxlRHJhZ01vdmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkVuZCA9IHRoaXMuX2hhbmRsZURyYWdFbmQuYmluZCh0aGlzKTtcblxuICAgIHN3aXRjaCAoc3RhcnRUeXBlKSB7XG4gICAgICBjYXNlIGV2ZW50cy5QT0lOVEVSRE9XTjpcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRzLlBPSU5URVJNT1ZFLCB0aGlzLl9vbk1vdmUpO1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudHMuUE9JTlRFUlVQLCB0aGlzLl9vbkVuZCk7XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50cy5QT0lOVEVSQ0FOQ0VMLCB0aGlzLl9vbkVuZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBldmVudHMuTU9VU0VET1dOOlxuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudHMuTU9VU0VNT1ZFLCB0aGlzLl9vbk1vdmUpO1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudHMuTU9VU0VVUCwgdGhpcy5fb25FbmQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgZXZlbnRzLlRPVUNIU1RBUlQ6XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50cy5UT1VDSE1PVkUsIHRoaXMuX29uTW92ZSk7XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50cy5UT1VDSEVORCwgdGhpcy5fb25FbmQpO1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudHMuVE9VQ0hDQU5DRUwsIHRoaXMuX29uRW5kKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBubyBkZWZhdWx0XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBldmVudHMgYm91bmQgZHVyaW5nIGRyYWcgc3RhcnQuIFRoZSBkcmFnZ2FibGUgbmFtZXNwYWNlIGNhbiBiZVxuICAgKiB1c2VkIHRvIHJlbW92ZSBhbGwgb2YgdGhlbSBiZWNhdXNlIHRoZSBkcmFnIHN0YXJ0IGV2ZW50IGlzIHN0aWxsIGJvdW5kXG4gICAqIHRvIHRoZSBhY3R1YWwgZWxlbWVudC5cbiAgICovXG5cblxuICBQb2ludGVyLnByb3RvdHlwZS5fcmVtb3ZlRHJhZ0hhbmRsZXJzID0gZnVuY3Rpb24gX3JlbW92ZURyYWdIYW5kbGVycygpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy5kcmFnRXZlbnRUYXJnZXQ7XG4gICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRzLlBPSU5URVJNT1ZFLCB0aGlzLl9vbk1vdmUpO1xuICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50cy5QT0lOVEVSVVAsIHRoaXMuX29uRW5kKTtcbiAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudHMuUE9JTlRFUkNBTkNFTCwgdGhpcy5fb25FbmQpO1xuICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50cy5NT1VTRU1PVkUsIHRoaXMuX29uTW92ZSk7XG4gICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRzLk1PVVNFVVAsIHRoaXMuX29uRW5kKTtcbiAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudHMuVE9VQ0hNT1ZFLCB0aGlzLl9vbk1vdmUpO1xuICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50cy5UT1VDSEVORCwgdGhpcy5fb25FbmQpO1xuICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50cy5UT1VDSENBTkNFTCwgdGhpcy5fb25FbmQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFdmVyeSAxMDAgbWlsbGlzZWNvbmRzLCBjYWxjdWxhdGUgdGhlIGN1cnJlbnQgdmVsb2NpdHkgd2l0aCBhIG1vdmluZyBhdmVyYWdlLlxuICAgKiBodHRwOi8vYXJpeWEub2ZpbGFicy5jb20vMjAxMy8xMS9qYXZhc2NyaXB0LWtpbmV0aWMtc2Nyb2xsaW5nLXBhcnQtMi5odG1sXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgUG9pbnRlci5wcm90b3R5cGUuX3RyYWNrVmVsb2NpdHkgPSBmdW5jdGlvbiBfdHJhY2tWZWxvY2l0eSgpIHtcbiAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICB2YXIgZWxhcHNlZCA9IG5vdyAtIHRoaXMuX2xhc3RUaW1lO1xuICAgIHZhciBkZWx0YSA9IENvb3JkaW5hdGUuZGlmZmVyZW5jZSh0aGlzLnBhZ2UsIHRoaXMuX2xhc3RQb3NpdGlvbik7XG4gICAgdGhpcy5hcHBseUZyaWN0aW9uKGRlbHRhKTtcbiAgICB0aGlzLl9sYXN0VGltZSA9IG5vdztcbiAgICB0aGlzLl9sYXN0UG9zaXRpb24gPSB0aGlzLnBhZ2U7XG5cbiAgICAvLyB2ZWxvY2l0eSA9IGRlbHRhIC8gdGltZS5cbiAgICAvLyBDbGFtcCB0aGUgdmVsb2NpdHkgdG8gYXZvaWQgb3V0bGllcnMuXG4gICAgdmFyIG1heFZlbG9jaXR5ID0gUG9pbnRlci5NQVhfVkVMT0NJVFk7XG4gICAgdGhpcy52ZWxvY2l0eS54ID0gY2xhbXAoZGVsdGEueCAvIGVsYXBzZWQsIC1tYXhWZWxvY2l0eSwgbWF4VmVsb2NpdHkpO1xuICAgIHRoaXMudmVsb2NpdHkueSA9IGNsYW1wKGRlbHRhLnkgLyBlbGFwc2VkLCAtbWF4VmVsb2NpdHksIG1heFZlbG9jaXR5KTtcblxuICAgIHRoaXMuX2hhc1RyYWNrZWRWZWxvY2l0eSA9IHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB3aGV0aGVyIHRoZSBkcmFnZ2FibGUgZXZlbnQgaGFzIGVub3VnaCB2ZWxvY2l0eSB0byBiZVxuICAgKiBjb25zaWRlcmVkIGEgc3dpcGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2ZWxvY2l0eSBPYmplY3Qgd2l0aCB4IGFuZCB5IHByb3BlcnRpZXMgZm9yIHZlbG9jaXR5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3RocmVzaG9sZF0gVGhyZXNob2xkIHRvIGNoZWNrIGFnYWluc3QuIERlZmF1bHRzIHRvIHRoZSBzd2lwZVxuICAgKiAgICAgdmVsb2NpdHkgY29uc3RhbnQuIE11c3QgYmUgemVybyBvciBhIHBvc2l0aXZlIG51bWJlci5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG5cblxuICBQb2ludGVyLnByb3RvdHlwZS5oYXNWZWxvY2l0eSA9IGZ1bmN0aW9uIGhhc1ZlbG9jaXR5KHZlbG9jaXR5KSB7XG4gICAgdmFyIHRocmVzaG9sZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogUG9pbnRlci5TV0lQRV9WRUxPQ0lUWTtcblxuICAgIGlmICh0aGlzLmlzWUF4aXMoKSkge1xuICAgICAgcmV0dXJuIE1hdGguYWJzKHZlbG9jaXR5LnkpID4gdGhyZXNob2xkO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzWEF4aXMoKSkge1xuICAgICAgcmV0dXJuIE1hdGguYWJzKHZlbG9jaXR5LngpID4gdGhyZXNob2xkO1xuICAgIH1cblxuICAgIC8vIE90aGVyd2lzZSBjaGVjayBib3RoIGF4aXMgZm9yIHZlbG9jaXR5LlxuICAgIHJldHVybiBNYXRoLmFicyh2ZWxvY2l0eS54KSA+IHRocmVzaG9sZCB8fCBNYXRoLmFicyh2ZWxvY2l0eS55KSA+IHRocmVzaG9sZDtcbiAgfTtcblxuICAvKipcbiAgICogRW1pdHMgYSBldmVudCBvbiB0aGlzIGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gZXZlbnQgRXZlbnQgb2JqZWN0IHdpdGggZGF0YS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBwcmV2ZW50RGVmYXVsdCB3YXMgY2FsbGVkIG9uIHRoZSBldmVudC5cbiAgICovXG5cblxuICBQb2ludGVyLnByb3RvdHlwZS5fZW1pdEV2ZW50ID0gZnVuY3Rpb24gX2VtaXRFdmVudChldmVudCkge1xuICAgIHRoaXMuZW1pdChldmVudC50eXBlLCBldmVudCk7XG4gICAgcmV0dXJuIGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBldmVudCBsaXN0ZW5lcnMgYW5kIGVsZW1lbnQgcmVmZXJlbmNlcy5cbiAgICovXG5cblxuICBQb2ludGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICBjbGVhckludGVydmFsKHRoaXMuX3ZlbG9jaXR5VHJhY2tlcklkKTtcbiAgICB0aGlzLl9yZW1vdmVEcmFnSGFuZGxlcnMoKTtcblxuICAgIC8vIFJlbW92ZSBwb2ludGVyL21vdXNlL3RvdWNoIGV2ZW50cy5cbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudHMuUE9JTlRFUkRPV04sIHRoaXMuX29uU3RhcnQpO1xuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50cy5NT1VTRURPV04sIHRoaXMuX29uU3RhcnQpO1xuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50cy5UT1VDSFNUQVJULCB0aGlzLl9vblN0YXJ0KTtcblxuICAgIGlmICh0aGlzLl9pc1RvdWNoQWN0aW9uU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGVbUG9pbnRlci5Ub3VjaEFjdGlvblN1cHBvcnRbdGhpcy5vcHRpb25zLmF4aXNdXSA9ICcnO1xuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnByZXZlbnRFdmVudERlZmF1bHQgJiYgT2RvRGV2aWNlLkhBU19UT1VDSF9FVkVOVFMpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50cy5UT1VDSE1PVkUsIG5vb3ApO1xuICAgIH1cblxuICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgdGhpcy5kcmFnRXZlbnRUYXJnZXQgPSBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBldmVudCBpcyBmcm9tIGEgdG91Y2guXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBldnQgRXZlbnQgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cblxuXG4gIFBvaW50ZXIuaXNUb3VjaEV2ZW50ID0gZnVuY3Rpb24gaXNUb3VjaEV2ZW50KGV2dCkge1xuICAgIHJldHVybiAhIWV2dC5jaGFuZ2VkVG91Y2hlcztcbiAgfTtcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgZXZlbnQgaXMgZnJvbSBhIHBvaW50ZXIgY2FuY2VsIG9yIHRvdWNoIGNhbmNlbC5cbiAgICogQHBhcmFtIHtUb3VjaEV2ZW50fE1vdXNlRXZlbnR8UG9pbnRlckV2ZW50fSBldnQgRXZlbnQgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFBvaW50ZXIuX2lzQ2FuY2VsRXZlbnQgPSBmdW5jdGlvbiBfaXNDYW5jZWxFdmVudChldnQpIHtcbiAgICByZXR1cm4gZXZ0LnR5cGUgPT09IGV2ZW50cy5QT0lOVEVSQ0FOQ0VMIHx8IGV2dC50eXBlID09PSBldmVudHMuVE9VQ0hDQU5DRUw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBwYWdlIHggYW5kIHBhZ2UgeSBiYXNlZCBvbiBhbiBldmVudC4gSXQgbm9ybWFsaXplc1xuICAgKiB0b3VjaCBldmVudHMsIG1vdXNlIGV2ZW50cywgYW5kIHBvaW50ZXIgZXZlbnRzLlxuICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR8TW91c2VFdmVudHxQb2ludGVyRXZlbnR9IGV2dCBFdmVudCBvYmplY3QuXG4gICAqIEByZXR1cm4geyFDb29yZGluYXRlfSBUaGUgcGFnZVggYW5kIHBhZ2VZIG9mIHRoZSBwcmVzcy5cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICBQb2ludGVyLl9nZXRQYWdlQ29vcmRpbmF0ZSA9IGZ1bmN0aW9uIF9nZXRQYWdlQ29vcmRpbmF0ZShldnQpIHtcbiAgICB2YXIgcGFnZVBvaW50cyA9IHZvaWQgMDtcblxuICAgIC8vIFVzZSB0aGUgZmlyc3QgdG91Y2ggZm9yIHRoZSBwYWdlWCBhbmQgcGFnZVkuXG4gICAgaWYgKFBvaW50ZXIuaXNUb3VjaEV2ZW50KGV2dCkpIHtcbiAgICAgIHBhZ2VQb2ludHMgPSBldnQuY2hhbmdlZFRvdWNoZXNbMF07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICB9IGVsc2Uge1xuICAgICAgcGFnZVBvaW50cyA9IGV2dDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IENvb3JkaW5hdGUocGFnZVBvaW50cy5wYWdlWCwgcGFnZVBvaW50cy5wYWdlWSk7XG4gIH07XG5cbiAgUG9pbnRlci5fcHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiBfcHJldmVudERlZmF1bHQoZXZ0KSB7XG4gICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gIH07XG5cbiAgY3JlYXRlQ2xhc3MoUG9pbnRlciwgW3tcbiAgICBrZXk6ICdpc0VuYWJsZWQnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VuYWJsZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHdoZXRoZXIgZHJhZ2dlciBpcyBlbmFibGVkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZCBXaGV0aGVyIGRyYWdnZXIgaXMgZW5hYmxlZC5cbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEoZW5hYmxlZCkge1xuICAgICAgdGhpcy5fZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZnJpY3Rpb24nLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZyaWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZnJpY3Rpb24gdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZyaWN0aW9uIEEgbnVtYmVyIGJldHdlZW4gWzEsIDBdLlxuICAgICAqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMShmcmljdGlvbikge1xuICAgICAgdGhpcy5fZnJpY3Rpb24gPSBmcmljdGlvbjtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFBvaW50ZXI7XG59KFRpbnlFbWl0dGVyKTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5cblxuUG9pbnRlci5EaXJlY3Rpb24gPSBEaXJlY3Rpb247XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuUG9pbnRlci5BeGlzID0gQXhpcztcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5Qb2ludGVyLkV2ZW50VHlwZSA9IHtcbiAgU1RBUlQ6ICdvZG9wb2ludGVyOnN0YXJ0JyxcbiAgTU9WRTogJ29kb3BvaW50ZXI6bW92ZScsXG4gIEVORDogJ29kb3BvaW50ZXI6ZW5kJ1xufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd8Ym9vbGVhbn0gKi9cblBvaW50ZXIuVG91Y2hBY3Rpb25TdXBwb3J0ID0ge1xuICB4OiBPZG9EZXZpY2UucHJlZml4ZWQoJ3RvdWNoQWN0aW9uJywgJ3Bhbi15JyksXG4gIHk6IE9kb0RldmljZS5wcmVmaXhlZCgndG91Y2hBY3Rpb24nLCAncGFuLXgnKSxcbiAgeHk6IE9kb0RldmljZS5wcmVmaXhlZCgndG91Y2hBY3Rpb24nLCAnbm9uZScpXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cblBvaW50ZXIuVG91Y2hBY3Rpb24gPSB7XG4gIHg6ICdwYW4teScsXG4gIHk6ICdwYW4teCcsXG4gIHh5OiAnbm9uZSdcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge3theGlzOiBBeGlzLCBwcmV2ZW50RXZlbnREZWZhdWx0OiBib29sZWFufX0gUG9pbnRlck9wdGlvbnNcbiAqL1xuXG4vKiogQHR5cGUge1BvaW50ZXJPcHRpb25zfSAqL1xuUG9pbnRlci5EZWZhdWx0cyA9IHtcbiAgYXhpczogJ3h5JyxcbiAgcHJldmVudEV2ZW50RGVmYXVsdDogdHJ1ZVxufTtcblxuLyoqXG4gKiBUaGUgY3VycmVudCB2ZWxvY2l0eSBwcm9wZXJ0eSB3aWxsIGJlIGNsYW1wZWQgdG8gdGhpcyB2YWx1ZSAocGl4ZWxzL21pbGxpc2Vjb25kKS5cbiAqIEBjb25zdCB7bnVtYmVyfVxuICovXG5Qb2ludGVyLk1BWF9WRUxPQ0lUWSA9IDEyO1xuXG4vKipcbiAqIFdoZW4gdGhlIHBvaW50ZXIgaXMgZG93biwgYW4gaW50ZXJ2YWwgc3RhcnRzIHRvIHRyYWNrIHRoZSBjdXJyZW50IHZlbG9jaXR5LlxuICogQGNvbnN0IHtudW1iZXJ9XG4gKi9cblBvaW50ZXIuVkVMT0NJVFlfSU5URVJWQUwgPSAxMDA7XG5cbi8qKlxuICogVmVsb2NpdHkgcmVxdWlyZWQgZm9yIGEgbW92ZW1lbnQgdG8gYmUgY29uc2lkZXJlZCBhIHN3aXBlLlxuICogQGNvbnN0IHtudW1iZXJ9XG4gKi9cblBvaW50ZXIuU1dJUEVfVkVMT0NJVFkgPSAwLjY7XG5cbi8qKlxuICogVGhlIHNjcm9sbC9kcmFnIGFtb3VudCAocGl4ZWxzKSByZXF1aXJlZCBvbiB0aGUgZHJhZ2dhYmxlIGF4aXMgYmVmb3JlXG4gKiBzdG9wcGluZyBmdXJ0aGVyIHBhZ2Ugc2Nyb2xsaW5nL21vdmVtZW50LlxuICogQGNvbnN0IHtudW1iZXJ9XG4gKi9cblBvaW50ZXIuTE9DS19USFJFU0hPTEQgPSA2O1xuXG4vKipcbiAqIFRoZSBzY3JvbGwvZHJhZyBhbW91bnQgKHBpeGVscykgcmVxdWlyZWQgb24gdGhlIG9wcG9zaXRlIGRyYWdnYWJsZSBheGlzXG4gKiBiZWZvcmUgZHJhZ2dpbmcgaXMgZGVhY3RpdmF0ZWQgZm9yIHRoZSByZXN0IG9mIHRoZSBpbnRlcmFjdGlvbi5cbiAqIEBjb25zdCB7bnVtYmVyfVxuICovXG5Qb2ludGVyLkRSQUdfVEhSRVNIT0xEID0gNTtcblxuUG9pbnRlci5FdmVudCA9IFBvaW50ZXJFdmVudDtcblxuZXhwb3J0IGRlZmF1bHQgUG9pbnRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9kby1wb2ludGVyLmVzbS5qcy5tYXBcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@odopod/odo-pointer/dist/odo-pointer.esm.js\n");

/***/ }),

/***/ "./node_modules/@odopod/odo-responsive-images/dist/odo-responsive-images.esm.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@odopod/odo-responsive-images/dist/odo-responsive-images.esm.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var picturefill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! picturefill */ \"./node_modules/picturefill/dist/picturefill.js\");\n/* harmony import */ var picturefill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(picturefill__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _odopod_odo_viewport__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @odopod/odo-viewport */ \"./node_modules/@odopod/odo-viewport/dist/odo-viewport.esm.js\");\n\n\n\n/**\n * Returns a function, that, as long as it continues to be invoked, will not\n * be triggered. The function will be called after it stops being called for\n * N milliseconds. If `immediate` is passed, trigger the function on the\n * leading edge, instead of the trailing. The function also has a property 'clear' \n * that is a function which will clear the timer to prevent previously scheduled executions. \n *\n * @source underscore.js\n * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/\n * @param {Function} function to wrap\n * @param {Number} timeout in ms (`100`)\n * @param {Boolean} whether to execute at the beginning (`false`)\n * @api public\n */\n\nvar debounce = function debounce(func, wait, immediate) {\n  var timeout, args, context, timestamp, result;\n  if (null == wait) wait = 100;\n\n  function later() {\n    var last = Date.now() - timestamp;\n\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n      if (!immediate) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n    }\n  }\n\n  var debounced = function debounced() {\n    context = this;\n    args = arguments;\n    timestamp = Date.now();\n    var callNow = immediate && !timeout;\n    if (!timeout) timeout = setTimeout(later, wait);\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n\n    return result;\n  };\n\n  debounced.clear = function () {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n\n  debounced.flush = function () {\n    if (timeout) {\n      result = func.apply(context, args);\n      context = args = null;\n\n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n\n  return debounced;\n};\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\n/**\n * If the first parameter is not an array, return an array containing the first\n * parameter.\n * @param {*} thing Anything.\n * @return {Array.<*>} Array of things.\n */\nfunction arrayify(thing) {\n  if (Array.isArray(thing)) {\n    return thing;\n  }\n\n  if (thing && typeof thing.length === 'number') {\n    return Array.from(thing);\n  }\n\n  return [thing];\n}\n\n/**\n * Move children from one element to another. Ignores <noscript> elements.\n * @param {Element} fromElement Element to move children from.\n * @param {Element} toElement Element to move children to.\n * @private\n */\nfunction transferChildren(fromElement, toElement) {\n  // Include comment nodes. Convert to array because the NodeList is \"live\"\n  // and will be updated when an element is removed from it.\n  var frag = document.createDocumentFragment();\n  var children = Array.from(fromElement.childNodes);\n\n  for (var i = 0; i < children.length; i++) {\n    if (children[i].nodeName !== 'NOSCRIPT') {\n      frag.appendChild(children[i]);\n    }\n  }\n\n  toElement.appendChild(frag);\n}\n\n/**\n * Whether the given thing is an element.\n * @param {*} thing Thing to test.\n * @return {boolean}\n */\nfunction isElement(thing) {\n  return thing && thing.nodeType === 1;\n}\n\nvar ResponsiveImages = function () {\n  function ResponsiveImages() {\n    classCallCheck(this, ResponsiveImages);\n\n    /**\n     * Because this class is a singleton, assign settings to the instance.\n     * @enum {string}\n     */\n    this.ClassName = {\n      IMAGE: 'odo-responsive-img',\n      LOADED: 'odo-responsive-img--loaded'\n    };\n\n    /**\n     * An array of viewport item ids and picture elements.\n     * @type {Array.<{id: string, element: Element}>}\n     */\n    this.images = [];\n\n    // Save context for this callback so it can easily be removed.\n    this._imageLoadHandler = this._handleImageLoad.bind(this);\n    this._imageInViewHandler = this._handleImageInView.bind(this);\n\n    /**\n     * Debounce calls to `_update`.\n     * @type {function}\n     */\n    this.updateOffsets = debounce(this._update, ResponsiveImages.DEBOUNCE_TIME);\n  }\n\n  ResponsiveImages.prototype.initialize = function initialize() {\n    // Ignore elements which are already <picture>.\n    this._add(Array.from(document.querySelectorAll('.' + this.ClassName.IMAGE + ':not(picture)')));\n  };\n\n  /**\n   * Add an array of images to track.\n   * @param {Array.<Element>} newImages Images array.\n   */\n\n\n  ResponsiveImages.prototype._add = function _add(newImages) {\n    var _this = this;\n\n    var options = newImages.map(function (image) {\n      return _this._getViewportOptions(image);\n    });\n    var ids = _odopod_odo_viewport__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(options);\n    this.images = this.images.concat(ids.map(function (id, i) {\n      return {\n        id: id,\n        element: newImages[i]\n      };\n    }));\n  };\n\n  /**\n   * Retrieve options to give OdoViewport for an element.\n   * @param {Element} picture The picture/div element.\n   * @return {!Object} OdoViewportItem options.\n   */\n\n\n  ResponsiveImages.prototype._getViewportOptions = function _getViewportOptions(picture) {\n    return {\n      element: picture,\n      threshold: picture.getAttribute('data-threshold') || 0,\n      enter: this._imageInViewHandler\n    };\n  };\n\n  /**\n   * Callback for when the image has entered the viewport. This triggers the image\n   * to start loading.\n   * @param {ViewportItem} viewportItem Data about the element entering view.\n   */\n\n\n  ResponsiveImages.prototype._handleImageInView = function _handleImageInView(viewportItem) {\n    this._loadImage(viewportItem.element);\n  };\n\n  /**\n   * Given the parent placeholder div, load the responsive image inside it.\n   * @param {Element} placeholder An element with the odo responsive image class.\n   * @private\n   */\n\n\n  ResponsiveImages.prototype._loadImage = function _loadImage(placeholder) {\n    var img = placeholder.querySelector('img');\n\n    if (!img) {\n      throw new Error('Unable to find <img> element within Odo Responsive Images placeholder.');\n    }\n\n    var srcset = img.getAttribute('data-srcset');\n\n    // Determine if this is img[srcset] or if it should be a <picture>.\n    if (srcset !== null) {\n      // Not sure what is best here, setting the property or the attribute, for both\n      // picturefill and native responsive images, so both are set.\n      img.srcset = srcset;\n      img.setAttribute('srcset', srcset);\n      img.removeAttribute('data-srcset');\n      placeholder._odoResponsiveImageUsed = true;\n    } else {\n      // Create a new picture element with the same contents and replace the\n      // placeholder with it.\n      var parent = placeholder.parentElement;\n      var picture = document.createElement('picture');\n      picture.className = placeholder.className;\n      transferChildren(placeholder, picture);\n      var type = placeholder.getAttribute('data-type');\n      if (type) {\n        picture.setAttribute('data-type', type);\n      }\n\n      img = picture.querySelector('img');\n\n      // Replace the placeholder element with the picture.\n      parent.replaceChild(picture, placeholder);\n      picture._odoResponsiveImageUsed = true;\n    }\n\n    // Splice out of array.\n    this._removeImageEntry(placeholder);\n\n    // Now that the DOM is in the final state, see if this image is already loaded.\n    if (this.isImageLoaded(img)) {\n      setTimeout(this._handleImageLoad.bind(this, {\n        target: img\n      }), 30);\n    }\n\n    // When the image first loads, add the loaded class and possibly update\n    // the background-image property.\n    img.addEventListener('load', this._imageLoadHandler, false);\n    img.addEventListener('error', this._imageLoadHandler, false);\n\n    // Run picturefill on the new element.\n    picturefill__WEBPACK_IMPORTED_MODULE_0___default()({\n      elements: [img]\n    });\n  };\n\n  /**\n   * Retrieve the image object which matches the given placeholder element.\n   * @param {Element} placeholder Responsive image element wrapper (the one which\n   *     gets replaced when using <picture>).\n   * @return {?number} Index of the responsive image object.\n   */\n\n\n  ResponsiveImages.prototype._getImageIndexByPlaceholder = function _getImageIndexByPlaceholder(placeholder) {\n    var index = null;\n\n    for (var i = 0, len = this.images.length; i < len; i++) {\n      if (this.images[i].element === placeholder) {\n        index = i;\n        break;\n      }\n    }\n\n    return index;\n  };\n\n  /**\n   * Removes an image stored in the `images` array from the array and from the\n   * Viewport watcher.\n   * @param {Element} placeholder Placeholder element.\n   * @private\n   */\n\n\n  ResponsiveImages.prototype._removeImageEntry = function _removeImageEntry(placeholder) {\n    var index = this._getImageIndexByPlaceholder(placeholder);\n\n    // Unable to find the index of the placeholder image. It is either already\n    // loaded, or the \"placeholder\" was the replacement?\n    if (index === null) {\n      return;\n    }\n\n    _odopod_odo_viewport__WEBPACK_IMPORTED_MODULE_1__[\"default\"].remove(this.images[index].id);\n    this.images.splice(index, 1);\n  };\n\n  /**\n   * Whether an image element has already been loaded.\n   * @param {HTMLImageElement} img The <img>.\n   * @return {boolean}\n   */\n\n\n  ResponsiveImages.prototype.isImageLoaded = function isImageLoaded(img) {\n    return img.naturalWidth > 0;\n  };\n\n  /**\n   * Determine if this is element should use a background image.\n   * @param {HTMLImageElement} img Image in question.\n   * @return {boolean}\n   */\n\n\n  ResponsiveImages.prototype._isBackgroundImage = function _isBackgroundImage(img) {\n    return img.parentElement.getAttribute('data-type') === 'background';\n  };\n\n  /**\n   * Whether the given element is a Odo Responsive Image which is not already\n   * loading and has not been loaded yet.\n   * @param {Element} picture Element to test.\n   */\n\n\n  ResponsiveImages.prototype._isUnloadedResponsiveImage = function _isUnloadedResponsiveImage(picture) {\n    if (!isElement(picture)) {\n      throw new TypeError('Odo Responsive Images requires an element. Got: \"' + picture + '\"');\n    }\n\n    if (!picture.classList.contains(this.ClassName.IMAGE)) {\n      throw new TypeError(picture + ' is not a Odo Responsive Image.');\n    }\n\n    // The _loadImage method adds this property to the picture (or div when using\n    // img[srcset]) after it has done its business.\n    return picture._odoResponsiveImageUsed !== true;\n  };\n\n  /**\n   * Whether the given element is already in the `images` object array.\n   * @param {Element} placeholder Element to test.\n   * @return {boolean}\n   */\n\n\n  ResponsiveImages.prototype.isUntrackedImage = function isUntrackedImage(placeholder) {\n    return this._getImageIndexByPlaceholder(placeholder) === null;\n  };\n\n  /**\n   * Load event handler for images.\n   * @param {UIEvent} evt Image load event object.\n   */\n\n\n  ResponsiveImages.prototype._handleImageLoad = function _handleImageLoad(evt) {\n    var _this2 = this;\n\n    var img = /** @type {HTMLImageElement} */evt.target;\n\n    // Exit early if this image is longer in the DOM.\n    if (!img.parentNode) {\n      return;\n    }\n\n    // Call debounced update offsets because once an image loads, it could\n    // offset everything below it on the page.\n    this.updateOffsets();\n\n    // Set the background image url if it has a [data-type=\"background\"] attribute.\n    if (this._isBackgroundImage(img)) {\n      this._updateBackgroundImage(img);\n    } else {\n      // No longer need to listen for the load event for <picture>s. It will be\n      // handled natively or by picturefill.\n      this._removeImageHandlers(img);\n    }\n\n    // Write to the DOM all at once if many images load at the same time.\n    requestAnimationFrame(function () {\n      // classList is smart enough not to change the className property if the\n      // element already has the class which is being added.\n      img.parentNode.classList.add(_this2.ClassName.LOADED);\n    });\n  };\n\n  /**\n   * Update the background image property with the current source of a responsive image.\n   * @param {HTMLImageElement} img Image element.\n   */\n\n\n  ResponsiveImages.prototype._updateBackgroundImage = function _updateBackgroundImage(img) {\n    img.parentNode.style.backgroundImage = 'url(\"' + (img.currentSrc || img.src) + '\")';\n  };\n\n  /**\n   * Notify the Viewport to update its value. This method is called when a new\n   * image loads. It should also be called manually if offsets on the page change.\n   */\n\n\n  ResponsiveImages.prototype._update = function _update() {\n    _odopod_odo_viewport__WEBPACK_IMPORTED_MODULE_1__[\"default\"].update();\n  };\n\n  /**\n   * Remove the event listeners bound to the image.\n   * @param {Element} img Image element.\n   */\n\n\n  ResponsiveImages.prototype._removeImageHandlers = function _removeImageHandlers(img) {\n    if (img) {\n      img.removeEventListener('load', this._imageLoadHandler, false);\n      img.removeEventListener('error', this._imageLoadHandler, false);\n    }\n  };\n\n  /**\n   * Clean up all references and listeners for current images.\n   */\n\n\n  ResponsiveImages.prototype.flush = function flush() {\n    var _this3 = this;\n\n    // Remove load listener for each image and stop the Viewport component\n    // from watching it.\n    this.images.forEach(function (image) {\n      var img = image.element.querySelector('img');\n      _this3._removeImageHandlers(img);\n      _odopod_odo_viewport__WEBPACK_IMPORTED_MODULE_1__[\"default\"].remove(image.id);\n    });\n\n    this.images.length = 0;\n\n    // Remove all `load` events from background images.\n    var selector = '.' + this.ClassName.IMAGE + '[data-type=\"background\"] img';\n    Array.from(document.querySelectorAll(selector)).forEach(function (img) {\n      _this3._removeImageHandlers(img);\n    });\n  };\n\n  /**\n   * Remove watched images from this component.\n   * @param {Element|Array.<Element>} placeholders An element or array of elements.\n   *     The element should be the parent element of the <img>.\n   */\n\n\n  ResponsiveImages.prototype.remove = function remove(placeholders) {\n    var _this4 = this;\n\n    arrayify(placeholders).forEach(function (placeholder) {\n      _this4._removeImageEntry(placeholder);\n      _this4._removeImageHandlers(placeholder.querySelector('img'));\n    });\n  };\n\n  /**\n   * Add more images for the ResponsiveImages component to watch.\n   * @param {Element|Array.<Element>} pictures An element or array of elements.\n   *     The element should be the parent element of the <img>.\n   */\n\n\n  ResponsiveImages.prototype.add = function add(pictures) {\n    var pics = arrayify(pictures).filter(this._isUnloadedResponsiveImage, this).filter(this.isUntrackedImage, this);\n\n    if (pics.length === 0) {\n      return;\n    }\n\n    this._add(pics);\n  };\n\n  /**\n   * Force the load of an element or group of elements instead of waiting for it\n   * to come into the viewport.\n   * @param {Element|Array.<Element>} pictures An element or array of elements.\n   *     The element should be the parent element of the <img>.\n   */\n\n\n  ResponsiveImages.prototype.load = function load(pictures) {\n    arrayify(pictures).filter(this._isUnloadedResponsiveImage, this).forEach(this._loadImage, this);\n  };\n\n  return ResponsiveImages;\n}();\n\nResponsiveImages.DEBOUNCE_TIME = 300;\n\n// Create a single instance and return that.\nvar responsiveImages = new ResponsiveImages();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (responsiveImages);\n//# sourceMappingURL=odo-responsive-images.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG9kb3BvZC9vZG8tcmVzcG9uc2l2ZS1pbWFnZXMvZGlzdC9vZG8tcmVzcG9uc2l2ZS1pbWFnZXMuZXNtLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BvZG9wb2Qvb2RvLXJlc3BvbnNpdmUtaW1hZ2VzL2Rpc3Qvb2RvLXJlc3BvbnNpdmUtaW1hZ2VzLmVzbS5qcz83MmJmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwaWN0dXJlZmlsbCBmcm9tICdwaWN0dXJlZmlsbCc7XG5pbXBvcnQgVmlld3BvcnQgZnJvbSAnQG9kb3BvZC9vZG8tdmlld3BvcnQnO1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3RcbiAqIGJlIHRyaWdnZXJlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGl0IHN0b3BzIGJlaW5nIGNhbGxlZCBmb3JcbiAqIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxuICogbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy4gVGhlIGZ1bmN0aW9uIGFsc28gaGFzIGEgcHJvcGVydHkgJ2NsZWFyJyBcbiAqIHRoYXQgaXMgYSBmdW5jdGlvbiB3aGljaCB3aWxsIGNsZWFyIHRoZSB0aW1lciB0byBwcmV2ZW50IHByZXZpb3VzbHkgc2NoZWR1bGVkIGV4ZWN1dGlvbnMuIFxuICpcbiAqIEBzb3VyY2UgdW5kZXJzY29yZS5qc1xuICogQHNlZSBodHRwOi8vdW5zY3JpcHRhYmxlLmNvbS8yMDA5LzAzLzIwL2RlYm91bmNpbmctamF2YXNjcmlwdC1tZXRob2RzL1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY3Rpb24gdG8gd3JhcFxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXQgaW4gbXMgKGAxMDBgKVxuICogQHBhcmFtIHtCb29sZWFufSB3aGV0aGVyIHRvIGV4ZWN1dGUgYXQgdGhlIGJlZ2lubmluZyAoYGZhbHNlYClcbiAqIEBhcGkgcHVibGljXG4gKi9cblxudmFyIGRlYm91bmNlID0gZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gIHZhciB0aW1lb3V0LCBhcmdzLCBjb250ZXh0LCB0aW1lc3RhbXAsIHJlc3VsdDtcbiAgaWYgKG51bGwgPT0gd2FpdCkgd2FpdCA9IDEwMDtcblxuICBmdW5jdGlvbiBsYXRlcigpIHtcbiAgICB2YXIgbGFzdCA9IERhdGUubm93KCkgLSB0aW1lc3RhbXA7XG5cbiAgICBpZiAobGFzdCA8IHdhaXQgJiYgbGFzdCA+PSAwKSB7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCAtIGxhc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIGlmICghaW1tZWRpYXRlKSB7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZGVib3VuY2VkID0gZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgIGNvbnRleHQgPSB0aGlzO1xuICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICBpZiAoIXRpbWVvdXQpIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICBpZiAoY2FsbE5vdykge1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIGRlYm91bmNlZC5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIGRlYm91bmNlZC5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGltZW91dCkge1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcblxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBkZWJvdW5jZWQ7XG59O1xuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxuLyoqXG4gKiBJZiB0aGUgZmlyc3QgcGFyYW1ldGVyIGlzIG5vdCBhbiBhcnJheSwgcmV0dXJuIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGZpcnN0XG4gKiBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0geyp9IHRoaW5nIEFueXRoaW5nLlxuICogQHJldHVybiB7QXJyYXkuPCo+fSBBcnJheSBvZiB0aGluZ3MuXG4gKi9cbmZ1bmN0aW9uIGFycmF5aWZ5KHRoaW5nKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRoaW5nKSkge1xuICAgIHJldHVybiB0aGluZztcbiAgfVxuXG4gIGlmICh0aGluZyAmJiB0eXBlb2YgdGhpbmcubGVuZ3RoID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaW5nKTtcbiAgfVxuXG4gIHJldHVybiBbdGhpbmddO1xufVxuXG4vKipcbiAqIE1vdmUgY2hpbGRyZW4gZnJvbSBvbmUgZWxlbWVudCB0byBhbm90aGVyLiBJZ25vcmVzIDxub3NjcmlwdD4gZWxlbWVudHMuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGZyb21FbGVtZW50IEVsZW1lbnQgdG8gbW92ZSBjaGlsZHJlbiBmcm9tLlxuICogQHBhcmFtIHtFbGVtZW50fSB0b0VsZW1lbnQgRWxlbWVudCB0byBtb3ZlIGNoaWxkcmVuIHRvLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdHJhbnNmZXJDaGlsZHJlbihmcm9tRWxlbWVudCwgdG9FbGVtZW50KSB7XG4gIC8vIEluY2x1ZGUgY29tbWVudCBub2Rlcy4gQ29udmVydCB0byBhcnJheSBiZWNhdXNlIHRoZSBOb2RlTGlzdCBpcyBcImxpdmVcIlxuICAvLyBhbmQgd2lsbCBiZSB1cGRhdGVkIHdoZW4gYW4gZWxlbWVudCBpcyByZW1vdmVkIGZyb20gaXQuXG4gIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICB2YXIgY2hpbGRyZW4gPSBBcnJheS5mcm9tKGZyb21FbGVtZW50LmNoaWxkTm9kZXMpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoY2hpbGRyZW5baV0ubm9kZU5hbWUgIT09ICdOT1NDUklQVCcpIHtcbiAgICAgIGZyYWcuYXBwZW5kQ2hpbGQoY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgfVxuXG4gIHRvRWxlbWVudC5hcHBlbmRDaGlsZChmcmFnKTtcbn1cblxuLyoqXG4gKiBXaGV0aGVyIHRoZSBnaXZlbiB0aGluZyBpcyBhbiBlbGVtZW50LlxuICogQHBhcmFtIHsqfSB0aGluZyBUaGluZyB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNFbGVtZW50KHRoaW5nKSB7XG4gIHJldHVybiB0aGluZyAmJiB0aGluZy5ub2RlVHlwZSA9PT0gMTtcbn1cblxudmFyIFJlc3BvbnNpdmVJbWFnZXMgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlc3BvbnNpdmVJbWFnZXMoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVzcG9uc2l2ZUltYWdlcyk7XG5cbiAgICAvKipcbiAgICAgKiBCZWNhdXNlIHRoaXMgY2xhc3MgaXMgYSBzaW5nbGV0b24sIGFzc2lnbiBzZXR0aW5ncyB0byB0aGUgaW5zdGFuY2UuXG4gICAgICogQGVudW0ge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLkNsYXNzTmFtZSA9IHtcbiAgICAgIElNQUdFOiAnb2RvLXJlc3BvbnNpdmUtaW1nJyxcbiAgICAgIExPQURFRDogJ29kby1yZXNwb25zaXZlLWltZy0tbG9hZGVkJ1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiB2aWV3cG9ydCBpdGVtIGlkcyBhbmQgcGljdHVyZSBlbGVtZW50cy5cbiAgICAgKiBAdHlwZSB7QXJyYXkuPHtpZDogc3RyaW5nLCBlbGVtZW50OiBFbGVtZW50fT59XG4gICAgICovXG4gICAgdGhpcy5pbWFnZXMgPSBbXTtcblxuICAgIC8vIFNhdmUgY29udGV4dCBmb3IgdGhpcyBjYWxsYmFjayBzbyBpdCBjYW4gZWFzaWx5IGJlIHJlbW92ZWQuXG4gICAgdGhpcy5faW1hZ2VMb2FkSGFuZGxlciA9IHRoaXMuX2hhbmRsZUltYWdlTG9hZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2ltYWdlSW5WaWV3SGFuZGxlciA9IHRoaXMuX2hhbmRsZUltYWdlSW5WaWV3LmJpbmQodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBEZWJvdW5jZSBjYWxscyB0byBgX3VwZGF0ZWAuXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMudXBkYXRlT2Zmc2V0cyA9IGRlYm91bmNlKHRoaXMuX3VwZGF0ZSwgUmVzcG9uc2l2ZUltYWdlcy5ERUJPVU5DRV9USU1FKTtcbiAgfVxuXG4gIFJlc3BvbnNpdmVJbWFnZXMucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIC8vIElnbm9yZSBlbGVtZW50cyB3aGljaCBhcmUgYWxyZWFkeSA8cGljdHVyZT4uXG4gICAgdGhpcy5fYWRkKEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLicgKyB0aGlzLkNsYXNzTmFtZS5JTUFHRSArICc6bm90KHBpY3R1cmUpJykpKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGFuIGFycmF5IG9mIGltYWdlcyB0byB0cmFjay5cbiAgICogQHBhcmFtIHtBcnJheS48RWxlbWVudD59IG5ld0ltYWdlcyBJbWFnZXMgYXJyYXkuXG4gICAqL1xuXG5cbiAgUmVzcG9uc2l2ZUltYWdlcy5wcm90b3R5cGUuX2FkZCA9IGZ1bmN0aW9uIF9hZGQobmV3SW1hZ2VzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBvcHRpb25zID0gbmV3SW1hZ2VzLm1hcChmdW5jdGlvbiAoaW1hZ2UpIHtcbiAgICAgIHJldHVybiBfdGhpcy5fZ2V0Vmlld3BvcnRPcHRpb25zKGltYWdlKTtcbiAgICB9KTtcbiAgICB2YXIgaWRzID0gVmlld3BvcnQuYWRkKG9wdGlvbnMpO1xuICAgIHRoaXMuaW1hZ2VzID0gdGhpcy5pbWFnZXMuY29uY2F0KGlkcy5tYXAoZnVuY3Rpb24gKGlkLCBpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIGVsZW1lbnQ6IG5ld0ltYWdlc1tpXVxuICAgICAgfTtcbiAgICB9KSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIG9wdGlvbnMgdG8gZ2l2ZSBPZG9WaWV3cG9ydCBmb3IgYW4gZWxlbWVudC5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBwaWN0dXJlIFRoZSBwaWN0dXJlL2RpdiBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHshT2JqZWN0fSBPZG9WaWV3cG9ydEl0ZW0gb3B0aW9ucy5cbiAgICovXG5cblxuICBSZXNwb25zaXZlSW1hZ2VzLnByb3RvdHlwZS5fZ2V0Vmlld3BvcnRPcHRpb25zID0gZnVuY3Rpb24gX2dldFZpZXdwb3J0T3B0aW9ucyhwaWN0dXJlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW1lbnQ6IHBpY3R1cmUsXG4gICAgICB0aHJlc2hvbGQ6IHBpY3R1cmUuZ2V0QXR0cmlidXRlKCdkYXRhLXRocmVzaG9sZCcpIHx8IDAsXG4gICAgICBlbnRlcjogdGhpcy5faW1hZ2VJblZpZXdIYW5kbGVyXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZm9yIHdoZW4gdGhlIGltYWdlIGhhcyBlbnRlcmVkIHRoZSB2aWV3cG9ydC4gVGhpcyB0cmlnZ2VycyB0aGUgaW1hZ2VcbiAgICogdG8gc3RhcnQgbG9hZGluZy5cbiAgICogQHBhcmFtIHtWaWV3cG9ydEl0ZW19IHZpZXdwb3J0SXRlbSBEYXRhIGFib3V0IHRoZSBlbGVtZW50IGVudGVyaW5nIHZpZXcuXG4gICAqL1xuXG5cbiAgUmVzcG9uc2l2ZUltYWdlcy5wcm90b3R5cGUuX2hhbmRsZUltYWdlSW5WaWV3ID0gZnVuY3Rpb24gX2hhbmRsZUltYWdlSW5WaWV3KHZpZXdwb3J0SXRlbSkge1xuICAgIHRoaXMuX2xvYWRJbWFnZSh2aWV3cG9ydEl0ZW0uZWxlbWVudCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdpdmVuIHRoZSBwYXJlbnQgcGxhY2Vob2xkZXIgZGl2LCBsb2FkIHRoZSByZXNwb25zaXZlIGltYWdlIGluc2lkZSBpdC5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBwbGFjZWhvbGRlciBBbiBlbGVtZW50IHdpdGggdGhlIG9kbyByZXNwb25zaXZlIGltYWdlIGNsYXNzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFJlc3BvbnNpdmVJbWFnZXMucHJvdG90eXBlLl9sb2FkSW1hZ2UgPSBmdW5jdGlvbiBfbG9hZEltYWdlKHBsYWNlaG9sZGVyKSB7XG4gICAgdmFyIGltZyA9IHBsYWNlaG9sZGVyLnF1ZXJ5U2VsZWN0b3IoJ2ltZycpO1xuXG4gICAgaWYgKCFpbWcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgPGltZz4gZWxlbWVudCB3aXRoaW4gT2RvIFJlc3BvbnNpdmUgSW1hZ2VzIHBsYWNlaG9sZGVyLicpO1xuICAgIH1cblxuICAgIHZhciBzcmNzZXQgPSBpbWcuZ2V0QXR0cmlidXRlKCdkYXRhLXNyY3NldCcpO1xuXG4gICAgLy8gRGV0ZXJtaW5lIGlmIHRoaXMgaXMgaW1nW3NyY3NldF0gb3IgaWYgaXQgc2hvdWxkIGJlIGEgPHBpY3R1cmU+LlxuICAgIGlmIChzcmNzZXQgIT09IG51bGwpIHtcbiAgICAgIC8vIE5vdCBzdXJlIHdoYXQgaXMgYmVzdCBoZXJlLCBzZXR0aW5nIHRoZSBwcm9wZXJ0eSBvciB0aGUgYXR0cmlidXRlLCBmb3IgYm90aFxuICAgICAgLy8gcGljdHVyZWZpbGwgYW5kIG5hdGl2ZSByZXNwb25zaXZlIGltYWdlcywgc28gYm90aCBhcmUgc2V0LlxuICAgICAgaW1nLnNyY3NldCA9IHNyY3NldDtcbiAgICAgIGltZy5zZXRBdHRyaWJ1dGUoJ3NyY3NldCcsIHNyY3NldCk7XG4gICAgICBpbWcucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXNyY3NldCcpO1xuICAgICAgcGxhY2Vob2xkZXIuX29kb1Jlc3BvbnNpdmVJbWFnZVVzZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDcmVhdGUgYSBuZXcgcGljdHVyZSBlbGVtZW50IHdpdGggdGhlIHNhbWUgY29udGVudHMgYW5kIHJlcGxhY2UgdGhlXG4gICAgICAvLyBwbGFjZWhvbGRlciB3aXRoIGl0LlxuICAgICAgdmFyIHBhcmVudCA9IHBsYWNlaG9sZGVyLnBhcmVudEVsZW1lbnQ7XG4gICAgICB2YXIgcGljdHVyZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3BpY3R1cmUnKTtcbiAgICAgIHBpY3R1cmUuY2xhc3NOYW1lID0gcGxhY2Vob2xkZXIuY2xhc3NOYW1lO1xuICAgICAgdHJhbnNmZXJDaGlsZHJlbihwbGFjZWhvbGRlciwgcGljdHVyZSk7XG4gICAgICB2YXIgdHlwZSA9IHBsYWNlaG9sZGVyLmdldEF0dHJpYnV0ZSgnZGF0YS10eXBlJyk7XG4gICAgICBpZiAodHlwZSkge1xuICAgICAgICBwaWN0dXJlLnNldEF0dHJpYnV0ZSgnZGF0YS10eXBlJywgdHlwZSk7XG4gICAgICB9XG5cbiAgICAgIGltZyA9IHBpY3R1cmUucXVlcnlTZWxlY3RvcignaW1nJyk7XG5cbiAgICAgIC8vIFJlcGxhY2UgdGhlIHBsYWNlaG9sZGVyIGVsZW1lbnQgd2l0aCB0aGUgcGljdHVyZS5cbiAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQocGljdHVyZSwgcGxhY2Vob2xkZXIpO1xuICAgICAgcGljdHVyZS5fb2RvUmVzcG9uc2l2ZUltYWdlVXNlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gU3BsaWNlIG91dCBvZiBhcnJheS5cbiAgICB0aGlzLl9yZW1vdmVJbWFnZUVudHJ5KHBsYWNlaG9sZGVyKTtcblxuICAgIC8vIE5vdyB0aGF0IHRoZSBET00gaXMgaW4gdGhlIGZpbmFsIHN0YXRlLCBzZWUgaWYgdGhpcyBpbWFnZSBpcyBhbHJlYWR5IGxvYWRlZC5cbiAgICBpZiAodGhpcy5pc0ltYWdlTG9hZGVkKGltZykpIHtcbiAgICAgIHNldFRpbWVvdXQodGhpcy5faGFuZGxlSW1hZ2VMb2FkLmJpbmQodGhpcywge1xuICAgICAgICB0YXJnZXQ6IGltZ1xuICAgICAgfSksIDMwKTtcbiAgICB9XG5cbiAgICAvLyBXaGVuIHRoZSBpbWFnZSBmaXJzdCBsb2FkcywgYWRkIHRoZSBsb2FkZWQgY2xhc3MgYW5kIHBvc3NpYmx5IHVwZGF0ZVxuICAgIC8vIHRoZSBiYWNrZ3JvdW5kLWltYWdlIHByb3BlcnR5LlxuICAgIGltZy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy5faW1hZ2VMb2FkSGFuZGxlciwgZmFsc2UpO1xuICAgIGltZy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMuX2ltYWdlTG9hZEhhbmRsZXIsIGZhbHNlKTtcblxuICAgIC8vIFJ1biBwaWN0dXJlZmlsbCBvbiB0aGUgbmV3IGVsZW1lbnQuXG4gICAgcGljdHVyZWZpbGwoe1xuICAgICAgZWxlbWVudHM6IFtpbWddXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBpbWFnZSBvYmplY3Qgd2hpY2ggbWF0Y2hlcyB0aGUgZ2l2ZW4gcGxhY2Vob2xkZXIgZWxlbWVudC5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBwbGFjZWhvbGRlciBSZXNwb25zaXZlIGltYWdlIGVsZW1lbnQgd3JhcHBlciAodGhlIG9uZSB3aGljaFxuICAgKiAgICAgZ2V0cyByZXBsYWNlZCB3aGVuIHVzaW5nIDxwaWN0dXJlPikuXG4gICAqIEByZXR1cm4gez9udW1iZXJ9IEluZGV4IG9mIHRoZSByZXNwb25zaXZlIGltYWdlIG9iamVjdC5cbiAgICovXG5cblxuICBSZXNwb25zaXZlSW1hZ2VzLnByb3RvdHlwZS5fZ2V0SW1hZ2VJbmRleEJ5UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiBfZ2V0SW1hZ2VJbmRleEJ5UGxhY2Vob2xkZXIocGxhY2Vob2xkZXIpIHtcbiAgICB2YXIgaW5kZXggPSBudWxsO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuaW1hZ2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5pbWFnZXNbaV0uZWxlbWVudCA9PT0gcGxhY2Vob2xkZXIpIHtcbiAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXg7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gaW1hZ2Ugc3RvcmVkIGluIHRoZSBgaW1hZ2VzYCBhcnJheSBmcm9tIHRoZSBhcnJheSBhbmQgZnJvbSB0aGVcbiAgICogVmlld3BvcnQgd2F0Y2hlci5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBwbGFjZWhvbGRlciBQbGFjZWhvbGRlciBlbGVtZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuXG4gIFJlc3BvbnNpdmVJbWFnZXMucHJvdG90eXBlLl9yZW1vdmVJbWFnZUVudHJ5ID0gZnVuY3Rpb24gX3JlbW92ZUltYWdlRW50cnkocGxhY2Vob2xkZXIpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLl9nZXRJbWFnZUluZGV4QnlQbGFjZWhvbGRlcihwbGFjZWhvbGRlcik7XG5cbiAgICAvLyBVbmFibGUgdG8gZmluZCB0aGUgaW5kZXggb2YgdGhlIHBsYWNlaG9sZGVyIGltYWdlLiBJdCBpcyBlaXRoZXIgYWxyZWFkeVxuICAgIC8vIGxvYWRlZCwgb3IgdGhlIFwicGxhY2Vob2xkZXJcIiB3YXMgdGhlIHJlcGxhY2VtZW50P1xuICAgIGlmIChpbmRleCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIFZpZXdwb3J0LnJlbW92ZSh0aGlzLmltYWdlc1tpbmRleF0uaWQpO1xuICAgIHRoaXMuaW1hZ2VzLnNwbGljZShpbmRleCwgMSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgYW4gaW1hZ2UgZWxlbWVudCBoYXMgYWxyZWFkeSBiZWVuIGxvYWRlZC5cbiAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fSBpbWcgVGhlIDxpbWc+LlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cblxuXG4gIFJlc3BvbnNpdmVJbWFnZXMucHJvdG90eXBlLmlzSW1hZ2VMb2FkZWQgPSBmdW5jdGlvbiBpc0ltYWdlTG9hZGVkKGltZykge1xuICAgIHJldHVybiBpbWcubmF0dXJhbFdpZHRoID4gMDtcbiAgfTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIHRoaXMgaXMgZWxlbWVudCBzaG91bGQgdXNlIGEgYmFja2dyb3VuZCBpbWFnZS5cbiAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fSBpbWcgSW1hZ2UgaW4gcXVlc3Rpb24uXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuXG5cbiAgUmVzcG9uc2l2ZUltYWdlcy5wcm90b3R5cGUuX2lzQmFja2dyb3VuZEltYWdlID0gZnVuY3Rpb24gX2lzQmFja2dyb3VuZEltYWdlKGltZykge1xuICAgIHJldHVybiBpbWcucGFyZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdHlwZScpID09PSAnYmFja2dyb3VuZCc7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGdpdmVuIGVsZW1lbnQgaXMgYSBPZG8gUmVzcG9uc2l2ZSBJbWFnZSB3aGljaCBpcyBub3QgYWxyZWFkeVxuICAgKiBsb2FkaW5nIGFuZCBoYXMgbm90IGJlZW4gbG9hZGVkIHlldC5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBwaWN0dXJlIEVsZW1lbnQgdG8gdGVzdC5cbiAgICovXG5cblxuICBSZXNwb25zaXZlSW1hZ2VzLnByb3RvdHlwZS5faXNVbmxvYWRlZFJlc3BvbnNpdmVJbWFnZSA9IGZ1bmN0aW9uIF9pc1VubG9hZGVkUmVzcG9uc2l2ZUltYWdlKHBpY3R1cmUpIHtcbiAgICBpZiAoIWlzRWxlbWVudChwaWN0dXJlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT2RvIFJlc3BvbnNpdmUgSW1hZ2VzIHJlcXVpcmVzIGFuIGVsZW1lbnQuIEdvdDogXCInICsgcGljdHVyZSArICdcIicpO1xuICAgIH1cblxuICAgIGlmICghcGljdHVyZS5jbGFzc0xpc3QuY29udGFpbnModGhpcy5DbGFzc05hbWUuSU1BR0UpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHBpY3R1cmUgKyAnIGlzIG5vdCBhIE9kbyBSZXNwb25zaXZlIEltYWdlLicpO1xuICAgIH1cblxuICAgIC8vIFRoZSBfbG9hZEltYWdlIG1ldGhvZCBhZGRzIHRoaXMgcHJvcGVydHkgdG8gdGhlIHBpY3R1cmUgKG9yIGRpdiB3aGVuIHVzaW5nXG4gICAgLy8gaW1nW3NyY3NldF0pIGFmdGVyIGl0IGhhcyBkb25lIGl0cyBidXNpbmVzcy5cbiAgICByZXR1cm4gcGljdHVyZS5fb2RvUmVzcG9uc2l2ZUltYWdlVXNlZCAhPT0gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgZ2l2ZW4gZWxlbWVudCBpcyBhbHJlYWR5IGluIHRoZSBgaW1hZ2VzYCBvYmplY3QgYXJyYXkuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcGxhY2Vob2xkZXIgRWxlbWVudCB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cblxuXG4gIFJlc3BvbnNpdmVJbWFnZXMucHJvdG90eXBlLmlzVW50cmFja2VkSW1hZ2UgPSBmdW5jdGlvbiBpc1VudHJhY2tlZEltYWdlKHBsYWNlaG9sZGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldEltYWdlSW5kZXhCeVBsYWNlaG9sZGVyKHBsYWNlaG9sZGVyKSA9PT0gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogTG9hZCBldmVudCBoYW5kbGVyIGZvciBpbWFnZXMuXG4gICAqIEBwYXJhbSB7VUlFdmVudH0gZXZ0IEltYWdlIGxvYWQgZXZlbnQgb2JqZWN0LlxuICAgKi9cblxuXG4gIFJlc3BvbnNpdmVJbWFnZXMucHJvdG90eXBlLl9oYW5kbGVJbWFnZUxvYWQgPSBmdW5jdGlvbiBfaGFuZGxlSW1hZ2VMb2FkKGV2dCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIGltZyA9IC8qKiBAdHlwZSB7SFRNTEltYWdlRWxlbWVudH0gKi9ldnQudGFyZ2V0O1xuXG4gICAgLy8gRXhpdCBlYXJseSBpZiB0aGlzIGltYWdlIGlzIGxvbmdlciBpbiB0aGUgRE9NLlxuICAgIGlmICghaW1nLnBhcmVudE5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDYWxsIGRlYm91bmNlZCB1cGRhdGUgb2Zmc2V0cyBiZWNhdXNlIG9uY2UgYW4gaW1hZ2UgbG9hZHMsIGl0IGNvdWxkXG4gICAgLy8gb2Zmc2V0IGV2ZXJ5dGhpbmcgYmVsb3cgaXQgb24gdGhlIHBhZ2UuXG4gICAgdGhpcy51cGRhdGVPZmZzZXRzKCk7XG5cbiAgICAvLyBTZXQgdGhlIGJhY2tncm91bmQgaW1hZ2UgdXJsIGlmIGl0IGhhcyBhIFtkYXRhLXR5cGU9XCJiYWNrZ3JvdW5kXCJdIGF0dHJpYnV0ZS5cbiAgICBpZiAodGhpcy5faXNCYWNrZ3JvdW5kSW1hZ2UoaW1nKSkge1xuICAgICAgdGhpcy5fdXBkYXRlQmFja2dyb3VuZEltYWdlKGltZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vIGxvbmdlciBuZWVkIHRvIGxpc3RlbiBmb3IgdGhlIGxvYWQgZXZlbnQgZm9yIDxwaWN0dXJlPnMuIEl0IHdpbGwgYmVcbiAgICAgIC8vIGhhbmRsZWQgbmF0aXZlbHkgb3IgYnkgcGljdHVyZWZpbGwuXG4gICAgICB0aGlzLl9yZW1vdmVJbWFnZUhhbmRsZXJzKGltZyk7XG4gICAgfVxuXG4gICAgLy8gV3JpdGUgdG8gdGhlIERPTSBhbGwgYXQgb25jZSBpZiBtYW55IGltYWdlcyBsb2FkIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGNsYXNzTGlzdCBpcyBzbWFydCBlbm91Z2ggbm90IHRvIGNoYW5nZSB0aGUgY2xhc3NOYW1lIHByb3BlcnR5IGlmIHRoZVxuICAgICAgLy8gZWxlbWVudCBhbHJlYWR5IGhhcyB0aGUgY2xhc3Mgd2hpY2ggaXMgYmVpbmcgYWRkZWQuXG4gICAgICBpbWcucGFyZW50Tm9kZS5jbGFzc0xpc3QuYWRkKF90aGlzMi5DbGFzc05hbWUuTE9BREVEKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBiYWNrZ3JvdW5kIGltYWdlIHByb3BlcnR5IHdpdGggdGhlIGN1cnJlbnQgc291cmNlIG9mIGEgcmVzcG9uc2l2ZSBpbWFnZS5cbiAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fSBpbWcgSW1hZ2UgZWxlbWVudC5cbiAgICovXG5cblxuICBSZXNwb25zaXZlSW1hZ2VzLnByb3RvdHlwZS5fdXBkYXRlQmFja2dyb3VuZEltYWdlID0gZnVuY3Rpb24gX3VwZGF0ZUJhY2tncm91bmRJbWFnZShpbWcpIHtcbiAgICBpbWcucGFyZW50Tm9kZS5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSAndXJsKFwiJyArIChpbWcuY3VycmVudFNyYyB8fCBpbWcuc3JjKSArICdcIiknO1xuICB9O1xuXG4gIC8qKlxuICAgKiBOb3RpZnkgdGhlIFZpZXdwb3J0IHRvIHVwZGF0ZSBpdHMgdmFsdWUuIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB3aGVuIGEgbmV3XG4gICAqIGltYWdlIGxvYWRzLiBJdCBzaG91bGQgYWxzbyBiZSBjYWxsZWQgbWFudWFsbHkgaWYgb2Zmc2V0cyBvbiB0aGUgcGFnZSBjaGFuZ2UuXG4gICAqL1xuXG5cbiAgUmVzcG9uc2l2ZUltYWdlcy5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIF91cGRhdGUoKSB7XG4gICAgVmlld3BvcnQudXBkYXRlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZXZlbnQgbGlzdGVuZXJzIGJvdW5kIHRvIHRoZSBpbWFnZS5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBpbWcgSW1hZ2UgZWxlbWVudC5cbiAgICovXG5cblxuICBSZXNwb25zaXZlSW1hZ2VzLnByb3RvdHlwZS5fcmVtb3ZlSW1hZ2VIYW5kbGVycyA9IGZ1bmN0aW9uIF9yZW1vdmVJbWFnZUhhbmRsZXJzKGltZykge1xuICAgIGlmIChpbWcpIHtcbiAgICAgIGltZy5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy5faW1hZ2VMb2FkSGFuZGxlciwgZmFsc2UpO1xuICAgICAgaW1nLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5faW1hZ2VMb2FkSGFuZGxlciwgZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2xlYW4gdXAgYWxsIHJlZmVyZW5jZXMgYW5kIGxpc3RlbmVycyBmb3IgY3VycmVudCBpbWFnZXMuXG4gICAqL1xuXG5cbiAgUmVzcG9uc2l2ZUltYWdlcy5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIC8vIFJlbW92ZSBsb2FkIGxpc3RlbmVyIGZvciBlYWNoIGltYWdlIGFuZCBzdG9wIHRoZSBWaWV3cG9ydCBjb21wb25lbnRcbiAgICAvLyBmcm9tIHdhdGNoaW5nIGl0LlxuICAgIHRoaXMuaW1hZ2VzLmZvckVhY2goZnVuY3Rpb24gKGltYWdlKSB7XG4gICAgICB2YXIgaW1nID0gaW1hZ2UuZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdpbWcnKTtcbiAgICAgIF90aGlzMy5fcmVtb3ZlSW1hZ2VIYW5kbGVycyhpbWcpO1xuICAgICAgVmlld3BvcnQucmVtb3ZlKGltYWdlLmlkKTtcbiAgICB9KTtcblxuICAgIHRoaXMuaW1hZ2VzLmxlbmd0aCA9IDA7XG5cbiAgICAvLyBSZW1vdmUgYWxsIGBsb2FkYCBldmVudHMgZnJvbSBiYWNrZ3JvdW5kIGltYWdlcy5cbiAgICB2YXIgc2VsZWN0b3IgPSAnLicgKyB0aGlzLkNsYXNzTmFtZS5JTUFHRSArICdbZGF0YS10eXBlPVwiYmFja2dyb3VuZFwiXSBpbWcnO1xuICAgIEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpLmZvckVhY2goZnVuY3Rpb24gKGltZykge1xuICAgICAgX3RoaXMzLl9yZW1vdmVJbWFnZUhhbmRsZXJzKGltZyk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB3YXRjaGVkIGltYWdlcyBmcm9tIHRoaXMgY29tcG9uZW50LlxuICAgKiBAcGFyYW0ge0VsZW1lbnR8QXJyYXkuPEVsZW1lbnQ+fSBwbGFjZWhvbGRlcnMgQW4gZWxlbWVudCBvciBhcnJheSBvZiBlbGVtZW50cy5cbiAgICogICAgIFRoZSBlbGVtZW50IHNob3VsZCBiZSB0aGUgcGFyZW50IGVsZW1lbnQgb2YgdGhlIDxpbWc+LlxuICAgKi9cblxuXG4gIFJlc3BvbnNpdmVJbWFnZXMucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShwbGFjZWhvbGRlcnMpIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgIGFycmF5aWZ5KHBsYWNlaG9sZGVycykuZm9yRWFjaChmdW5jdGlvbiAocGxhY2Vob2xkZXIpIHtcbiAgICAgIF90aGlzNC5fcmVtb3ZlSW1hZ2VFbnRyeShwbGFjZWhvbGRlcik7XG4gICAgICBfdGhpczQuX3JlbW92ZUltYWdlSGFuZGxlcnMocGxhY2Vob2xkZXIucXVlcnlTZWxlY3RvcignaW1nJykpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgbW9yZSBpbWFnZXMgZm9yIHRoZSBSZXNwb25zaXZlSW1hZ2VzIGNvbXBvbmVudCB0byB3YXRjaC5cbiAgICogQHBhcmFtIHtFbGVtZW50fEFycmF5LjxFbGVtZW50Pn0gcGljdHVyZXMgQW4gZWxlbWVudCBvciBhcnJheSBvZiBlbGVtZW50cy5cbiAgICogICAgIFRoZSBlbGVtZW50IHNob3VsZCBiZSB0aGUgcGFyZW50IGVsZW1lbnQgb2YgdGhlIDxpbWc+LlxuICAgKi9cblxuXG4gIFJlc3BvbnNpdmVJbWFnZXMucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChwaWN0dXJlcykge1xuICAgIHZhciBwaWNzID0gYXJyYXlpZnkocGljdHVyZXMpLmZpbHRlcih0aGlzLl9pc1VubG9hZGVkUmVzcG9uc2l2ZUltYWdlLCB0aGlzKS5maWx0ZXIodGhpcy5pc1VudHJhY2tlZEltYWdlLCB0aGlzKTtcblxuICAgIGlmIChwaWNzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2FkZChwaWNzKTtcbiAgfTtcblxuICAvKipcbiAgICogRm9yY2UgdGhlIGxvYWQgb2YgYW4gZWxlbWVudCBvciBncm91cCBvZiBlbGVtZW50cyBpbnN0ZWFkIG9mIHdhaXRpbmcgZm9yIGl0XG4gICAqIHRvIGNvbWUgaW50byB0aGUgdmlld3BvcnQuXG4gICAqIEBwYXJhbSB7RWxlbWVudHxBcnJheS48RWxlbWVudD59IHBpY3R1cmVzIEFuIGVsZW1lbnQgb3IgYXJyYXkgb2YgZWxlbWVudHMuXG4gICAqICAgICBUaGUgZWxlbWVudCBzaG91bGQgYmUgdGhlIHBhcmVudCBlbGVtZW50IG9mIHRoZSA8aW1nPi5cbiAgICovXG5cblxuICBSZXNwb25zaXZlSW1hZ2VzLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gbG9hZChwaWN0dXJlcykge1xuICAgIGFycmF5aWZ5KHBpY3R1cmVzKS5maWx0ZXIodGhpcy5faXNVbmxvYWRlZFJlc3BvbnNpdmVJbWFnZSwgdGhpcykuZm9yRWFjaCh0aGlzLl9sb2FkSW1hZ2UsIHRoaXMpO1xuICB9O1xuXG4gIHJldHVybiBSZXNwb25zaXZlSW1hZ2VzO1xufSgpO1xuXG5SZXNwb25zaXZlSW1hZ2VzLkRFQk9VTkNFX1RJTUUgPSAzMDA7XG5cbi8vIENyZWF0ZSBhIHNpbmdsZSBpbnN0YW5jZSBhbmQgcmV0dXJuIHRoYXQuXG52YXIgcmVzcG9uc2l2ZUltYWdlcyA9IG5ldyBSZXNwb25zaXZlSW1hZ2VzKCk7XG5cbmV4cG9ydCBkZWZhdWx0IHJlc3BvbnNpdmVJbWFnZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vZG8tcmVzcG9uc2l2ZS1pbWFnZXMuZXNtLmpzLm1hcFxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@odopod/odo-responsive-images/dist/odo-responsive-images.esm.js\n");

/***/ }),

/***/ "./node_modules/@odopod/odo-viewport/dist/odo-viewport.esm.js":
/*!********************************************************************!*\
  !*** ./node_modules/@odopod/odo-viewport/dist/odo-viewport.esm.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _odopod_odo_window_events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @odopod/odo-window-events */ \"./node_modules/@odopod/odo-window-events/dist/odo-window-events.esm.js\");\n\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar ViewportItem = function () {\n  /**\n   * A viewport item represents an element being watched by the Viewport component.\n   * @param {Object} options Viewport item options.\n   * @param {Viewport} parent A reference to the viewport.\n   * @constructor\n   */\n  function ViewportItem(options, parent) {\n    classCallCheck(this, ViewportItem);\n\n    this.parent = parent;\n    this.id = Math.random().toString(36).substring(7);\n    this.triggered = false;\n    this.threshold = 200;\n    this.isThresholdPercentage = false;\n\n    // Override defaults with options.\n    Object.assign(this, options);\n\n    // The whole point is to have a callback function. Don't do anything if it's not given.\n    if (typeof this.enter !== 'function') {\n      throw new TypeError('Viewport.add :: No `enter` function provided in Viewport options.');\n    }\n\n    this.parseThreshold();\n\n    this.hasExitCallback = typeof this.exit === 'function';\n\n    // Cache element's offsets and dimensions.\n    this.update();\n  }\n\n  // Use getter for `this.offset` so that the tests don't have to assign\n  // a threshold and an offset.\n\n\n  /**\n   * Update offset and size values.\n   */\n  ViewportItem.prototype.update = function update() {\n    var box = this.element.getBoundingClientRect();\n    this.height = this.element.offsetHeight;\n    this.width = this.element.offsetWidth;\n    this.top = box.top + window.pageYOffset;\n    this.left = box.left + window.pageXOffset;\n    this.right = this.width + this.left;\n    this.bottom = this.height + this.top;\n  };\n\n  /**\n   * Determine the threshold setting.\n   */\n\n\n  ViewportItem.prototype.parseThreshold = function parseThreshold() {\n    var value = this.threshold;\n    this.threshold = parseFloat(value);\n\n    // Threshold can be a percentage. Parse it.\n    if (typeof value === 'string' && value.indexOf('%') > -1) {\n      this.isThresholdPercentage = true;\n      this.threshold = this.threshold / 100;\n    } else if (this.threshold < 1 && this.threshold > 0) {\n      this.isThresholdPercentage = true;\n    }\n  };\n\n  /**\n   * Nullify references so they're garbage collected.\n   */\n\n\n  ViewportItem.prototype.dispose = function dispose() {\n    this.element = null;\n    this.enter = null;\n    this.exit = null;\n    this.parent = null;\n  };\n\n  createClass(ViewportItem, [{\n    key: 'offset',\n    get: function get$$1() {\n      return this.isThresholdPercentage ? this.threshold * this.parent.viewportHeight : this.threshold;\n    }\n  }]);\n  return ViewportItem;\n}();\n\nvar instance = null;\n\nfunction inRange(value, min, max) {\n  return min <= value && value <= max;\n}\n\nvar Viewport = function () {\n  /**\n   * Viewport singleton.\n   * @constructor\n   */\n  function Viewport() {\n    classCallCheck(this, Viewport);\n\n    this.addId = null;\n    this.hasActiveHandlers = false;\n    this.items = new Map();\n\n    // Assume there is no horizontal scrollbar. documentElement.clientHeight\n    // is incorrect on iOS 8 because it includes toolbars.\n    this.viewportHeight = window.innerHeight;\n    this.viewportWidth = document.documentElement.clientWidth;\n    this.viewportTop = 0;\n\n    // What's nice here is that rAF won't execute until the user is on this tab,\n    // so if they open the page in a new tab which they aren't looking at,\n    // this will execute when they come back to that tab.\n    requestAnimationFrame(this.handleScroll.bind(this));\n  }\n\n  /**\n   * Listen for scroll and resize.\n   */\n  Viewport.prototype.bindEvents = function bindEvents() {\n    // Listen for global debounced resize.\n    this.resizeId = _odopod_odo_window_events__WEBPACK_IMPORTED_MODULE_0__[\"default\"].onResize(this.update.bind(this));\n\n    // Throttle scrolling because it doesn't need to be super accurate.\n    this.scrollId = _odopod_odo_window_events__WEBPACK_IMPORTED_MODULE_0__[\"default\"].onFastScroll(this.handleScroll.bind(this));\n\n    this.hasActiveHandlers = true;\n  };\n\n  /**\n   * Remove event listeners when there are no longer any viewport items to watch.\n   */\n\n\n  Viewport.prototype.unbindEvents = function unbindEvents() {\n    if (this.items.size === 0) {\n      _odopod_odo_window_events__WEBPACK_IMPORTED_MODULE_0__[\"default\"].remove(this.resizeId);\n      _odopod_odo_window_events__WEBPACK_IMPORTED_MODULE_0__[\"default\"].remove(this.scrollId);\n\n      this.hasActiveHandlers = false;\n    }\n  };\n\n  /**\n   * Watch another item.\n   * @param {Object} options Viewport item options.\n   * @return {string} The new item's id which is used to remove it.\n   */\n\n\n  Viewport.prototype.add = function add(options) {\n    var item = new ViewportItem(options, this);\n    this.items.set(item.id, item);\n\n    // Event handlers are removed if a callback is triggered and the\n    // watch list is empty. Because modules are instantiated asynchronously,\n    // another module could potentially add itself to the watch list when the events\n    // have been unbound.\n    // Check here if events have been unbound and bind them again if they have\n    if (!this.hasActiveHandlers) {\n      this.bindEvents();\n    }\n\n    return item.id;\n  };\n\n  /**\n   * Update each item's width/height/top/left values and the viewport size.\n   */\n\n\n  Viewport.prototype.saveDimensions = function saveDimensions() {\n    this.items.forEach(function (item) {\n      item.update();\n    });\n\n    // Window width and height without scrollbars.\n    this.viewportHeight = window.innerHeight;\n    this.viewportWidth = document.documentElement.clientWidth;\n\n    return this;\n  };\n\n  /**\n   * Throttled scroll event. Update the viewport top position and process items.\n   */\n\n\n  Viewport.prototype.handleScroll = function handleScroll() {\n    return this.setScrollTop().process();\n  };\n\n  /**\n   * Update offsets and process items.\n   */\n\n\n  Viewport.prototype.update = function update() {\n    return this.saveDimensions().process();\n  };\n\n  /**\n   * Notify the viewport item it has entered view.\n   * @param {ViewportItem} item item.\n   */\n\n\n  Viewport.prototype.triggerEnter = function triggerEnter(item) {\n    item.enter.call(item.element, item);\n\n    if (item.hasExitCallback) {\n      item.triggered = true;\n\n      // If the exit property is not a function, the module no longer needs to\n      // watch it, so remove from list of viewport items.\n    } else {\n      Viewport.remove(item.id);\n\n      // If there are no more, unbind from scroll and resize events\n      this.unbindEvents();\n    }\n  };\n\n  /**\n   * Notify the viewport item it has exited view.\n   * @param {ViewportItem} item item.\n   */\n\n\n  Viewport.prototype.triggerExit = function triggerExit(item) {\n    item.exit.call(item.element, item);\n    item.triggered = false;\n  };\n\n  /**\n   * Save the new scroll top\n   */\n\n\n  Viewport.prototype.setScrollTop = function setScrollTop() {\n    this.viewportTop = window.pageYOffset;\n    return this;\n  };\n\n  /**\n   * Process each viewport item to see if it is now in view (or out of view).\n   */\n\n\n  Viewport.prototype.process = function process() {\n    this.items.forEach(this._processItem, this);\n    this.addId = null;\n\n    return this;\n  };\n\n  /**\n   * Determine if enter or exit callbacks should be executed for a viewport item.\n   * @param {ViewportItem} item Item to test.\n   */\n\n\n  Viewport.prototype._processItem = function _processItem(item) {\n    var isVisible = this.isVisible(item);\n    var isInView = isVisible && this.isInViewport(item);\n\n    // Whether the item is not in the viewport and doesn't have an exit\n    // callback. In this case, the enter callback should be executed\n    // because the browser has already scrolled past the trigger point.\n    var isTopPastView = isVisible && !item.hasExitCallback && this.isTopPastViewport(item);\n\n    // If the enter callback hasn't been triggered and it's in the viewport,\n    // trigger the enter callback.\n    if (!item.triggered && (isInView || isTopPastView)) {\n      this.triggerEnter(item);\n      return;\n    }\n\n    // This viewport has already come into view once (viewport item has been\n    // triggered) and now the bottom is out of view.\n    if (!isInView && item.triggered && item.hasExitCallback && !this.isBottomInViewport(item)) {\n      this.triggerExit(item);\n    }\n  };\n\n  /**\n   * Whether a viewport item is considered to be in view.\n   * @param {ViewportItem} item Item to test.\n   * @return {boolean}\n   */\n\n\n  Viewport.prototype.isInViewport = function isInViewport(item) {\n    var isTopInView = this.isTopInViewport(item);\n\n    // If the item has not come into view, ignore checking to see if the bottom\n    // is in view because this can conflict with the top being in view when the\n    // offset is greater than the height of the watched element.\n    var isBottomInView = void 0;\n    if (item.offset >= 0) {\n      if (item.triggered) {\n        isBottomInView = this.isBottomInViewport(item);\n      } else {\n        isBottomInView = false;\n      }\n    } else {\n      // If the offset is negative, assume that it shouldn't wait until the top\n      // is in view before checking the bottom again.\n      isBottomInView = this.isBottomInViewport(item);\n    }\n\n    var isViewPastBottom = this.isViewportPastBottom(item);\n    var spanningViewport = !isTopInView && !isBottomInView && this.doesSpanViewport(item);\n\n    var isSideInView = this.isSideInViewport(item);\n\n    return (isTopInView || isBottomInView || spanningViewport) && !isViewPastBottom && isSideInView;\n  };\n\n  /**\n   * Determine whether a side of the viewport item is within the viewport. A side\n   * is also considered to be in view if the viewport item is wider than the viewport\n   * and its left and right sides are out of view.\n   * @param {ViewportItem} item Item to test.\n   * @return {boolean}\n   */\n\n\n  Viewport.prototype.isSideInViewport = function isSideInViewport(item) {\n    var isLeftInView = inRange(item.left, 0, this.viewportWidth);\n    var isRightInView = inRange(item.right, 0, this.viewportWidth);\n\n    // To span the viewport, it must:\n    // * Wider than the viewport.\n    // * Left side not in view.\n    // * left side less than zero.\n    // * Right side not in view.\n    // * Right side greater than window width.\n    var spansViewport = item.width >= this.viewportWidth && !isLeftInView && !isRightInView && item.left < 0 && item.right > this.viewportWidth;\n\n    return isLeftInView || isRightInView || spansViewport;\n  };\n\n  /**\n   * If an element is hidden (has a parent with display:none), getBoundingClientRect\n   * will return all zeros\n   * @param {ViewportItem} item item Item to test.\n   * @return {boolean}\n   */\n\n\n  Viewport.prototype.isVisible = function isVisible(item) {\n    return !(item.width === 0 && item.height === 0);\n  };\n\n  Viewport.prototype.isTopPastViewport = function isTopPastViewport(item) {\n    return this.viewportTop > item.top;\n  };\n\n  Viewport.prototype.isViewportPastBottom = function isViewportPastBottom(item) {\n    return this.viewportTop >= item.bottom;\n  };\n\n  Viewport.prototype.isTopInViewport = function isTopInViewport(item) {\n    var elementTop = item.top + item.offset;\n    return inRange(elementTop, this.viewportTop, this.viewportBottom);\n  };\n\n  Viewport.prototype.isBottomInViewport = function isBottomInViewport(item) {\n    // Account for threshold only from the element top. Otherwise the element\n    // won't be \"out of view\" from the bottom until after the extra threshold.\n    return inRange(item.bottom, this.viewportTop, this.viewportBottom);\n  };\n\n  Viewport.prototype.doesSpanViewport = function doesSpanViewport(item) {\n    var elementTop = item.top + item.offset;\n    var elementBottom = item.bottom;\n    return item.height >= this.viewportHeight && elementTop < this.viewportTop && elementBottom > this.viewportBottom;\n  };\n\n  /**\n   * Remove all viewport items and unbind events.\n   */\n\n\n  Viewport.flush = function flush() {\n    var instance = Viewport.getInstance();\n    if (instance.addId) {\n      cancelAnimationFrame(instance.addId);\n      instance.addId = null;\n    }\n\n    instance.items.forEach(function (item, id) {\n      Viewport.remove(id);\n    });\n\n    instance.items.clear();\n    instance.unbindEvents();\n  };\n\n  /**\n   * Add a viewport item to watch.\n   * @param {object|object[]} options Optional options object or array of\n   *     options objects to initialize.\n   * @param {Element} options.element Element to watch.\n   * @param {number|string} [options.threshold] Optional - either a number representing\n   *     the threshold offset (like 100), a float between zero and one representing\n   *     a percentage, or a string like '50%' for a percentage.\n   * @param {function} options.enter Callback when the element enters view.\n   * @param {function} [options.exit] Optional callback when the element exits view.\n   * @return {string|string[]} Viewport item id or array of item ids if\n   *     `options` is an array.\n   */\n\n\n  Viewport.add = function add(options) {\n    var instance = Viewport.getInstance();\n\n    var id = void 0;\n    if (Array.isArray(options)) {\n      id = options.map(function (option) {\n        return instance.add(option);\n      });\n    } else {\n      id = instance.add(options);\n    }\n\n    // Avoid adding multiple rAFs when it should really only be processed once.\n    if (instance.addId) {\n      cancelAnimationFrame(instance.addId);\n    }\n\n    instance.addId = requestAnimationFrame(instance.process.bind(instance));\n\n    return id;\n  };\n\n  /**\n   * Remove a viewport item from the list of viewport items to watch.\n   * @param {string} id The id returned from adding the viewport item.\n   */\n\n\n  Viewport.remove = function remove(id) {\n    var instance = Viewport.getInstance();\n    if (instance.items.has(id)) {\n      instance.items.get(id).dispose();\n      instance.items.delete(id);\n    }\n  };\n\n  /**\n   * Tell the viewport instance that offsets need to be updated.\n   */\n\n\n  Viewport.update = function update() {\n    Viewport.getInstance().update();\n  };\n\n  /**\n   * Retrieve the viewport instance.\n   * @return {Viewport}\n   */\n\n\n  Viewport.getInstance = function getInstance() {\n    if (!instance) {\n      instance = new Viewport();\n    }\n\n    return instance;\n  };\n\n  createClass(Viewport, [{\n    key: 'viewportBottom',\n    get: function get$$1() {\n      return this.viewportTop + this.viewportHeight;\n    }\n  }]);\n  return Viewport;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Viewport);\n//# sourceMappingURL=odo-viewport.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG9kb3BvZC9vZG8tdmlld3BvcnQvZGlzdC9vZG8tdmlld3BvcnQuZXNtLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BvZG9wb2Qvb2RvLXZpZXdwb3J0L2Rpc3Qvb2RvLXZpZXdwb3J0LmVzbS5qcz84YWVhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBPZG9XaW5kb3dFdmVudHMgZnJvbSAnQG9kb3BvZC9vZG8td2luZG93LWV2ZW50cyc7XG5cbnZhciBjbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG52YXIgY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7XG5cbnZhciBWaWV3cG9ydEl0ZW0gPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBBIHZpZXdwb3J0IGl0ZW0gcmVwcmVzZW50cyBhbiBlbGVtZW50IGJlaW5nIHdhdGNoZWQgYnkgdGhlIFZpZXdwb3J0IGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVmlld3BvcnQgaXRlbSBvcHRpb25zLlxuICAgKiBAcGFyYW0ge1ZpZXdwb3J0fSBwYXJlbnQgQSByZWZlcmVuY2UgdG8gdGhlIHZpZXdwb3J0LlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIFZpZXdwb3J0SXRlbShvcHRpb25zLCBwYXJlbnQpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBWaWV3cG9ydEl0ZW0pO1xuXG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5pZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KTtcbiAgICB0aGlzLnRyaWdnZXJlZCA9IGZhbHNlO1xuICAgIHRoaXMudGhyZXNob2xkID0gMjAwO1xuICAgIHRoaXMuaXNUaHJlc2hvbGRQZXJjZW50YWdlID0gZmFsc2U7XG5cbiAgICAvLyBPdmVycmlkZSBkZWZhdWx0cyB3aXRoIG9wdGlvbnMuXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvcHRpb25zKTtcblxuICAgIC8vIFRoZSB3aG9sZSBwb2ludCBpcyB0byBoYXZlIGEgY2FsbGJhY2sgZnVuY3Rpb24uIERvbid0IGRvIGFueXRoaW5nIGlmIGl0J3Mgbm90IGdpdmVuLlxuICAgIGlmICh0eXBlb2YgdGhpcy5lbnRlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVmlld3BvcnQuYWRkIDo6IE5vIGBlbnRlcmAgZnVuY3Rpb24gcHJvdmlkZWQgaW4gVmlld3BvcnQgb3B0aW9ucy4nKTtcbiAgICB9XG5cbiAgICB0aGlzLnBhcnNlVGhyZXNob2xkKCk7XG5cbiAgICB0aGlzLmhhc0V4aXRDYWxsYmFjayA9IHR5cGVvZiB0aGlzLmV4aXQgPT09ICdmdW5jdGlvbic7XG5cbiAgICAvLyBDYWNoZSBlbGVtZW50J3Mgb2Zmc2V0cyBhbmQgZGltZW5zaW9ucy5cbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG5cbiAgLy8gVXNlIGdldHRlciBmb3IgYHRoaXMub2Zmc2V0YCBzbyB0aGF0IHRoZSB0ZXN0cyBkb24ndCBoYXZlIHRvIGFzc2lnblxuICAvLyBhIHRocmVzaG9sZCBhbmQgYW4gb2Zmc2V0LlxuXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBvZmZzZXQgYW5kIHNpemUgdmFsdWVzLlxuICAgKi9cbiAgVmlld3BvcnRJdGVtLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdmFyIGJveCA9IHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB0aGlzLmhlaWdodCA9IHRoaXMuZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgdGhpcy53aWR0aCA9IHRoaXMuZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICB0aGlzLnRvcCA9IGJveC50b3AgKyB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgdGhpcy5sZWZ0ID0gYm94LmxlZnQgKyB3aW5kb3cucGFnZVhPZmZzZXQ7XG4gICAgdGhpcy5yaWdodCA9IHRoaXMud2lkdGggKyB0aGlzLmxlZnQ7XG4gICAgdGhpcy5ib3R0b20gPSB0aGlzLmhlaWdodCArIHRoaXMudG9wO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgdGhlIHRocmVzaG9sZCBzZXR0aW5nLlxuICAgKi9cblxuXG4gIFZpZXdwb3J0SXRlbS5wcm90b3R5cGUucGFyc2VUaHJlc2hvbGQgPSBmdW5jdGlvbiBwYXJzZVRocmVzaG9sZCgpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnRocmVzaG9sZDtcbiAgICB0aGlzLnRocmVzaG9sZCA9IHBhcnNlRmxvYXQodmFsdWUpO1xuXG4gICAgLy8gVGhyZXNob2xkIGNhbiBiZSBhIHBlcmNlbnRhZ2UuIFBhcnNlIGl0LlxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmluZGV4T2YoJyUnKSA+IC0xKSB7XG4gICAgICB0aGlzLmlzVGhyZXNob2xkUGVyY2VudGFnZSA9IHRydWU7XG4gICAgICB0aGlzLnRocmVzaG9sZCA9IHRoaXMudGhyZXNob2xkIC8gMTAwO1xuICAgIH0gZWxzZSBpZiAodGhpcy50aHJlc2hvbGQgPCAxICYmIHRoaXMudGhyZXNob2xkID4gMCkge1xuICAgICAgdGhpcy5pc1RocmVzaG9sZFBlcmNlbnRhZ2UgPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogTnVsbGlmeSByZWZlcmVuY2VzIHNvIHRoZXkncmUgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4gICAqL1xuXG5cbiAgVmlld3BvcnRJdGVtLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuZW50ZXIgPSBudWxsO1xuICAgIHRoaXMuZXhpdCA9IG51bGw7XG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICB9O1xuXG4gIGNyZWF0ZUNsYXNzKFZpZXdwb3J0SXRlbSwgW3tcbiAgICBrZXk6ICdvZmZzZXQnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNUaHJlc2hvbGRQZXJjZW50YWdlID8gdGhpcy50aHJlc2hvbGQgKiB0aGlzLnBhcmVudC52aWV3cG9ydEhlaWdodCA6IHRoaXMudGhyZXNob2xkO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVmlld3BvcnRJdGVtO1xufSgpO1xuXG52YXIgaW5zdGFuY2UgPSBudWxsO1xuXG5mdW5jdGlvbiBpblJhbmdlKHZhbHVlLCBtaW4sIG1heCkge1xuICByZXR1cm4gbWluIDw9IHZhbHVlICYmIHZhbHVlIDw9IG1heDtcbn1cblxudmFyIFZpZXdwb3J0ID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogVmlld3BvcnQgc2luZ2xldG9uLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIFZpZXdwb3J0KCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFZpZXdwb3J0KTtcblxuICAgIHRoaXMuYWRkSWQgPSBudWxsO1xuICAgIHRoaXMuaGFzQWN0aXZlSGFuZGxlcnMgPSBmYWxzZTtcbiAgICB0aGlzLml0ZW1zID0gbmV3IE1hcCgpO1xuXG4gICAgLy8gQXNzdW1lIHRoZXJlIGlzIG5vIGhvcml6b250YWwgc2Nyb2xsYmFyLiBkb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0XG4gICAgLy8gaXMgaW5jb3JyZWN0IG9uIGlPUyA4IGJlY2F1c2UgaXQgaW5jbHVkZXMgdG9vbGJhcnMuXG4gICAgdGhpcy52aWV3cG9ydEhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICB0aGlzLnZpZXdwb3J0V2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgdGhpcy52aWV3cG9ydFRvcCA9IDA7XG5cbiAgICAvLyBXaGF0J3MgbmljZSBoZXJlIGlzIHRoYXQgckFGIHdvbid0IGV4ZWN1dGUgdW50aWwgdGhlIHVzZXIgaXMgb24gdGhpcyB0YWIsXG4gICAgLy8gc28gaWYgdGhleSBvcGVuIHRoZSBwYWdlIGluIGEgbmV3IHRhYiB3aGljaCB0aGV5IGFyZW4ndCBsb29raW5nIGF0LFxuICAgIC8vIHRoaXMgd2lsbCBleGVjdXRlIHdoZW4gdGhleSBjb21lIGJhY2sgdG8gdGhhdCB0YWIuXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuaGFuZGxlU2Nyb2xsLmJpbmQodGhpcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3RlbiBmb3Igc2Nyb2xsIGFuZCByZXNpemUuXG4gICAqL1xuICBWaWV3cG9ydC5wcm90b3R5cGUuYmluZEV2ZW50cyA9IGZ1bmN0aW9uIGJpbmRFdmVudHMoKSB7XG4gICAgLy8gTGlzdGVuIGZvciBnbG9iYWwgZGVib3VuY2VkIHJlc2l6ZS5cbiAgICB0aGlzLnJlc2l6ZUlkID0gT2RvV2luZG93RXZlbnRzLm9uUmVzaXplKHRoaXMudXBkYXRlLmJpbmQodGhpcykpO1xuXG4gICAgLy8gVGhyb3R0bGUgc2Nyb2xsaW5nIGJlY2F1c2UgaXQgZG9lc24ndCBuZWVkIHRvIGJlIHN1cGVyIGFjY3VyYXRlLlxuICAgIHRoaXMuc2Nyb2xsSWQgPSBPZG9XaW5kb3dFdmVudHMub25GYXN0U2Nyb2xsKHRoaXMuaGFuZGxlU2Nyb2xsLmJpbmQodGhpcykpO1xuXG4gICAgdGhpcy5oYXNBY3RpdmVIYW5kbGVycyA9IHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBldmVudCBsaXN0ZW5lcnMgd2hlbiB0aGVyZSBhcmUgbm8gbG9uZ2VyIGFueSB2aWV3cG9ydCBpdGVtcyB0byB3YXRjaC5cbiAgICovXG5cblxuICBWaWV3cG9ydC5wcm90b3R5cGUudW5iaW5kRXZlbnRzID0gZnVuY3Rpb24gdW5iaW5kRXZlbnRzKCkge1xuICAgIGlmICh0aGlzLml0ZW1zLnNpemUgPT09IDApIHtcbiAgICAgIE9kb1dpbmRvd0V2ZW50cy5yZW1vdmUodGhpcy5yZXNpemVJZCk7XG4gICAgICBPZG9XaW5kb3dFdmVudHMucmVtb3ZlKHRoaXMuc2Nyb2xsSWQpO1xuXG4gICAgICB0aGlzLmhhc0FjdGl2ZUhhbmRsZXJzID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBXYXRjaCBhbm90aGVyIGl0ZW0uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFZpZXdwb3J0IGl0ZW0gb3B0aW9ucy5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgbmV3IGl0ZW0ncyBpZCB3aGljaCBpcyB1c2VkIHRvIHJlbW92ZSBpdC5cbiAgICovXG5cblxuICBWaWV3cG9ydC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKG9wdGlvbnMpIHtcbiAgICB2YXIgaXRlbSA9IG5ldyBWaWV3cG9ydEl0ZW0ob3B0aW9ucywgdGhpcyk7XG4gICAgdGhpcy5pdGVtcy5zZXQoaXRlbS5pZCwgaXRlbSk7XG5cbiAgICAvLyBFdmVudCBoYW5kbGVycyBhcmUgcmVtb3ZlZCBpZiBhIGNhbGxiYWNrIGlzIHRyaWdnZXJlZCBhbmQgdGhlXG4gICAgLy8gd2F0Y2ggbGlzdCBpcyBlbXB0eS4gQmVjYXVzZSBtb2R1bGVzIGFyZSBpbnN0YW50aWF0ZWQgYXN5bmNocm9ub3VzbHksXG4gICAgLy8gYW5vdGhlciBtb2R1bGUgY291bGQgcG90ZW50aWFsbHkgYWRkIGl0c2VsZiB0byB0aGUgd2F0Y2ggbGlzdCB3aGVuIHRoZSBldmVudHNcbiAgICAvLyBoYXZlIGJlZW4gdW5ib3VuZC5cbiAgICAvLyBDaGVjayBoZXJlIGlmIGV2ZW50cyBoYXZlIGJlZW4gdW5ib3VuZCBhbmQgYmluZCB0aGVtIGFnYWluIGlmIHRoZXkgaGF2ZVxuICAgIGlmICghdGhpcy5oYXNBY3RpdmVIYW5kbGVycykge1xuICAgICAgdGhpcy5iaW5kRXZlbnRzKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW0uaWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBlYWNoIGl0ZW0ncyB3aWR0aC9oZWlnaHQvdG9wL2xlZnQgdmFsdWVzIGFuZCB0aGUgdmlld3BvcnQgc2l6ZS5cbiAgICovXG5cblxuICBWaWV3cG9ydC5wcm90b3R5cGUuc2F2ZURpbWVuc2lvbnMgPSBmdW5jdGlvbiBzYXZlRGltZW5zaW9ucygpIHtcbiAgICB0aGlzLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIGl0ZW0udXBkYXRlKCk7XG4gICAgfSk7XG5cbiAgICAvLyBXaW5kb3cgd2lkdGggYW5kIGhlaWdodCB3aXRob3V0IHNjcm9sbGJhcnMuXG4gICAgdGhpcy52aWV3cG9ydEhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICB0aGlzLnZpZXdwb3J0V2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogVGhyb3R0bGVkIHNjcm9sbCBldmVudC4gVXBkYXRlIHRoZSB2aWV3cG9ydCB0b3AgcG9zaXRpb24gYW5kIHByb2Nlc3MgaXRlbXMuXG4gICAqL1xuXG5cbiAgVmlld3BvcnQucHJvdG90eXBlLmhhbmRsZVNjcm9sbCA9IGZ1bmN0aW9uIGhhbmRsZVNjcm9sbCgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRTY3JvbGxUb3AoKS5wcm9jZXNzKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBvZmZzZXRzIGFuZCBwcm9jZXNzIGl0ZW1zLlxuICAgKi9cblxuXG4gIFZpZXdwb3J0LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2F2ZURpbWVuc2lvbnMoKS5wcm9jZXNzKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIE5vdGlmeSB0aGUgdmlld3BvcnQgaXRlbSBpdCBoYXMgZW50ZXJlZCB2aWV3LlxuICAgKiBAcGFyYW0ge1ZpZXdwb3J0SXRlbX0gaXRlbSBpdGVtLlxuICAgKi9cblxuXG4gIFZpZXdwb3J0LnByb3RvdHlwZS50cmlnZ2VyRW50ZXIgPSBmdW5jdGlvbiB0cmlnZ2VyRW50ZXIoaXRlbSkge1xuICAgIGl0ZW0uZW50ZXIuY2FsbChpdGVtLmVsZW1lbnQsIGl0ZW0pO1xuXG4gICAgaWYgKGl0ZW0uaGFzRXhpdENhbGxiYWNrKSB7XG4gICAgICBpdGVtLnRyaWdnZXJlZCA9IHRydWU7XG5cbiAgICAgIC8vIElmIHRoZSBleGl0IHByb3BlcnR5IGlzIG5vdCBhIGZ1bmN0aW9uLCB0aGUgbW9kdWxlIG5vIGxvbmdlciBuZWVkcyB0b1xuICAgICAgLy8gd2F0Y2ggaXQsIHNvIHJlbW92ZSBmcm9tIGxpc3Qgb2Ygdmlld3BvcnQgaXRlbXMuXG4gICAgfSBlbHNlIHtcbiAgICAgIFZpZXdwb3J0LnJlbW92ZShpdGVtLmlkKTtcblxuICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIG1vcmUsIHVuYmluZCBmcm9tIHNjcm9sbCBhbmQgcmVzaXplIGV2ZW50c1xuICAgICAgdGhpcy51bmJpbmRFdmVudHMoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIE5vdGlmeSB0aGUgdmlld3BvcnQgaXRlbSBpdCBoYXMgZXhpdGVkIHZpZXcuXG4gICAqIEBwYXJhbSB7Vmlld3BvcnRJdGVtfSBpdGVtIGl0ZW0uXG4gICAqL1xuXG5cbiAgVmlld3BvcnQucHJvdG90eXBlLnRyaWdnZXJFeGl0ID0gZnVuY3Rpb24gdHJpZ2dlckV4aXQoaXRlbSkge1xuICAgIGl0ZW0uZXhpdC5jYWxsKGl0ZW0uZWxlbWVudCwgaXRlbSk7XG4gICAgaXRlbS50cmlnZ2VyZWQgPSBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogU2F2ZSB0aGUgbmV3IHNjcm9sbCB0b3BcbiAgICovXG5cblxuICBWaWV3cG9ydC5wcm90b3R5cGUuc2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gc2V0U2Nyb2xsVG9wKCkge1xuICAgIHRoaXMudmlld3BvcnRUb3AgPSB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgZWFjaCB2aWV3cG9ydCBpdGVtIHRvIHNlZSBpZiBpdCBpcyBub3cgaW4gdmlldyAob3Igb3V0IG9mIHZpZXcpLlxuICAgKi9cblxuXG4gIFZpZXdwb3J0LnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gcHJvY2VzcygpIHtcbiAgICB0aGlzLml0ZW1zLmZvckVhY2godGhpcy5fcHJvY2Vzc0l0ZW0sIHRoaXMpO1xuICAgIHRoaXMuYWRkSWQgPSBudWxsO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIERldGVybWluZSBpZiBlbnRlciBvciBleGl0IGNhbGxiYWNrcyBzaG91bGQgYmUgZXhlY3V0ZWQgZm9yIGEgdmlld3BvcnQgaXRlbS5cbiAgICogQHBhcmFtIHtWaWV3cG9ydEl0ZW19IGl0ZW0gSXRlbSB0byB0ZXN0LlxuICAgKi9cblxuXG4gIFZpZXdwb3J0LnByb3RvdHlwZS5fcHJvY2Vzc0l0ZW0gPSBmdW5jdGlvbiBfcHJvY2Vzc0l0ZW0oaXRlbSkge1xuICAgIHZhciBpc1Zpc2libGUgPSB0aGlzLmlzVmlzaWJsZShpdGVtKTtcbiAgICB2YXIgaXNJblZpZXcgPSBpc1Zpc2libGUgJiYgdGhpcy5pc0luVmlld3BvcnQoaXRlbSk7XG5cbiAgICAvLyBXaGV0aGVyIHRoZSBpdGVtIGlzIG5vdCBpbiB0aGUgdmlld3BvcnQgYW5kIGRvZXNuJ3QgaGF2ZSBhbiBleGl0XG4gICAgLy8gY2FsbGJhY2suIEluIHRoaXMgY2FzZSwgdGhlIGVudGVyIGNhbGxiYWNrIHNob3VsZCBiZSBleGVjdXRlZFxuICAgIC8vIGJlY2F1c2UgdGhlIGJyb3dzZXIgaGFzIGFscmVhZHkgc2Nyb2xsZWQgcGFzdCB0aGUgdHJpZ2dlciBwb2ludC5cbiAgICB2YXIgaXNUb3BQYXN0VmlldyA9IGlzVmlzaWJsZSAmJiAhaXRlbS5oYXNFeGl0Q2FsbGJhY2sgJiYgdGhpcy5pc1RvcFBhc3RWaWV3cG9ydChpdGVtKTtcblxuICAgIC8vIElmIHRoZSBlbnRlciBjYWxsYmFjayBoYXNuJ3QgYmVlbiB0cmlnZ2VyZWQgYW5kIGl0J3MgaW4gdGhlIHZpZXdwb3J0LFxuICAgIC8vIHRyaWdnZXIgdGhlIGVudGVyIGNhbGxiYWNrLlxuICAgIGlmICghaXRlbS50cmlnZ2VyZWQgJiYgKGlzSW5WaWV3IHx8IGlzVG9wUGFzdFZpZXcpKSB7XG4gICAgICB0aGlzLnRyaWdnZXJFbnRlcihpdGVtKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUaGlzIHZpZXdwb3J0IGhhcyBhbHJlYWR5IGNvbWUgaW50byB2aWV3IG9uY2UgKHZpZXdwb3J0IGl0ZW0gaGFzIGJlZW5cbiAgICAvLyB0cmlnZ2VyZWQpIGFuZCBub3cgdGhlIGJvdHRvbSBpcyBvdXQgb2Ygdmlldy5cbiAgICBpZiAoIWlzSW5WaWV3ICYmIGl0ZW0udHJpZ2dlcmVkICYmIGl0ZW0uaGFzRXhpdENhbGxiYWNrICYmICF0aGlzLmlzQm90dG9tSW5WaWV3cG9ydChpdGVtKSkge1xuICAgICAgdGhpcy50cmlnZ2VyRXhpdChpdGVtKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgYSB2aWV3cG9ydCBpdGVtIGlzIGNvbnNpZGVyZWQgdG8gYmUgaW4gdmlldy5cbiAgICogQHBhcmFtIHtWaWV3cG9ydEl0ZW19IGl0ZW0gSXRlbSB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cblxuXG4gIFZpZXdwb3J0LnByb3RvdHlwZS5pc0luVmlld3BvcnQgPSBmdW5jdGlvbiBpc0luVmlld3BvcnQoaXRlbSkge1xuICAgIHZhciBpc1RvcEluVmlldyA9IHRoaXMuaXNUb3BJblZpZXdwb3J0KGl0ZW0pO1xuXG4gICAgLy8gSWYgdGhlIGl0ZW0gaGFzIG5vdCBjb21lIGludG8gdmlldywgaWdub3JlIGNoZWNraW5nIHRvIHNlZSBpZiB0aGUgYm90dG9tXG4gICAgLy8gaXMgaW4gdmlldyBiZWNhdXNlIHRoaXMgY2FuIGNvbmZsaWN0IHdpdGggdGhlIHRvcCBiZWluZyBpbiB2aWV3IHdoZW4gdGhlXG4gICAgLy8gb2Zmc2V0IGlzIGdyZWF0ZXIgdGhhbiB0aGUgaGVpZ2h0IG9mIHRoZSB3YXRjaGVkIGVsZW1lbnQuXG4gICAgdmFyIGlzQm90dG9tSW5WaWV3ID0gdm9pZCAwO1xuICAgIGlmIChpdGVtLm9mZnNldCA+PSAwKSB7XG4gICAgICBpZiAoaXRlbS50cmlnZ2VyZWQpIHtcbiAgICAgICAgaXNCb3R0b21JblZpZXcgPSB0aGlzLmlzQm90dG9tSW5WaWV3cG9ydChpdGVtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzQm90dG9tSW5WaWV3ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZSBvZmZzZXQgaXMgbmVnYXRpdmUsIGFzc3VtZSB0aGF0IGl0IHNob3VsZG4ndCB3YWl0IHVudGlsIHRoZSB0b3BcbiAgICAgIC8vIGlzIGluIHZpZXcgYmVmb3JlIGNoZWNraW5nIHRoZSBib3R0b20gYWdhaW4uXG4gICAgICBpc0JvdHRvbUluVmlldyA9IHRoaXMuaXNCb3R0b21JblZpZXdwb3J0KGl0ZW0pO1xuICAgIH1cblxuICAgIHZhciBpc1ZpZXdQYXN0Qm90dG9tID0gdGhpcy5pc1ZpZXdwb3J0UGFzdEJvdHRvbShpdGVtKTtcbiAgICB2YXIgc3Bhbm5pbmdWaWV3cG9ydCA9ICFpc1RvcEluVmlldyAmJiAhaXNCb3R0b21JblZpZXcgJiYgdGhpcy5kb2VzU3BhblZpZXdwb3J0KGl0ZW0pO1xuXG4gICAgdmFyIGlzU2lkZUluVmlldyA9IHRoaXMuaXNTaWRlSW5WaWV3cG9ydChpdGVtKTtcblxuICAgIHJldHVybiAoaXNUb3BJblZpZXcgfHwgaXNCb3R0b21JblZpZXcgfHwgc3Bhbm5pbmdWaWV3cG9ydCkgJiYgIWlzVmlld1Bhc3RCb3R0b20gJiYgaXNTaWRlSW5WaWV3O1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciBhIHNpZGUgb2YgdGhlIHZpZXdwb3J0IGl0ZW0gaXMgd2l0aGluIHRoZSB2aWV3cG9ydC4gQSBzaWRlXG4gICAqIGlzIGFsc28gY29uc2lkZXJlZCB0byBiZSBpbiB2aWV3IGlmIHRoZSB2aWV3cG9ydCBpdGVtIGlzIHdpZGVyIHRoYW4gdGhlIHZpZXdwb3J0XG4gICAqIGFuZCBpdHMgbGVmdCBhbmQgcmlnaHQgc2lkZXMgYXJlIG91dCBvZiB2aWV3LlxuICAgKiBAcGFyYW0ge1ZpZXdwb3J0SXRlbX0gaXRlbSBJdGVtIHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuXG5cbiAgVmlld3BvcnQucHJvdG90eXBlLmlzU2lkZUluVmlld3BvcnQgPSBmdW5jdGlvbiBpc1NpZGVJblZpZXdwb3J0KGl0ZW0pIHtcbiAgICB2YXIgaXNMZWZ0SW5WaWV3ID0gaW5SYW5nZShpdGVtLmxlZnQsIDAsIHRoaXMudmlld3BvcnRXaWR0aCk7XG4gICAgdmFyIGlzUmlnaHRJblZpZXcgPSBpblJhbmdlKGl0ZW0ucmlnaHQsIDAsIHRoaXMudmlld3BvcnRXaWR0aCk7XG5cbiAgICAvLyBUbyBzcGFuIHRoZSB2aWV3cG9ydCwgaXQgbXVzdDpcbiAgICAvLyAqIFdpZGVyIHRoYW4gdGhlIHZpZXdwb3J0LlxuICAgIC8vICogTGVmdCBzaWRlIG5vdCBpbiB2aWV3LlxuICAgIC8vICogbGVmdCBzaWRlIGxlc3MgdGhhbiB6ZXJvLlxuICAgIC8vICogUmlnaHQgc2lkZSBub3QgaW4gdmlldy5cbiAgICAvLyAqIFJpZ2h0IHNpZGUgZ3JlYXRlciB0aGFuIHdpbmRvdyB3aWR0aC5cbiAgICB2YXIgc3BhbnNWaWV3cG9ydCA9IGl0ZW0ud2lkdGggPj0gdGhpcy52aWV3cG9ydFdpZHRoICYmICFpc0xlZnRJblZpZXcgJiYgIWlzUmlnaHRJblZpZXcgJiYgaXRlbS5sZWZ0IDwgMCAmJiBpdGVtLnJpZ2h0ID4gdGhpcy52aWV3cG9ydFdpZHRoO1xuXG4gICAgcmV0dXJuIGlzTGVmdEluVmlldyB8fCBpc1JpZ2h0SW5WaWV3IHx8IHNwYW5zVmlld3BvcnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIElmIGFuIGVsZW1lbnQgaXMgaGlkZGVuIChoYXMgYSBwYXJlbnQgd2l0aCBkaXNwbGF5Om5vbmUpLCBnZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAgICogd2lsbCByZXR1cm4gYWxsIHplcm9zXG4gICAqIEBwYXJhbSB7Vmlld3BvcnRJdGVtfSBpdGVtIGl0ZW0gSXRlbSB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cblxuXG4gIFZpZXdwb3J0LnByb3RvdHlwZS5pc1Zpc2libGUgPSBmdW5jdGlvbiBpc1Zpc2libGUoaXRlbSkge1xuICAgIHJldHVybiAhKGl0ZW0ud2lkdGggPT09IDAgJiYgaXRlbS5oZWlnaHQgPT09IDApO1xuICB9O1xuXG4gIFZpZXdwb3J0LnByb3RvdHlwZS5pc1RvcFBhc3RWaWV3cG9ydCA9IGZ1bmN0aW9uIGlzVG9wUGFzdFZpZXdwb3J0KGl0ZW0pIHtcbiAgICByZXR1cm4gdGhpcy52aWV3cG9ydFRvcCA+IGl0ZW0udG9wO1xuICB9O1xuXG4gIFZpZXdwb3J0LnByb3RvdHlwZS5pc1ZpZXdwb3J0UGFzdEJvdHRvbSA9IGZ1bmN0aW9uIGlzVmlld3BvcnRQYXN0Qm90dG9tKGl0ZW0pIHtcbiAgICByZXR1cm4gdGhpcy52aWV3cG9ydFRvcCA+PSBpdGVtLmJvdHRvbTtcbiAgfTtcblxuICBWaWV3cG9ydC5wcm90b3R5cGUuaXNUb3BJblZpZXdwb3J0ID0gZnVuY3Rpb24gaXNUb3BJblZpZXdwb3J0KGl0ZW0pIHtcbiAgICB2YXIgZWxlbWVudFRvcCA9IGl0ZW0udG9wICsgaXRlbS5vZmZzZXQ7XG4gICAgcmV0dXJuIGluUmFuZ2UoZWxlbWVudFRvcCwgdGhpcy52aWV3cG9ydFRvcCwgdGhpcy52aWV3cG9ydEJvdHRvbSk7XG4gIH07XG5cbiAgVmlld3BvcnQucHJvdG90eXBlLmlzQm90dG9tSW5WaWV3cG9ydCA9IGZ1bmN0aW9uIGlzQm90dG9tSW5WaWV3cG9ydChpdGVtKSB7XG4gICAgLy8gQWNjb3VudCBmb3IgdGhyZXNob2xkIG9ubHkgZnJvbSB0aGUgZWxlbWVudCB0b3AuIE90aGVyd2lzZSB0aGUgZWxlbWVudFxuICAgIC8vIHdvbid0IGJlIFwib3V0IG9mIHZpZXdcIiBmcm9tIHRoZSBib3R0b20gdW50aWwgYWZ0ZXIgdGhlIGV4dHJhIHRocmVzaG9sZC5cbiAgICByZXR1cm4gaW5SYW5nZShpdGVtLmJvdHRvbSwgdGhpcy52aWV3cG9ydFRvcCwgdGhpcy52aWV3cG9ydEJvdHRvbSk7XG4gIH07XG5cbiAgVmlld3BvcnQucHJvdG90eXBlLmRvZXNTcGFuVmlld3BvcnQgPSBmdW5jdGlvbiBkb2VzU3BhblZpZXdwb3J0KGl0ZW0pIHtcbiAgICB2YXIgZWxlbWVudFRvcCA9IGl0ZW0udG9wICsgaXRlbS5vZmZzZXQ7XG4gICAgdmFyIGVsZW1lbnRCb3R0b20gPSBpdGVtLmJvdHRvbTtcbiAgICByZXR1cm4gaXRlbS5oZWlnaHQgPj0gdGhpcy52aWV3cG9ydEhlaWdodCAmJiBlbGVtZW50VG9wIDwgdGhpcy52aWV3cG9ydFRvcCAmJiBlbGVtZW50Qm90dG9tID4gdGhpcy52aWV3cG9ydEJvdHRvbTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCB2aWV3cG9ydCBpdGVtcyBhbmQgdW5iaW5kIGV2ZW50cy5cbiAgICovXG5cblxuICBWaWV3cG9ydC5mbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHZhciBpbnN0YW5jZSA9IFZpZXdwb3J0LmdldEluc3RhbmNlKCk7XG4gICAgaWYgKGluc3RhbmNlLmFkZElkKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShpbnN0YW5jZS5hZGRJZCk7XG4gICAgICBpbnN0YW5jZS5hZGRJZCA9IG51bGw7XG4gICAgfVxuXG4gICAgaW5zdGFuY2UuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaWQpIHtcbiAgICAgIFZpZXdwb3J0LnJlbW92ZShpZCk7XG4gICAgfSk7XG5cbiAgICBpbnN0YW5jZS5pdGVtcy5jbGVhcigpO1xuICAgIGluc3RhbmNlLnVuYmluZEV2ZW50cygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSB2aWV3cG9ydCBpdGVtIHRvIHdhdGNoLlxuICAgKiBAcGFyYW0ge29iamVjdHxvYmplY3RbXX0gb3B0aW9ucyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCBvciBhcnJheSBvZlxuICAgKiAgICAgb3B0aW9ucyBvYmplY3RzIHRvIGluaXRpYWxpemUuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gb3B0aW9ucy5lbGVtZW50IEVsZW1lbnQgdG8gd2F0Y2guXG4gICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW29wdGlvbnMudGhyZXNob2xkXSBPcHRpb25hbCAtIGVpdGhlciBhIG51bWJlciByZXByZXNlbnRpbmdcbiAgICogICAgIHRoZSB0aHJlc2hvbGQgb2Zmc2V0IChsaWtlIDEwMCksIGEgZmxvYXQgYmV0d2VlbiB6ZXJvIGFuZCBvbmUgcmVwcmVzZW50aW5nXG4gICAqICAgICBhIHBlcmNlbnRhZ2UsIG9yIGEgc3RyaW5nIGxpa2UgJzUwJScgZm9yIGEgcGVyY2VudGFnZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0aW9ucy5lbnRlciBDYWxsYmFjayB3aGVuIHRoZSBlbGVtZW50IGVudGVycyB2aWV3LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5leGl0XSBPcHRpb25hbCBjYWxsYmFjayB3aGVuIHRoZSBlbGVtZW50IGV4aXRzIHZpZXcuXG4gICAqIEByZXR1cm4ge3N0cmluZ3xzdHJpbmdbXX0gVmlld3BvcnQgaXRlbSBpZCBvciBhcnJheSBvZiBpdGVtIGlkcyBpZlxuICAgKiAgICAgYG9wdGlvbnNgIGlzIGFuIGFycmF5LlxuICAgKi9cblxuXG4gIFZpZXdwb3J0LmFkZCA9IGZ1bmN0aW9uIGFkZChvcHRpb25zKSB7XG4gICAgdmFyIGluc3RhbmNlID0gVmlld3BvcnQuZ2V0SW5zdGFuY2UoKTtcblxuICAgIHZhciBpZCA9IHZvaWQgMDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgaWQgPSBvcHRpb25zLm1hcChmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS5hZGQob3B0aW9uKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZCA9IGluc3RhbmNlLmFkZChvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvLyBBdm9pZCBhZGRpbmcgbXVsdGlwbGUgckFGcyB3aGVuIGl0IHNob3VsZCByZWFsbHkgb25seSBiZSBwcm9jZXNzZWQgb25jZS5cbiAgICBpZiAoaW5zdGFuY2UuYWRkSWQpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGluc3RhbmNlLmFkZElkKTtcbiAgICB9XG5cbiAgICBpbnN0YW5jZS5hZGRJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShpbnN0YW5jZS5wcm9jZXNzLmJpbmQoaW5zdGFuY2UpKTtcblxuICAgIHJldHVybiBpZDtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIGEgdmlld3BvcnQgaXRlbSBmcm9tIHRoZSBsaXN0IG9mIHZpZXdwb3J0IGl0ZW1zIHRvIHdhdGNoLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIGlkIHJldHVybmVkIGZyb20gYWRkaW5nIHRoZSB2aWV3cG9ydCBpdGVtLlxuICAgKi9cblxuXG4gIFZpZXdwb3J0LnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShpZCkge1xuICAgIHZhciBpbnN0YW5jZSA9IFZpZXdwb3J0LmdldEluc3RhbmNlKCk7XG4gICAgaWYgKGluc3RhbmNlLml0ZW1zLmhhcyhpZCkpIHtcbiAgICAgIGluc3RhbmNlLml0ZW1zLmdldChpZCkuZGlzcG9zZSgpO1xuICAgICAgaW5zdGFuY2UuaXRlbXMuZGVsZXRlKGlkKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFRlbGwgdGhlIHZpZXdwb3J0IGluc3RhbmNlIHRoYXQgb2Zmc2V0cyBuZWVkIHRvIGJlIHVwZGF0ZWQuXG4gICAqL1xuXG5cbiAgVmlld3BvcnQudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIFZpZXdwb3J0LmdldEluc3RhbmNlKCkudXBkYXRlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSB2aWV3cG9ydCBpbnN0YW5jZS5cbiAgICogQHJldHVybiB7Vmlld3BvcnR9XG4gICAqL1xuXG5cbiAgVmlld3BvcnQuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiBnZXRJbnN0YW5jZSgpIHtcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICBpbnN0YW5jZSA9IG5ldyBWaWV3cG9ydCgpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcblxuICBjcmVhdGVDbGFzcyhWaWV3cG9ydCwgW3tcbiAgICBrZXk6ICd2aWV3cG9ydEJvdHRvbScsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICByZXR1cm4gdGhpcy52aWV3cG9ydFRvcCArIHRoaXMudmlld3BvcnRIZWlnaHQ7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBWaWV3cG9ydDtcbn0oKTtcblxuZXhwb3J0IGRlZmF1bHQgVmlld3BvcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vZG8tdmlld3BvcnQuZXNtLmpzLm1hcFxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@odopod/odo-viewport/dist/odo-viewport.esm.js\n");

/***/ }),

/***/ "./node_modules/@odopod/odo-window-events/dist/odo-window-events.esm.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@odopod/odo-window-events/dist/odo-window-events.esm.js ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nvar throttleit = throttle;\n\n/**\n * Returns a new function that, when invoked, invokes `func` at most once per `wait` milliseconds.\n *\n * @param {Function} func Function to wrap.\n * @param {Number} wait Number of milliseconds that must elapse between `func` invocations.\n * @return {Function} A new function that wraps the `func` function passed in.\n */\n\nfunction throttle(func, wait) {\n  var ctx, args, rtn, timeoutID; // caching\n  var last = 0;\n\n  return function throttled() {\n    ctx = this;\n    args = arguments;\n    var delta = new Date() - last;\n    if (!timeoutID) if (delta >= wait) call();else timeoutID = setTimeout(call, wait - delta);\n    return rtn;\n  };\n\n  function call() {\n    timeoutID = 0;\n    last = +new Date();\n    rtn = func.apply(ctx, args);\n    ctx = null;\n    args = null;\n  }\n}\n\n/**\n * Returns a function, that, as long as it continues to be invoked, will not\n * be triggered. The function will be called after it stops being called for\n * N milliseconds. If `immediate` is passed, trigger the function on the\n * leading edge, instead of the trailing. The function also has a property 'clear' \n * that is a function which will clear the timer to prevent previously scheduled executions. \n *\n * @source underscore.js\n * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/\n * @param {Function} function to wrap\n * @param {Number} timeout in ms (`100`)\n * @param {Boolean} whether to execute at the beginning (`false`)\n * @api public\n */\n\nvar debounce = function debounce(func, wait, immediate) {\n  var timeout, args, context, timestamp, result;\n  if (null == wait) wait = 100;\n\n  function later() {\n    var last = Date.now() - timestamp;\n\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last);\n    } else {\n      timeout = null;\n      if (!immediate) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n    }\n  }\n\n  var debounced = function debounced() {\n    context = this;\n    args = arguments;\n    timestamp = Date.now();\n    var callNow = immediate && !timeout;\n    if (!timeout) timeout = setTimeout(later, wait);\n    if (callNow) {\n      result = func.apply(context, args);\n      context = args = null;\n    }\n\n    return result;\n  };\n\n  debounced.clear = function () {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n\n  debounced.flush = function () {\n    if (timeout) {\n      result = func.apply(context, args);\n      context = args = null;\n\n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n\n  return debounced;\n};\n\nvar count = 0;\nfunction uniqueId() {\n  count += 1;\n  return 'OdoWindowEvents' + count;\n}\n\nfunction callEachWithArg(object, args) {\n  Object.keys(object).forEach(function (i) {\n    object[i].call(null, args[0], args[1]);\n  });\n}\n\n/**\n * Retrieves the scroll offsets. This only works for the page scroll. For\n * scroll positions of an element, the `scrollTop` and `scrollLeft` properties\n * need to be used.\n * @return {{top: number, left: number}}\n */\nfunction getScrollPosition() {\n  return {\n    top: window.pageYOffset,\n    left: window.pageXOffset\n  };\n}\n\n/**\n * Retrieve the dimensions of the viewable screen.\n * @return {{width: number, height: number}}\n */\nfunction getViewportSize() {\n  return {\n    width: window.innerWidth,\n    height: window.innerHeight\n  };\n}\n\nfunction addCallback(object, fn) {\n  var id = uniqueId();\n  object[id] = fn;\n  return id;\n}\n\nvar WindowEvents = {\n\n  _scrollCallbacks: {},\n  _fastScrollCallbacks: {},\n  _resizeCallbacks: {},\n  _leadingResizeCallbacks: {},\n\n  _callbacks: {\n    resize: function resize() {\n      var viewport = getViewportSize();\n      callEachWithArg(WindowEvents._resizeCallbacks, [viewport.width, viewport.height]);\n    },\n    leadingResize: function leadingResize() {\n      var viewport = getViewportSize();\n      callEachWithArg(WindowEvents._leadingResizeCallbacks, [viewport.width, viewport.height]);\n    },\n    scroll: function scroll() {\n      var scroll = getScrollPosition();\n      callEachWithArg(WindowEvents._scrollCallbacks, [scroll.top, scroll.left]);\n    },\n    fastScroll: function fastScroll() {\n      var scroll = getScrollPosition();\n      callEachWithArg(WindowEvents._fastScrollCallbacks, [scroll.top, scroll.left]);\n    }\n  },\n\n  Timing: {\n    DEBOUNCE_TIME: 500,\n    THROTTLE_TIME_DEFAULT: 500,\n    THROTTLE_TIME_FAST: 150\n  },\n\n  /**\n   * Bind a callback to window scroll.\n   * @param {function(number, number):void} fn Callback to execute on scroll.\n   * @return {string} id of event, to be used with service's remove method.\n   */\n  onScroll: function onScroll(fn) {\n    return addCallback(WindowEvents._scrollCallbacks, fn);\n  },\n\n\n  /**\n   * Bind a callback to window scroll which executes quicker.\n   * @param {function(number, number):void} fn Callback to execute on scroll.\n   * @return {string} id of event, to be used with service's remove method.\n   */\n  onFastScroll: function onFastScroll(fn) {\n    return addCallback(WindowEvents._fastScrollCallbacks, fn);\n  },\n\n\n  /**\n   * Bind a callback to window resize.\n   * @param {function(number, number):void} fn Callback to execute on resize.\n   * @return {string} id of event, to be used with service's remove method.\n   */\n  onResize: function onResize(fn) {\n    return addCallback(WindowEvents._resizeCallbacks, fn);\n  },\n\n\n  /**\n   * Bind a callback to window resize.\n   * @param {function(number, number):void} fn Callback to execute on resize.\n   * @return {string} id of event, to be used with service's remove method.\n   */\n  onLeadingResize: function onLeadingResize(fn) {\n    return addCallback(WindowEvents._leadingResizeCallbacks, fn);\n  },\n\n\n  /**\n   * Remove callback with a given id.\n   * @param {string} id Callback ID to remove.\n   */\n  remove: function remove(id) {\n    delete WindowEvents._scrollCallbacks[id];\n    delete WindowEvents._fastScrollCallbacks[id];\n    delete WindowEvents._resizeCallbacks[id];\n    delete WindowEvents._leadingResizeCallbacks[id];\n  }\n};\n\nvar resize = debounce(WindowEvents._callbacks.resize, WindowEvents.Timing.DEBOUNCE_TIME);\nvar leadingResize = debounce(WindowEvents._callbacks.leadingResize, WindowEvents.Timing.DEBOUNCE_TIME, true);\nvar scrolled = throttleit(WindowEvents._callbacks.scroll, WindowEvents.Timing.THROTTLE_TIME_DEFAULT);\nvar fastScroll = throttleit(WindowEvents._callbacks.fastScroll, WindowEvents.Timing.THROTTLE_TIME_FAST);\n\nWindowEvents._resizeCallback = function () {\n  leadingResize();\n  resize();\n};\n\nWindowEvents._scrollCallback = function () {\n  scrolled();\n  fastScroll();\n};\n\nwindow.addEventListener('resize', WindowEvents._resizeCallback);\nwindow.addEventListener('scroll', WindowEvents._scrollCallback);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (WindowEvents);\n//# sourceMappingURL=odo-window-events.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG9kb3BvZC9vZG8td2luZG93LWV2ZW50cy9kaXN0L29kby13aW5kb3ctZXZlbnRzLmVzbS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ab2RvcG9kL29kby13aW5kb3ctZXZlbnRzL2Rpc3Qvb2RvLXdpbmRvdy1ldmVudHMuZXNtLmpzP2M1Y2EiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHRocm90dGxlaXQgPSB0aHJvdHRsZTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGZ1bmN0aW9uIHRoYXQsIHdoZW4gaW52b2tlZCwgaW52b2tlcyBgZnVuY2AgYXQgbW9zdCBvbmNlIHBlciBgd2FpdGAgbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgRnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7TnVtYmVyfSB3YWl0IE51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBtdXN0IGVsYXBzZSBiZXR3ZWVuIGBmdW5jYCBpbnZvY2F0aW9ucy5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIG5ldyBmdW5jdGlvbiB0aGF0IHdyYXBzIHRoZSBgZnVuY2AgZnVuY3Rpb24gcGFzc2VkIGluLlxuICovXG5cbmZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQpIHtcbiAgdmFyIGN0eCwgYXJncywgcnRuLCB0aW1lb3V0SUQ7IC8vIGNhY2hpbmdcbiAgdmFyIGxhc3QgPSAwO1xuXG4gIHJldHVybiBmdW5jdGlvbiB0aHJvdHRsZWQoKSB7XG4gICAgY3R4ID0gdGhpcztcbiAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBkZWx0YSA9IG5ldyBEYXRlKCkgLSBsYXN0O1xuICAgIGlmICghdGltZW91dElEKSBpZiAoZGVsdGEgPj0gd2FpdCkgY2FsbCgpO2Vsc2UgdGltZW91dElEID0gc2V0VGltZW91dChjYWxsLCB3YWl0IC0gZGVsdGEpO1xuICAgIHJldHVybiBydG47XG4gIH07XG5cbiAgZnVuY3Rpb24gY2FsbCgpIHtcbiAgICB0aW1lb3V0SUQgPSAwO1xuICAgIGxhc3QgPSArbmV3IERhdGUoKTtcbiAgICBydG4gPSBmdW5jLmFwcGx5KGN0eCwgYXJncyk7XG4gICAgY3R4ID0gbnVsbDtcbiAgICBhcmdzID0gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3RcbiAqIGJlIHRyaWdnZXJlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGl0IHN0b3BzIGJlaW5nIGNhbGxlZCBmb3JcbiAqIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxuICogbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy4gVGhlIGZ1bmN0aW9uIGFsc28gaGFzIGEgcHJvcGVydHkgJ2NsZWFyJyBcbiAqIHRoYXQgaXMgYSBmdW5jdGlvbiB3aGljaCB3aWxsIGNsZWFyIHRoZSB0aW1lciB0byBwcmV2ZW50IHByZXZpb3VzbHkgc2NoZWR1bGVkIGV4ZWN1dGlvbnMuIFxuICpcbiAqIEBzb3VyY2UgdW5kZXJzY29yZS5qc1xuICogQHNlZSBodHRwOi8vdW5zY3JpcHRhYmxlLmNvbS8yMDA5LzAzLzIwL2RlYm91bmNpbmctamF2YXNjcmlwdC1tZXRob2RzL1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY3Rpb24gdG8gd3JhcFxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXQgaW4gbXMgKGAxMDBgKVxuICogQHBhcmFtIHtCb29sZWFufSB3aGV0aGVyIHRvIGV4ZWN1dGUgYXQgdGhlIGJlZ2lubmluZyAoYGZhbHNlYClcbiAqIEBhcGkgcHVibGljXG4gKi9cblxudmFyIGRlYm91bmNlID0gZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gIHZhciB0aW1lb3V0LCBhcmdzLCBjb250ZXh0LCB0aW1lc3RhbXAsIHJlc3VsdDtcbiAgaWYgKG51bGwgPT0gd2FpdCkgd2FpdCA9IDEwMDtcblxuICBmdW5jdGlvbiBsYXRlcigpIHtcbiAgICB2YXIgbGFzdCA9IERhdGUubm93KCkgLSB0aW1lc3RhbXA7XG5cbiAgICBpZiAobGFzdCA8IHdhaXQgJiYgbGFzdCA+PSAwKSB7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCAtIGxhc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIGlmICghaW1tZWRpYXRlKSB7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZGVib3VuY2VkID0gZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgIGNvbnRleHQgPSB0aGlzO1xuICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICBpZiAoIXRpbWVvdXQpIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICBpZiAoY2FsbE5vdykge1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIGRlYm91bmNlZC5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIGRlYm91bmNlZC5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGltZW91dCkge1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcblxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBkZWJvdW5jZWQ7XG59O1xuXG52YXIgY291bnQgPSAwO1xuZnVuY3Rpb24gdW5pcXVlSWQoKSB7XG4gIGNvdW50ICs9IDE7XG4gIHJldHVybiAnT2RvV2luZG93RXZlbnRzJyArIGNvdW50O1xufVxuXG5mdW5jdGlvbiBjYWxsRWFjaFdpdGhBcmcob2JqZWN0LCBhcmdzKSB7XG4gIE9iamVjdC5rZXlzKG9iamVjdCkuZm9yRWFjaChmdW5jdGlvbiAoaSkge1xuICAgIG9iamVjdFtpXS5jYWxsKG51bGwsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIHNjcm9sbCBvZmZzZXRzLiBUaGlzIG9ubHkgd29ya3MgZm9yIHRoZSBwYWdlIHNjcm9sbC4gRm9yXG4gKiBzY3JvbGwgcG9zaXRpb25zIG9mIGFuIGVsZW1lbnQsIHRoZSBgc2Nyb2xsVG9wYCBhbmQgYHNjcm9sbExlZnRgIHByb3BlcnRpZXNcbiAqIG5lZWQgdG8gYmUgdXNlZC5cbiAqIEByZXR1cm4ge3t0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyfX1cbiAqL1xuZnVuY3Rpb24gZ2V0U2Nyb2xsUG9zaXRpb24oKSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiB3aW5kb3cucGFnZVlPZmZzZXQsXG4gICAgbGVmdDogd2luZG93LnBhZ2VYT2Zmc2V0XG4gIH07XG59XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIHZpZXdhYmxlIHNjcmVlbi5cbiAqIEByZXR1cm4ge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19XG4gKi9cbmZ1bmN0aW9uIGdldFZpZXdwb3J0U2l6ZSgpIHtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2luZG93LmlubmVyV2lkdGgsXG4gICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgfTtcbn1cblxuZnVuY3Rpb24gYWRkQ2FsbGJhY2sob2JqZWN0LCBmbikge1xuICB2YXIgaWQgPSB1bmlxdWVJZCgpO1xuICBvYmplY3RbaWRdID0gZm47XG4gIHJldHVybiBpZDtcbn1cblxudmFyIFdpbmRvd0V2ZW50cyA9IHtcblxuICBfc2Nyb2xsQ2FsbGJhY2tzOiB7fSxcbiAgX2Zhc3RTY3JvbGxDYWxsYmFja3M6IHt9LFxuICBfcmVzaXplQ2FsbGJhY2tzOiB7fSxcbiAgX2xlYWRpbmdSZXNpemVDYWxsYmFja3M6IHt9LFxuXG4gIF9jYWxsYmFja3M6IHtcbiAgICByZXNpemU6IGZ1bmN0aW9uIHJlc2l6ZSgpIHtcbiAgICAgIHZhciB2aWV3cG9ydCA9IGdldFZpZXdwb3J0U2l6ZSgpO1xuICAgICAgY2FsbEVhY2hXaXRoQXJnKFdpbmRvd0V2ZW50cy5fcmVzaXplQ2FsbGJhY2tzLCBbdmlld3BvcnQud2lkdGgsIHZpZXdwb3J0LmhlaWdodF0pO1xuICAgIH0sXG4gICAgbGVhZGluZ1Jlc2l6ZTogZnVuY3Rpb24gbGVhZGluZ1Jlc2l6ZSgpIHtcbiAgICAgIHZhciB2aWV3cG9ydCA9IGdldFZpZXdwb3J0U2l6ZSgpO1xuICAgICAgY2FsbEVhY2hXaXRoQXJnKFdpbmRvd0V2ZW50cy5fbGVhZGluZ1Jlc2l6ZUNhbGxiYWNrcywgW3ZpZXdwb3J0LndpZHRoLCB2aWV3cG9ydC5oZWlnaHRdKTtcbiAgICB9LFxuICAgIHNjcm9sbDogZnVuY3Rpb24gc2Nyb2xsKCkge1xuICAgICAgdmFyIHNjcm9sbCA9IGdldFNjcm9sbFBvc2l0aW9uKCk7XG4gICAgICBjYWxsRWFjaFdpdGhBcmcoV2luZG93RXZlbnRzLl9zY3JvbGxDYWxsYmFja3MsIFtzY3JvbGwudG9wLCBzY3JvbGwubGVmdF0pO1xuICAgIH0sXG4gICAgZmFzdFNjcm9sbDogZnVuY3Rpb24gZmFzdFNjcm9sbCgpIHtcbiAgICAgIHZhciBzY3JvbGwgPSBnZXRTY3JvbGxQb3NpdGlvbigpO1xuICAgICAgY2FsbEVhY2hXaXRoQXJnKFdpbmRvd0V2ZW50cy5fZmFzdFNjcm9sbENhbGxiYWNrcywgW3Njcm9sbC50b3AsIHNjcm9sbC5sZWZ0XSk7XG4gICAgfVxuICB9LFxuXG4gIFRpbWluZzoge1xuICAgIERFQk9VTkNFX1RJTUU6IDUwMCxcbiAgICBUSFJPVFRMRV9USU1FX0RFRkFVTFQ6IDUwMCxcbiAgICBUSFJPVFRMRV9USU1FX0ZBU1Q6IDE1MFxuICB9LFxuXG4gIC8qKlxuICAgKiBCaW5kIGEgY2FsbGJhY2sgdG8gd2luZG93IHNjcm9sbC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIsIG51bWJlcik6dm9pZH0gZm4gQ2FsbGJhY2sgdG8gZXhlY3V0ZSBvbiBzY3JvbGwuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gaWQgb2YgZXZlbnQsIHRvIGJlIHVzZWQgd2l0aCBzZXJ2aWNlJ3MgcmVtb3ZlIG1ldGhvZC5cbiAgICovXG4gIG9uU2Nyb2xsOiBmdW5jdGlvbiBvblNjcm9sbChmbikge1xuICAgIHJldHVybiBhZGRDYWxsYmFjayhXaW5kb3dFdmVudHMuX3Njcm9sbENhbGxiYWNrcywgZm4pO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIEJpbmQgYSBjYWxsYmFjayB0byB3aW5kb3cgc2Nyb2xsIHdoaWNoIGV4ZWN1dGVzIHF1aWNrZXIuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24obnVtYmVyLCBudW1iZXIpOnZvaWR9IGZuIENhbGxiYWNrIHRvIGV4ZWN1dGUgb24gc2Nyb2xsLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IGlkIG9mIGV2ZW50LCB0byBiZSB1c2VkIHdpdGggc2VydmljZSdzIHJlbW92ZSBtZXRob2QuXG4gICAqL1xuICBvbkZhc3RTY3JvbGw6IGZ1bmN0aW9uIG9uRmFzdFNjcm9sbChmbikge1xuICAgIHJldHVybiBhZGRDYWxsYmFjayhXaW5kb3dFdmVudHMuX2Zhc3RTY3JvbGxDYWxsYmFja3MsIGZuKTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBCaW5kIGEgY2FsbGJhY2sgdG8gd2luZG93IHJlc2l6ZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIsIG51bWJlcik6dm9pZH0gZm4gQ2FsbGJhY2sgdG8gZXhlY3V0ZSBvbiByZXNpemUuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gaWQgb2YgZXZlbnQsIHRvIGJlIHVzZWQgd2l0aCBzZXJ2aWNlJ3MgcmVtb3ZlIG1ldGhvZC5cbiAgICovXG4gIG9uUmVzaXplOiBmdW5jdGlvbiBvblJlc2l6ZShmbikge1xuICAgIHJldHVybiBhZGRDYWxsYmFjayhXaW5kb3dFdmVudHMuX3Jlc2l6ZUNhbGxiYWNrcywgZm4pO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIEJpbmQgYSBjYWxsYmFjayB0byB3aW5kb3cgcmVzaXplLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlciwgbnVtYmVyKTp2b2lkfSBmbiBDYWxsYmFjayB0byBleGVjdXRlIG9uIHJlc2l6ZS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBpZCBvZiBldmVudCwgdG8gYmUgdXNlZCB3aXRoIHNlcnZpY2UncyByZW1vdmUgbWV0aG9kLlxuICAgKi9cbiAgb25MZWFkaW5nUmVzaXplOiBmdW5jdGlvbiBvbkxlYWRpbmdSZXNpemUoZm4pIHtcbiAgICByZXR1cm4gYWRkQ2FsbGJhY2soV2luZG93RXZlbnRzLl9sZWFkaW5nUmVzaXplQ2FsbGJhY2tzLCBmbik7XG4gIH0sXG5cblxuICAvKipcbiAgICogUmVtb3ZlIGNhbGxiYWNrIHdpdGggYSBnaXZlbiBpZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIENhbGxiYWNrIElEIHRvIHJlbW92ZS5cbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGlkKSB7XG4gICAgZGVsZXRlIFdpbmRvd0V2ZW50cy5fc2Nyb2xsQ2FsbGJhY2tzW2lkXTtcbiAgICBkZWxldGUgV2luZG93RXZlbnRzLl9mYXN0U2Nyb2xsQ2FsbGJhY2tzW2lkXTtcbiAgICBkZWxldGUgV2luZG93RXZlbnRzLl9yZXNpemVDYWxsYmFja3NbaWRdO1xuICAgIGRlbGV0ZSBXaW5kb3dFdmVudHMuX2xlYWRpbmdSZXNpemVDYWxsYmFja3NbaWRdO1xuICB9XG59O1xuXG52YXIgcmVzaXplID0gZGVib3VuY2UoV2luZG93RXZlbnRzLl9jYWxsYmFja3MucmVzaXplLCBXaW5kb3dFdmVudHMuVGltaW5nLkRFQk9VTkNFX1RJTUUpO1xudmFyIGxlYWRpbmdSZXNpemUgPSBkZWJvdW5jZShXaW5kb3dFdmVudHMuX2NhbGxiYWNrcy5sZWFkaW5nUmVzaXplLCBXaW5kb3dFdmVudHMuVGltaW5nLkRFQk9VTkNFX1RJTUUsIHRydWUpO1xudmFyIHNjcm9sbGVkID0gdGhyb3R0bGVpdChXaW5kb3dFdmVudHMuX2NhbGxiYWNrcy5zY3JvbGwsIFdpbmRvd0V2ZW50cy5UaW1pbmcuVEhST1RUTEVfVElNRV9ERUZBVUxUKTtcbnZhciBmYXN0U2Nyb2xsID0gdGhyb3R0bGVpdChXaW5kb3dFdmVudHMuX2NhbGxiYWNrcy5mYXN0U2Nyb2xsLCBXaW5kb3dFdmVudHMuVGltaW5nLlRIUk9UVExFX1RJTUVfRkFTVCk7XG5cbldpbmRvd0V2ZW50cy5fcmVzaXplQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gIGxlYWRpbmdSZXNpemUoKTtcbiAgcmVzaXplKCk7XG59O1xuXG5XaW5kb3dFdmVudHMuX3Njcm9sbENhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICBzY3JvbGxlZCgpO1xuICBmYXN0U2Nyb2xsKCk7XG59O1xuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgV2luZG93RXZlbnRzLl9yZXNpemVDYWxsYmFjayk7XG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgV2luZG93RXZlbnRzLl9zY3JvbGxDYWxsYmFjayk7XG5cbmV4cG9ydCBkZWZhdWx0IFdpbmRvd0V2ZW50cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9kby13aW5kb3ctZXZlbnRzLmVzbS5qcy5tYXBcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@odopod/odo-window-events/dist/odo-window-events.esm.js\n");

/***/ }),

/***/ "./node_modules/picturefill/dist/picturefill.js":
/*!******************************************************!*\
  !*** ./node_modules/picturefill/dist/picturefill.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*! picturefill - v3.0.2 - 2016-02-12\n * https://scottjehl.github.io/picturefill/\n * Copyright (c) 2016 https://github.com/scottjehl/picturefill/blob/master/Authors.txt; Licensed MIT\n */\n/*! Gecko-Picture - v1.0\n * https://github.com/scottjehl/picturefill/tree/3.0/src/plugins/gecko-picture\n * Firefox's early picture implementation (prior to FF41) is static and does\n * not react to viewport changes. This tiny module fixes this.\n */\n(function(window) {\n\t/*jshint eqnull:true */\n\tvar ua = navigator.userAgent;\n\n\tif ( window.HTMLPictureElement && ((/ecko/).test(ua) && ua.match(/rv\\:(\\d+)/) && RegExp.$1 < 45) ) {\n\t\taddEventListener(\"resize\", (function() {\n\t\t\tvar timer;\n\n\t\t\tvar dummySrc = document.createElement(\"source\");\n\n\t\t\tvar fixRespimg = function(img) {\n\t\t\t\tvar source, sizes;\n\t\t\t\tvar picture = img.parentNode;\n\n\t\t\t\tif (picture.nodeName.toUpperCase() === \"PICTURE\") {\n\t\t\t\t\tsource = dummySrc.cloneNode();\n\n\t\t\t\t\tpicture.insertBefore(source, picture.firstElementChild);\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\tpicture.removeChild(source);\n\t\t\t\t\t});\n\t\t\t\t} else if (!img._pfLastSize || img.offsetWidth > img._pfLastSize) {\n\t\t\t\t\timg._pfLastSize = img.offsetWidth;\n\t\t\t\t\tsizes = img.sizes;\n\t\t\t\t\timg.sizes += \",100vw\";\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\timg.sizes = sizes;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tvar findPictureImgs = function() {\n\t\t\t\tvar i;\n\t\t\t\tvar imgs = document.querySelectorAll(\"picture > img, img[srcset][sizes]\");\n\t\t\t\tfor (i = 0; i < imgs.length; i++) {\n\t\t\t\t\tfixRespimg(imgs[i]);\n\t\t\t\t}\n\t\t\t};\n\t\t\tvar onResize = function() {\n\t\t\t\tclearTimeout(timer);\n\t\t\t\ttimer = setTimeout(findPictureImgs, 99);\n\t\t\t};\n\t\t\tvar mq = window.matchMedia && matchMedia(\"(orientation: landscape)\");\n\t\t\tvar init = function() {\n\t\t\t\tonResize();\n\n\t\t\t\tif (mq && mq.addListener) {\n\t\t\t\t\tmq.addListener(onResize);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tdummySrc.srcset = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n\n\t\t\tif (/^[c|i]|d$/.test(document.readyState || \"\")) {\n\t\t\t\tinit();\n\t\t\t} else {\n\t\t\t\tdocument.addEventListener(\"DOMContentLoaded\", init);\n\t\t\t}\n\n\t\t\treturn onResize;\n\t\t})());\n\t}\n})(window);\n\n/*! Picturefill - v3.0.2\n * http://scottjehl.github.io/picturefill\n * Copyright (c) 2015 https://github.com/scottjehl/picturefill/blob/master/Authors.txt;\n *  License: MIT\n */\n\n(function( window, document, undefined ) {\n\t// Enable strict mode\n\t\"use strict\";\n\n\t// HTML shim|v it for old IE (IE9 will still need the HTML video tag workaround)\n\tdocument.createElement( \"picture\" );\n\n\tvar warn, eminpx, alwaysCheckWDescriptor, evalId;\n\t// local object for method references and testing exposure\n\tvar pf = {};\n\tvar isSupportTestReady = false;\n\tvar noop = function() {};\n\tvar image = document.createElement( \"img\" );\n\tvar getImgAttr = image.getAttribute;\n\tvar setImgAttr = image.setAttribute;\n\tvar removeImgAttr = image.removeAttribute;\n\tvar docElem = document.documentElement;\n\tvar types = {};\n\tvar cfg = {\n\t\t//resource selection:\n\t\talgorithm: \"\"\n\t};\n\tvar srcAttr = \"data-pfsrc\";\n\tvar srcsetAttr = srcAttr + \"set\";\n\t// ua sniffing is done for undetectable img loading features,\n\t// to do some non crucial perf optimizations\n\tvar ua = navigator.userAgent;\n\tvar supportAbort = (/rident/).test(ua) || ((/ecko/).test(ua) && ua.match(/rv\\:(\\d+)/) && RegExp.$1 > 35 );\n\tvar curSrcProp = \"currentSrc\";\n\tvar regWDesc = /\\s+\\+?\\d+(e\\d+)?w/;\n\tvar regSize = /(\\([^)]+\\))?\\s*(.+)/;\n\tvar setOptions = window.picturefillCFG;\n\t/**\n\t * Shortcut property for https://w3c.github.io/webappsec/specs/mixedcontent/#restricts-mixed-content ( for easy overriding in tests )\n\t */\n\t// baseStyle also used by getEmValue (i.e.: width: 1em is important)\n\tvar baseStyle = \"position:absolute;left:0;visibility:hidden;display:block;padding:0;border:none;font-size:1em;width:1em;overflow:hidden;clip:rect(0px, 0px, 0px, 0px)\";\n\tvar fsCss = \"font-size:100%!important;\";\n\tvar isVwDirty = true;\n\n\tvar cssCache = {};\n\tvar sizeLengthCache = {};\n\tvar DPR = window.devicePixelRatio;\n\tvar units = {\n\t\tpx: 1,\n\t\t\"in\": 96\n\t};\n\tvar anchor = document.createElement( \"a\" );\n\t/**\n\t * alreadyRun flag used for setOptions. is it true setOptions will reevaluate\n\t * @type {boolean}\n\t */\n\tvar alreadyRun = false;\n\n\t// Reusable, non-\"g\" Regexes\n\n\t// (Don't use \\s, to avoid matching non-breaking space.)\n\tvar regexLeadingSpaces = /^[ \\t\\n\\r\\u000c]+/,\n\t    regexLeadingCommasOrSpaces = /^[, \\t\\n\\r\\u000c]+/,\n\t    regexLeadingNotSpaces = /^[^ \\t\\n\\r\\u000c]+/,\n\t    regexTrailingCommas = /[,]+$/,\n\t    regexNonNegativeInteger = /^\\d+$/,\n\n\t    // ( Positive or negative or unsigned integers or decimals, without or without exponents.\n\t    // Must include at least one digit.\n\t    // According to spec tests any decimal point must be followed by a digit.\n\t    // No leading plus sign is allowed.)\n\t    // https://html.spec.whatwg.org/multipage/infrastructure.html#valid-floating-point-number\n\t    regexFloatingPoint = /^-?(?:[0-9]+|[0-9]*\\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/;\n\n\tvar on = function(obj, evt, fn, capture) {\n\t\tif ( obj.addEventListener ) {\n\t\t\tobj.addEventListener(evt, fn, capture || false);\n\t\t} else if ( obj.attachEvent ) {\n\t\t\tobj.attachEvent( \"on\" + evt, fn);\n\t\t}\n\t};\n\n\t/**\n\t * simple memoize function:\n\t */\n\n\tvar memoize = function(fn) {\n\t\tvar cache = {};\n\t\treturn function(input) {\n\t\t\tif ( !(input in cache) ) {\n\t\t\t\tcache[ input ] = fn(input);\n\t\t\t}\n\t\t\treturn cache[ input ];\n\t\t};\n\t};\n\n\t// UTILITY FUNCTIONS\n\n\t// Manual is faster than RegEx\n\t// http://jsperf.com/whitespace-character/5\n\tfunction isSpace(c) {\n\t\treturn (c === \"\\u0020\" || // space\n\t\t        c === \"\\u0009\" || // horizontal tab\n\t\t        c === \"\\u000A\" || // new line\n\t\t        c === \"\\u000C\" || // form feed\n\t\t        c === \"\\u000D\");  // carriage return\n\t}\n\n\t/**\n\t * gets a mediaquery and returns a boolean or gets a css length and returns a number\n\t * @param css mediaqueries or css length\n\t * @returns {boolean|number}\n\t *\n\t * based on: https://gist.github.com/jonathantneal/db4f77009b155f083738\n\t */\n\tvar evalCSS = (function() {\n\n\t\tvar regLength = /^([\\d\\.]+)(em|vw|px)$/;\n\t\tvar replace = function() {\n\t\t\tvar args = arguments, index = 0, string = args[0];\n\t\t\twhile (++index in args) {\n\t\t\t\tstring = string.replace(args[index], args[++index]);\n\t\t\t}\n\t\t\treturn string;\n\t\t};\n\n\t\tvar buildStr = memoize(function(css) {\n\n\t\t\treturn \"return \" + replace((css || \"\").toLowerCase(),\n\t\t\t\t// interpret `and`\n\t\t\t\t/\\band\\b/g, \"&&\",\n\n\t\t\t\t// interpret `,`\n\t\t\t\t/,/g, \"||\",\n\n\t\t\t\t// interpret `min-` as >=\n\t\t\t\t/min-([a-z-\\s]+):/g, \"e.$1>=\",\n\n\t\t\t\t// interpret `max-` as <=\n\t\t\t\t/max-([a-z-\\s]+):/g, \"e.$1<=\",\n\n\t\t\t\t//calc value\n\t\t\t\t/calc([^)]+)/g, \"($1)\",\n\n\t\t\t\t// interpret css values\n\t\t\t\t/(\\d+[\\.]*[\\d]*)([a-z]+)/g, \"($1 * e.$2)\",\n\t\t\t\t//make eval less evil\n\t\t\t\t/^(?!(e.[a-z]|[0-9\\.&=|><\\+\\-\\*\\(\\)\\/])).*/ig, \"\"\n\t\t\t) + \";\";\n\t\t});\n\n\t\treturn function(css, length) {\n\t\t\tvar parsedLength;\n\t\t\tif (!(css in cssCache)) {\n\t\t\t\tcssCache[css] = false;\n\t\t\t\tif (length && (parsedLength = css.match( regLength ))) {\n\t\t\t\t\tcssCache[css] = parsedLength[ 1 ] * units[parsedLength[ 2 ]];\n\t\t\t\t} else {\n\t\t\t\t\t/*jshint evil:true */\n\t\t\t\t\ttry{\n\t\t\t\t\t\tcssCache[css] = new Function(\"e\", buildStr(css))(units);\n\t\t\t\t\t} catch(e) {}\n\t\t\t\t\t/*jshint evil:false */\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn cssCache[css];\n\t\t};\n\t})();\n\n\tvar setResolution = function( candidate, sizesattr ) {\n\t\tif ( candidate.w ) { // h = means height: || descriptor.type === 'h' do not handle yet...\n\t\t\tcandidate.cWidth = pf.calcListLength( sizesattr || \"100vw\" );\n\t\t\tcandidate.res = candidate.w / candidate.cWidth ;\n\t\t} else {\n\t\t\tcandidate.res = candidate.d;\n\t\t}\n\t\treturn candidate;\n\t};\n\n\t/**\n\t *\n\t * @param opt\n\t */\n\tvar picturefill = function( opt ) {\n\n\t\tif (!isSupportTestReady) {return;}\n\n\t\tvar elements, i, plen;\n\n\t\tvar options = opt || {};\n\n\t\tif ( options.elements && options.elements.nodeType === 1 ) {\n\t\t\tif ( options.elements.nodeName.toUpperCase() === \"IMG\" ) {\n\t\t\t\toptions.elements =  [ options.elements ];\n\t\t\t} else {\n\t\t\t\toptions.context = options.elements;\n\t\t\t\toptions.elements =  null;\n\t\t\t}\n\t\t}\n\n\t\telements = options.elements || pf.qsa( (options.context || document), ( options.reevaluate || options.reselect ) ? pf.sel : pf.selShort );\n\n\t\tif ( (plen = elements.length) ) {\n\n\t\t\tpf.setupRun( options );\n\t\t\talreadyRun = true;\n\n\t\t\t// Loop through all elements\n\t\t\tfor ( i = 0; i < plen; i++ ) {\n\t\t\t\tpf.fillImg(elements[ i ], options);\n\t\t\t}\n\n\t\t\tpf.teardownRun( options );\n\t\t}\n\t};\n\n\t/**\n\t * outputs a warning for the developer\n\t * @param {message}\n\t * @type {Function}\n\t */\n\twarn = ( window.console && console.warn ) ?\n\t\tfunction( message ) {\n\t\t\tconsole.warn( message );\n\t\t} :\n\t\tnoop\n\t;\n\n\tif ( !(curSrcProp in image) ) {\n\t\tcurSrcProp = \"src\";\n\t}\n\n\t// Add support for standard mime types.\n\ttypes[ \"image/jpeg\" ] = true;\n\ttypes[ \"image/gif\" ] = true;\n\ttypes[ \"image/png\" ] = true;\n\n\tfunction detectTypeSupport( type, typeUri ) {\n\t\t// based on Modernizr's lossless img-webp test\n\t\t// note: asynchronous\n\t\tvar image = new window.Image();\n\t\timage.onerror = function() {\n\t\t\ttypes[ type ] = false;\n\t\t\tpicturefill();\n\t\t};\n\t\timage.onload = function() {\n\t\t\ttypes[ type ] = image.width === 1;\n\t\t\tpicturefill();\n\t\t};\n\t\timage.src = typeUri;\n\t\treturn \"pending\";\n\t}\n\n\t// test svg support\n\ttypes[ \"image/svg+xml\" ] = document.implementation.hasFeature( \"http://www.w3.org/TR/SVG11/feature#Image\", \"1.1\" );\n\n\t/**\n\t * updates the internal vW property with the current viewport width in px\n\t */\n\tfunction updateMetrics() {\n\n\t\tisVwDirty = false;\n\t\tDPR = window.devicePixelRatio;\n\t\tcssCache = {};\n\t\tsizeLengthCache = {};\n\n\t\tpf.DPR = DPR || 1;\n\n\t\tunits.width = Math.max(window.innerWidth || 0, docElem.clientWidth);\n\t\tunits.height = Math.max(window.innerHeight || 0, docElem.clientHeight);\n\n\t\tunits.vw = units.width / 100;\n\t\tunits.vh = units.height / 100;\n\n\t\tevalId = [ units.height, units.width, DPR ].join(\"-\");\n\n\t\tunits.em = pf.getEmValue();\n\t\tunits.rem = units.em;\n\t}\n\n\tfunction chooseLowRes( lowerValue, higherValue, dprValue, isCached ) {\n\t\tvar bonusFactor, tooMuch, bonus, meanDensity;\n\n\t\t//experimental\n\t\tif (cfg.algorithm === \"saveData\" ){\n\t\t\tif ( lowerValue > 2.7 ) {\n\t\t\t\tmeanDensity = dprValue + 1;\n\t\t\t} else {\n\t\t\t\ttooMuch = higherValue - dprValue;\n\t\t\t\tbonusFactor = Math.pow(lowerValue - 0.6, 1.5);\n\n\t\t\t\tbonus = tooMuch * bonusFactor;\n\n\t\t\t\tif (isCached) {\n\t\t\t\t\tbonus += 0.1 * bonusFactor;\n\t\t\t\t}\n\n\t\t\t\tmeanDensity = lowerValue + bonus;\n\t\t\t}\n\t\t} else {\n\t\t\tmeanDensity = (dprValue > 1) ?\n\t\t\t\tMath.sqrt(lowerValue * higherValue) :\n\t\t\t\tlowerValue;\n\t\t}\n\n\t\treturn meanDensity > dprValue;\n\t}\n\n\tfunction applyBestCandidate( img ) {\n\t\tvar srcSetCandidates;\n\t\tvar matchingSet = pf.getSet( img );\n\t\tvar evaluated = false;\n\t\tif ( matchingSet !== \"pending\" ) {\n\t\t\tevaluated = evalId;\n\t\t\tif ( matchingSet ) {\n\t\t\t\tsrcSetCandidates = pf.setRes( matchingSet );\n\t\t\t\tpf.applySetCandidate( srcSetCandidates, img );\n\t\t\t}\n\t\t}\n\t\timg[ pf.ns ].evaled = evaluated;\n\t}\n\n\tfunction ascendingSort( a, b ) {\n\t\treturn a.res - b.res;\n\t}\n\n\tfunction setSrcToCur( img, src, set ) {\n\t\tvar candidate;\n\t\tif ( !set && src ) {\n\t\t\tset = img[ pf.ns ].sets;\n\t\t\tset = set && set[set.length - 1];\n\t\t}\n\n\t\tcandidate = getCandidateForSrc(src, set);\n\n\t\tif ( candidate ) {\n\t\t\tsrc = pf.makeUrl(src);\n\t\t\timg[ pf.ns ].curSrc = src;\n\t\t\timg[ pf.ns ].curCan = candidate;\n\n\t\t\tif ( !candidate.res ) {\n\t\t\t\tsetResolution( candidate, candidate.set.sizes );\n\t\t\t}\n\t\t}\n\t\treturn candidate;\n\t}\n\n\tfunction getCandidateForSrc( src, set ) {\n\t\tvar i, candidate, candidates;\n\t\tif ( src && set ) {\n\t\t\tcandidates = pf.parseSet( set );\n\t\t\tsrc = pf.makeUrl(src);\n\t\t\tfor ( i = 0; i < candidates.length; i++ ) {\n\t\t\t\tif ( src === pf.makeUrl(candidates[ i ].url) ) {\n\t\t\t\t\tcandidate = candidates[ i ];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn candidate;\n\t}\n\n\tfunction getAllSourceElements( picture, candidates ) {\n\t\tvar i, len, source, srcset;\n\n\t\t// SPEC mismatch intended for size and perf:\n\t\t// actually only source elements preceding the img should be used\n\t\t// also note: don't use qsa here, because IE8 sometimes doesn't like source as the key part in a selector\n\t\tvar sources = picture.getElementsByTagName( \"source\" );\n\n\t\tfor ( i = 0, len = sources.length; i < len; i++ ) {\n\t\t\tsource = sources[ i ];\n\t\t\tsource[ pf.ns ] = true;\n\t\t\tsrcset = source.getAttribute( \"srcset\" );\n\n\t\t\t// if source does not have a srcset attribute, skip\n\t\t\tif ( srcset ) {\n\t\t\t\tcandidates.push( {\n\t\t\t\t\tsrcset: srcset,\n\t\t\t\t\tmedia: source.getAttribute( \"media\" ),\n\t\t\t\t\ttype: source.getAttribute( \"type\" ),\n\t\t\t\t\tsizes: source.getAttribute( \"sizes\" )\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Srcset Parser\n\t * By Alex Bell |  MIT License\n\t *\n\t * @returns Array [{url: _, d: _, w: _, h:_, set:_(????)}, ...]\n\t *\n\t * Based super duper closely on the reference algorithm at:\n\t * https://html.spec.whatwg.org/multipage/embedded-content.html#parse-a-srcset-attribute\n\t */\n\n\t// 1. Let input be the value passed to this algorithm.\n\t// (TO-DO : Explain what \"set\" argument is here. Maybe choose a more\n\t// descriptive & more searchable name.  Since passing the \"set\" in really has\n\t// nothing to do with parsing proper, I would prefer this assignment eventually\n\t// go in an external fn.)\n\tfunction parseSrcset(input, set) {\n\n\t\tfunction collectCharacters(regEx) {\n\t\t\tvar chars,\n\t\t\t    match = regEx.exec(input.substring(pos));\n\t\t\tif (match) {\n\t\t\t\tchars = match[ 0 ];\n\t\t\t\tpos += chars.length;\n\t\t\t\treturn chars;\n\t\t\t}\n\t\t}\n\n\t\tvar inputLength = input.length,\n\t\t    url,\n\t\t    descriptors,\n\t\t    currentDescriptor,\n\t\t    state,\n\t\t    c,\n\n\t\t    // 2. Let position be a pointer into input, initially pointing at the start\n\t\t    //    of the string.\n\t\t    pos = 0,\n\n\t\t    // 3. Let candidates be an initially empty source set.\n\t\t    candidates = [];\n\n\t\t/**\n\t\t* Adds descriptor properties to a candidate, pushes to the candidates array\n\t\t* @return undefined\n\t\t*/\n\t\t// (Declared outside of the while loop so that it's only created once.\n\t\t// (This fn is defined before it is used, in order to pass JSHINT.\n\t\t// Unfortunately this breaks the sequencing of the spec comments. :/ )\n\t\tfunction parseDescriptors() {\n\n\t\t\t// 9. Descriptor parser: Let error be no.\n\t\t\tvar pError = false,\n\n\t\t\t// 10. Let width be absent.\n\t\t\t// 11. Let density be absent.\n\t\t\t// 12. Let future-compat-h be absent. (We're implementing it now as h)\n\t\t\t    w, d, h, i,\n\t\t\t    candidate = {},\n\t\t\t    desc, lastChar, value, intVal, floatVal;\n\n\t\t\t// 13. For each descriptor in descriptors, run the appropriate set of steps\n\t\t\t// from the following list:\n\t\t\tfor (i = 0 ; i < descriptors.length; i++) {\n\t\t\t\tdesc = descriptors[ i ];\n\n\t\t\t\tlastChar = desc[ desc.length - 1 ];\n\t\t\t\tvalue = desc.substring(0, desc.length - 1);\n\t\t\t\tintVal = parseInt(value, 10);\n\t\t\t\tfloatVal = parseFloat(value);\n\n\t\t\t\t// If the descriptor consists of a valid non-negative integer followed by\n\t\t\t\t// a U+0077 LATIN SMALL LETTER W character\n\t\t\t\tif (regexNonNegativeInteger.test(value) && (lastChar === \"w\")) {\n\n\t\t\t\t\t// If width and density are not both absent, then let error be yes.\n\t\t\t\t\tif (w || d) {pError = true;}\n\n\t\t\t\t\t// Apply the rules for parsing non-negative integers to the descriptor.\n\t\t\t\t\t// If the result is zero, let error be yes.\n\t\t\t\t\t// Otherwise, let width be the result.\n\t\t\t\t\tif (intVal === 0) {pError = true;} else {w = intVal;}\n\n\t\t\t\t// If the descriptor consists of a valid floating-point number followed by\n\t\t\t\t// a U+0078 LATIN SMALL LETTER X character\n\t\t\t\t} else if (regexFloatingPoint.test(value) && (lastChar === \"x\")) {\n\n\t\t\t\t\t// If width, density and future-compat-h are not all absent, then let error\n\t\t\t\t\t// be yes.\n\t\t\t\t\tif (w || d || h) {pError = true;}\n\n\t\t\t\t\t// Apply the rules for parsing floating-point number values to the descriptor.\n\t\t\t\t\t// If the result is less than zero, let error be yes. Otherwise, let density\n\t\t\t\t\t// be the result.\n\t\t\t\t\tif (floatVal < 0) {pError = true;} else {d = floatVal;}\n\n\t\t\t\t// If the descriptor consists of a valid non-negative integer followed by\n\t\t\t\t// a U+0068 LATIN SMALL LETTER H character\n\t\t\t\t} else if (regexNonNegativeInteger.test(value) && (lastChar === \"h\")) {\n\n\t\t\t\t\t// If height and density are not both absent, then let error be yes.\n\t\t\t\t\tif (h || d) {pError = true;}\n\n\t\t\t\t\t// Apply the rules for parsing non-negative integers to the descriptor.\n\t\t\t\t\t// If the result is zero, let error be yes. Otherwise, let future-compat-h\n\t\t\t\t\t// be the result.\n\t\t\t\t\tif (intVal === 0) {pError = true;} else {h = intVal;}\n\n\t\t\t\t// Anything else, Let error be yes.\n\t\t\t\t} else {pError = true;}\n\t\t\t} // (close step 13 for loop)\n\n\t\t\t// 15. If error is still no, then append a new image source to candidates whose\n\t\t\t// URL is url, associated with a width width if not absent and a pixel\n\t\t\t// density density if not absent. Otherwise, there is a parse error.\n\t\t\tif (!pError) {\n\t\t\t\tcandidate.url = url;\n\n\t\t\t\tif (w) { candidate.w = w;}\n\t\t\t\tif (d) { candidate.d = d;}\n\t\t\t\tif (h) { candidate.h = h;}\n\t\t\t\tif (!h && !d && !w) {candidate.d = 1;}\n\t\t\t\tif (candidate.d === 1) {set.has1x = true;}\n\t\t\t\tcandidate.set = set;\n\n\t\t\t\tcandidates.push(candidate);\n\t\t\t}\n\t\t} // (close parseDescriptors fn)\n\n\t\t/**\n\t\t* Tokenizes descriptor properties prior to parsing\n\t\t* Returns undefined.\n\t\t* (Again, this fn is defined before it is used, in order to pass JSHINT.\n\t\t* Unfortunately this breaks the logical sequencing of the spec comments. :/ )\n\t\t*/\n\t\tfunction tokenize() {\n\n\t\t\t// 8.1. Descriptor tokeniser: Skip whitespace\n\t\t\tcollectCharacters(regexLeadingSpaces);\n\n\t\t\t// 8.2. Let current descriptor be the empty string.\n\t\t\tcurrentDescriptor = \"\";\n\n\t\t\t// 8.3. Let state be in descriptor.\n\t\t\tstate = \"in descriptor\";\n\n\t\t\twhile (true) {\n\n\t\t\t\t// 8.4. Let c be the character at position.\n\t\t\t\tc = input.charAt(pos);\n\n\t\t\t\t//  Do the following depending on the value of state.\n\t\t\t\t//  For the purpose of this step, \"EOF\" is a special character representing\n\t\t\t\t//  that position is past the end of input.\n\n\t\t\t\t// In descriptor\n\t\t\t\tif (state === \"in descriptor\") {\n\t\t\t\t\t// Do the following, depending on the value of c:\n\n\t\t\t\t  // Space character\n\t\t\t\t  // If current descriptor is not empty, append current descriptor to\n\t\t\t\t  // descriptors and let current descriptor be the empty string.\n\t\t\t\t  // Set state to after descriptor.\n\t\t\t\t\tif (isSpace(c)) {\n\t\t\t\t\t\tif (currentDescriptor) {\n\t\t\t\t\t\t\tdescriptors.push(currentDescriptor);\n\t\t\t\t\t\t\tcurrentDescriptor = \"\";\n\t\t\t\t\t\t\tstate = \"after descriptor\";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// U+002C COMMA (,)\n\t\t\t\t\t// Advance position to the next character in input. If current descriptor\n\t\t\t\t\t// is not empty, append current descriptor to descriptors. Jump to the step\n\t\t\t\t\t// labeled descriptor parser.\n\t\t\t\t\t} else if (c === \",\") {\n\t\t\t\t\t\tpos += 1;\n\t\t\t\t\t\tif (currentDescriptor) {\n\t\t\t\t\t\t\tdescriptors.push(currentDescriptor);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparseDescriptors();\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t// U+0028 LEFT PARENTHESIS (()\n\t\t\t\t\t// Append c to current descriptor. Set state to in parens.\n\t\t\t\t\t} else if (c === \"\\u0028\") {\n\t\t\t\t\t\tcurrentDescriptor = currentDescriptor + c;\n\t\t\t\t\t\tstate = \"in parens\";\n\n\t\t\t\t\t// EOF\n\t\t\t\t\t// If current descriptor is not empty, append current descriptor to\n\t\t\t\t\t// descriptors. Jump to the step labeled descriptor parser.\n\t\t\t\t\t} else if (c === \"\") {\n\t\t\t\t\t\tif (currentDescriptor) {\n\t\t\t\t\t\t\tdescriptors.push(currentDescriptor);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparseDescriptors();\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t// Anything else\n\t\t\t\t\t// Append c to current descriptor.\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrentDescriptor = currentDescriptor + c;\n\t\t\t\t\t}\n\t\t\t\t// (end \"in descriptor\"\n\n\t\t\t\t// In parens\n\t\t\t\t} else if (state === \"in parens\") {\n\n\t\t\t\t\t// U+0029 RIGHT PARENTHESIS ())\n\t\t\t\t\t// Append c to current descriptor. Set state to in descriptor.\n\t\t\t\t\tif (c === \")\") {\n\t\t\t\t\t\tcurrentDescriptor = currentDescriptor + c;\n\t\t\t\t\t\tstate = \"in descriptor\";\n\n\t\t\t\t\t// EOF\n\t\t\t\t\t// Append current descriptor to descriptors. Jump to the step labeled\n\t\t\t\t\t// descriptor parser.\n\t\t\t\t\t} else if (c === \"\") {\n\t\t\t\t\t\tdescriptors.push(currentDescriptor);\n\t\t\t\t\t\tparseDescriptors();\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t// Anything else\n\t\t\t\t\t// Append c to current descriptor.\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrentDescriptor = currentDescriptor + c;\n\t\t\t\t\t}\n\n\t\t\t\t// After descriptor\n\t\t\t\t} else if (state === \"after descriptor\") {\n\n\t\t\t\t\t// Do the following, depending on the value of c:\n\t\t\t\t\t// Space character: Stay in this state.\n\t\t\t\t\tif (isSpace(c)) {\n\n\t\t\t\t\t// EOF: Jump to the step labeled descriptor parser.\n\t\t\t\t\t} else if (c === \"\") {\n\t\t\t\t\t\tparseDescriptors();\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t// Anything else\n\t\t\t\t\t// Set state to in descriptor. Set position to the previous character in input.\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstate = \"in descriptor\";\n\t\t\t\t\t\tpos -= 1;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Advance position to the next character in input.\n\t\t\t\tpos += 1;\n\n\t\t\t// Repeat this step.\n\t\t\t} // (close while true loop)\n\t\t}\n\n\t\t// 4. Splitting loop: Collect a sequence of characters that are space\n\t\t//    characters or U+002C COMMA characters. If any U+002C COMMA characters\n\t\t//    were collected, that is a parse error.\n\t\twhile (true) {\n\t\t\tcollectCharacters(regexLeadingCommasOrSpaces);\n\n\t\t\t// 5. If position is past the end of input, return candidates and abort these steps.\n\t\t\tif (pos >= inputLength) {\n\t\t\t\treturn candidates; // (we're done, this is the sole return path)\n\t\t\t}\n\n\t\t\t// 6. Collect a sequence of characters that are not space characters,\n\t\t\t//    and let that be url.\n\t\t\turl = collectCharacters(regexLeadingNotSpaces);\n\n\t\t\t// 7. Let descriptors be a new empty list.\n\t\t\tdescriptors = [];\n\n\t\t\t// 8. If url ends with a U+002C COMMA character (,), follow these substeps:\n\t\t\t//\t\t(1). Remove all trailing U+002C COMMA characters from url. If this removed\n\t\t\t//         more than one character, that is a parse error.\n\t\t\tif (url.slice(-1) === \",\") {\n\t\t\t\turl = url.replace(regexTrailingCommas, \"\");\n\t\t\t\t// (Jump ahead to step 9 to skip tokenization and just push the candidate).\n\t\t\t\tparseDescriptors();\n\n\t\t\t//\tOtherwise, follow these substeps:\n\t\t\t} else {\n\t\t\t\ttokenize();\n\t\t\t} // (close else of step 8)\n\n\t\t// 16. Return to the step labeled splitting loop.\n\t\t} // (Close of big while loop.)\n\t}\n\n\t/*\n\t * Sizes Parser\n\t *\n\t * By Alex Bell |  MIT License\n\t *\n\t * Non-strict but accurate and lightweight JS Parser for the string value <img sizes=\"here\">\n\t *\n\t * Reference algorithm at:\n\t * https://html.spec.whatwg.org/multipage/embedded-content.html#parse-a-sizes-attribute\n\t *\n\t * Most comments are copied in directly from the spec\n\t * (except for comments in parens).\n\t *\n\t * Grammar is:\n\t * <source-size-list> = <source-size># [ , <source-size-value> ]? | <source-size-value>\n\t * <source-size> = <media-condition> <source-size-value>\n\t * <source-size-value> = <length>\n\t * http://www.w3.org/html/wg/drafts/html/master/embedded-content.html#attr-img-sizes\n\t *\n\t * E.g. \"(max-width: 30em) 100vw, (max-width: 50em) 70vw, 100vw\"\n\t * or \"(min-width: 30em), calc(30vw - 15px)\" or just \"30vw\"\n\t *\n\t * Returns the first valid <css-length> with a media condition that evaluates to true,\n\t * or \"100vw\" if all valid media conditions evaluate to false.\n\t *\n\t */\n\n\tfunction parseSizes(strValue) {\n\n\t\t// (Percentage CSS lengths are not allowed in this case, to avoid confusion:\n\t\t// https://html.spec.whatwg.org/multipage/embedded-content.html#valid-source-size-list\n\t\t// CSS allows a single optional plus or minus sign:\n\t\t// http://www.w3.org/TR/CSS2/syndata.html#numbers\n\t\t// CSS is ASCII case-insensitive:\n\t\t// http://www.w3.org/TR/CSS2/syndata.html#characters )\n\t\t// Spec allows exponential notation for <number> type:\n\t\t// http://dev.w3.org/csswg/css-values/#numbers\n\t\tvar regexCssLengthWithUnits = /^(?:[+-]?[0-9]+|[0-9]*\\.[0-9]+)(?:[eE][+-]?[0-9]+)?(?:ch|cm|em|ex|in|mm|pc|pt|px|rem|vh|vmin|vmax|vw)$/i;\n\n\t\t// (This is a quick and lenient test. Because of optional unlimited-depth internal\n\t\t// grouping parens and strict spacing rules, this could get very complicated.)\n\t\tvar regexCssCalc = /^calc\\((?:[0-9a-z \\.\\+\\-\\*\\/\\(\\)]+)\\)$/i;\n\n\t\tvar i;\n\t\tvar unparsedSizesList;\n\t\tvar unparsedSizesListLength;\n\t\tvar unparsedSize;\n\t\tvar lastComponentValue;\n\t\tvar size;\n\n\t\t// UTILITY FUNCTIONS\n\n\t\t//  (Toy CSS parser. The goals here are:\n\t\t//  1) expansive test coverage without the weight of a full CSS parser.\n\t\t//  2) Avoiding regex wherever convenient.\n\t\t//  Quick tests: http://jsfiddle.net/gtntL4gr/3/\n\t\t//  Returns an array of arrays.)\n\t\tfunction parseComponentValues(str) {\n\t\t\tvar chrctr;\n\t\t\tvar component = \"\";\n\t\t\tvar componentArray = [];\n\t\t\tvar listArray = [];\n\t\t\tvar parenDepth = 0;\n\t\t\tvar pos = 0;\n\t\t\tvar inComment = false;\n\n\t\t\tfunction pushComponent() {\n\t\t\t\tif (component) {\n\t\t\t\t\tcomponentArray.push(component);\n\t\t\t\t\tcomponent = \"\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction pushComponentArray() {\n\t\t\t\tif (componentArray[0]) {\n\t\t\t\t\tlistArray.push(componentArray);\n\t\t\t\t\tcomponentArray = [];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// (Loop forwards from the beginning of the string.)\n\t\t\twhile (true) {\n\t\t\t\tchrctr = str.charAt(pos);\n\n\t\t\t\tif (chrctr === \"\") { // ( End of string reached.)\n\t\t\t\t\tpushComponent();\n\t\t\t\t\tpushComponentArray();\n\t\t\t\t\treturn listArray;\n\t\t\t\t} else if (inComment) {\n\t\t\t\t\tif ((chrctr === \"*\") && (str[pos + 1] === \"/\")) { // (At end of a comment.)\n\t\t\t\t\t\tinComment = false;\n\t\t\t\t\t\tpos += 2;\n\t\t\t\t\t\tpushComponent();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpos += 1; // (Skip all characters inside comments.)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} else if (isSpace(chrctr)) {\n\t\t\t\t\t// (If previous character in loop was also a space, or if\n\t\t\t\t\t// at the beginning of the string, do not add space char to\n\t\t\t\t\t// component.)\n\t\t\t\t\tif ( (str.charAt(pos - 1) && isSpace( str.charAt(pos - 1) ) ) || !component ) {\n\t\t\t\t\t\tpos += 1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (parenDepth === 0) {\n\t\t\t\t\t\tpushComponent();\n\t\t\t\t\t\tpos +=1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// (Replace any space character with a plain space for legibility.)\n\t\t\t\t\t\tchrctr = \" \";\n\t\t\t\t\t}\n\t\t\t\t} else if (chrctr === \"(\") {\n\t\t\t\t\tparenDepth += 1;\n\t\t\t\t} else if (chrctr === \")\") {\n\t\t\t\t\tparenDepth -= 1;\n\t\t\t\t} else if (chrctr === \",\") {\n\t\t\t\t\tpushComponent();\n\t\t\t\t\tpushComponentArray();\n\t\t\t\t\tpos += 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if ( (chrctr === \"/\") && (str.charAt(pos + 1) === \"*\") ) {\n\t\t\t\t\tinComment = true;\n\t\t\t\t\tpos += 2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tcomponent = component + chrctr;\n\t\t\t\tpos += 1;\n\t\t\t}\n\t\t}\n\n\t\tfunction isValidNonNegativeSourceSizeValue(s) {\n\t\t\tif (regexCssLengthWithUnits.test(s) && (parseFloat(s) >= 0)) {return true;}\n\t\t\tif (regexCssCalc.test(s)) {return true;}\n\t\t\t// ( http://www.w3.org/TR/CSS2/syndata.html#numbers says:\n\t\t\t// \"-0 is equivalent to 0 and is not a negative number.\" which means that\n\t\t\t// unitless zero and unitless negative zero must be accepted as special cases.)\n\t\t\tif ((s === \"0\") || (s === \"-0\") || (s === \"+0\")) {return true;}\n\t\t\treturn false;\n\t\t}\n\n\t\t// When asked to parse a sizes attribute from an element, parse a\n\t\t// comma-separated list of component values from the value of the element's\n\t\t// sizes attribute (or the empty string, if the attribute is absent), and let\n\t\t// unparsed sizes list be the result.\n\t\t// http://dev.w3.org/csswg/css-syntax/#parse-comma-separated-list-of-component-values\n\n\t\tunparsedSizesList = parseComponentValues(strValue);\n\t\tunparsedSizesListLength = unparsedSizesList.length;\n\n\t\t// For each unparsed size in unparsed sizes list:\n\t\tfor (i = 0; i < unparsedSizesListLength; i++) {\n\t\t\tunparsedSize = unparsedSizesList[i];\n\n\t\t\t// 1. Remove all consecutive <whitespace-token>s from the end of unparsed size.\n\t\t\t// ( parseComponentValues() already omits spaces outside of parens. )\n\n\t\t\t// If unparsed size is now empty, that is a parse error; continue to the next\n\t\t\t// iteration of this algorithm.\n\t\t\t// ( parseComponentValues() won't push an empty array. )\n\n\t\t\t// 2. If the last component value in unparsed size is a valid non-negative\n\t\t\t// <source-size-value>, let size be its value and remove the component value\n\t\t\t// from unparsed size. Any CSS function other than the calc() function is\n\t\t\t// invalid. Otherwise, there is a parse error; continue to the next iteration\n\t\t\t// of this algorithm.\n\t\t\t// http://dev.w3.org/csswg/css-syntax/#parse-component-value\n\t\t\tlastComponentValue = unparsedSize[unparsedSize.length - 1];\n\n\t\t\tif (isValidNonNegativeSourceSizeValue(lastComponentValue)) {\n\t\t\t\tsize = lastComponentValue;\n\t\t\t\tunparsedSize.pop();\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// 3. Remove all consecutive <whitespace-token>s from the end of unparsed\n\t\t\t// size. If unparsed size is now empty, return size and exit this algorithm.\n\t\t\t// If this was not the last item in unparsed sizes list, that is a parse error.\n\t\t\tif (unparsedSize.length === 0) {\n\t\t\t\treturn size;\n\t\t\t}\n\n\t\t\t// 4. Parse the remaining component values in unparsed size as a\n\t\t\t// <media-condition>. If it does not parse correctly, or it does parse\n\t\t\t// correctly but the <media-condition> evaluates to false, continue to the\n\t\t\t// next iteration of this algorithm.\n\t\t\t// (Parsing all possible compound media conditions in JS is heavy, complicated,\n\t\t\t// and the payoff is unclear. Is there ever an situation where the\n\t\t\t// media condition parses incorrectly but still somehow evaluates to true?\n\t\t\t// Can we just rely on the browser/polyfill to do it?)\n\t\t\tunparsedSize = unparsedSize.join(\" \");\n\t\t\tif (!(pf.matchesMedia( unparsedSize ) ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// 5. Return size and exit this algorithm.\n\t\t\treturn size;\n\t\t}\n\n\t\t// If the above algorithm exhausts unparsed sizes list without returning a\n\t\t// size value, return 100vw.\n\t\treturn \"100vw\";\n\t}\n\n\t// namespace\n\tpf.ns = (\"pf\" + new Date().getTime()).substr(0, 9);\n\n\t// srcset support test\n\tpf.supSrcset = \"srcset\" in image;\n\tpf.supSizes = \"sizes\" in image;\n\tpf.supPicture = !!window.HTMLPictureElement;\n\n\t// UC browser does claim to support srcset and picture, but not sizes,\n\t// this extended test reveals the browser does support nothing\n\tif (pf.supSrcset && pf.supPicture && !pf.supSizes) {\n\t\t(function(image2) {\n\t\t\timage.srcset = \"data:,a\";\n\t\t\timage2.src = \"data:,a\";\n\t\t\tpf.supSrcset = image.complete === image2.complete;\n\t\t\tpf.supPicture = pf.supSrcset && pf.supPicture;\n\t\t})(document.createElement(\"img\"));\n\t}\n\n\t// Safari9 has basic support for sizes, but does't expose the `sizes` idl attribute\n\tif (pf.supSrcset && !pf.supSizes) {\n\n\t\t(function() {\n\t\t\tvar width2 = \"data:image/gif;base64,R0lGODlhAgABAPAAAP///wAAACH5BAAAAAAALAAAAAACAAEAAAICBAoAOw==\";\n\t\t\tvar width1 = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n\t\t\tvar img = document.createElement(\"img\");\n\t\t\tvar test = function() {\n\t\t\t\tvar width = img.width;\n\n\t\t\t\tif (width === 2) {\n\t\t\t\t\tpf.supSizes = true;\n\t\t\t\t}\n\n\t\t\t\talwaysCheckWDescriptor = pf.supSrcset && !pf.supSizes;\n\n\t\t\t\tisSupportTestReady = true;\n\t\t\t\t// force async\n\t\t\t\tsetTimeout(picturefill);\n\t\t\t};\n\n\t\t\timg.onload = test;\n\t\t\timg.onerror = test;\n\t\t\timg.setAttribute(\"sizes\", \"9px\");\n\n\t\t\timg.srcset = width1 + \" 1w,\" + width2 + \" 9w\";\n\t\t\timg.src = width1;\n\t\t})();\n\n\t} else {\n\t\tisSupportTestReady = true;\n\t}\n\n\t// using pf.qsa instead of dom traversing does scale much better,\n\t// especially on sites mixing responsive and non-responsive images\n\tpf.selShort = \"picture>img,img[srcset]\";\n\tpf.sel = pf.selShort;\n\tpf.cfg = cfg;\n\n\t/**\n\t * Shortcut property for `devicePixelRatio` ( for easy overriding in tests )\n\t */\n\tpf.DPR = (DPR  || 1 );\n\tpf.u = units;\n\n\t// container of supported mime types that one might need to qualify before using\n\tpf.types =  types;\n\n\tpf.setSize = noop;\n\n\t/**\n\t * Gets a string and returns the absolute URL\n\t * @param src\n\t * @returns {String} absolute URL\n\t */\n\n\tpf.makeUrl = memoize(function(src) {\n\t\tanchor.href = src;\n\t\treturn anchor.href;\n\t});\n\n\t/**\n\t * Gets a DOM element or document and a selctor and returns the found matches\n\t * Can be extended with jQuery/Sizzle for IE7 support\n\t * @param context\n\t * @param sel\n\t * @returns {NodeList|Array}\n\t */\n\tpf.qsa = function(context, sel) {\n\t\treturn ( \"querySelector\" in context ) ? context.querySelectorAll(sel) : [];\n\t};\n\n\t/**\n\t * Shortcut method for matchMedia ( for easy overriding in tests )\n\t * wether native or pf.mMQ is used will be decided lazy on first call\n\t * @returns {boolean}\n\t */\n\tpf.matchesMedia = function() {\n\t\tif ( window.matchMedia && (matchMedia( \"(min-width: 0.1em)\" ) || {}).matches ) {\n\t\t\tpf.matchesMedia = function( media ) {\n\t\t\t\treturn !media || ( matchMedia( media ).matches );\n\t\t\t};\n\t\t} else {\n\t\t\tpf.matchesMedia = pf.mMQ;\n\t\t}\n\n\t\treturn pf.matchesMedia.apply( this, arguments );\n\t};\n\n\t/**\n\t * A simplified matchMedia implementation for IE8 and IE9\n\t * handles only min-width/max-width with px or em values\n\t * @param media\n\t * @returns {boolean}\n\t */\n\tpf.mMQ = function( media ) {\n\t\treturn media ? evalCSS(media) : true;\n\t};\n\n\t/**\n\t * Returns the calculated length in css pixel from the given sourceSizeValue\n\t * http://dev.w3.org/csswg/css-values-3/#length-value\n\t * intended Spec mismatches:\n\t * * Does not check for invalid use of CSS functions\n\t * * Does handle a computed length of 0 the same as a negative and therefore invalid value\n\t * @param sourceSizeValue\n\t * @returns {Number}\n\t */\n\tpf.calcLength = function( sourceSizeValue ) {\n\n\t\tvar value = evalCSS(sourceSizeValue, true) || false;\n\t\tif (value < 0) {\n\t\t\tvalue = false;\n\t\t}\n\n\t\treturn value;\n\t};\n\n\t/**\n\t * Takes a type string and checks if its supported\n\t */\n\n\tpf.supportsType = function( type ) {\n\t\treturn ( type ) ? types[ type ] : true;\n\t};\n\n\t/**\n\t * Parses a sourceSize into mediaCondition (media) and sourceSizeValue (length)\n\t * @param sourceSizeStr\n\t * @returns {*}\n\t */\n\tpf.parseSize = memoize(function( sourceSizeStr ) {\n\t\tvar match = ( sourceSizeStr || \"\" ).match(regSize);\n\t\treturn {\n\t\t\tmedia: match && match[1],\n\t\t\tlength: match && match[2]\n\t\t};\n\t});\n\n\tpf.parseSet = function( set ) {\n\t\tif ( !set.cands ) {\n\t\t\tset.cands = parseSrcset(set.srcset, set);\n\t\t}\n\t\treturn set.cands;\n\t};\n\n\t/**\n\t * returns 1em in css px for html/body default size\n\t * function taken from respondjs\n\t * @returns {*|number}\n\t */\n\tpf.getEmValue = function() {\n\t\tvar body;\n\t\tif ( !eminpx && (body = document.body) ) {\n\t\t\tvar div = document.createElement( \"div\" ),\n\t\t\t\toriginalHTMLCSS = docElem.style.cssText,\n\t\t\t\toriginalBodyCSS = body.style.cssText;\n\n\t\t\tdiv.style.cssText = baseStyle;\n\n\t\t\t// 1em in a media query is the value of the default font size of the browser\n\t\t\t// reset docElem and body to ensure the correct value is returned\n\t\t\tdocElem.style.cssText = fsCss;\n\t\t\tbody.style.cssText = fsCss;\n\n\t\t\tbody.appendChild( div );\n\t\t\teminpx = div.offsetWidth;\n\t\t\tbody.removeChild( div );\n\n\t\t\t//also update eminpx before returning\n\t\t\teminpx = parseFloat( eminpx, 10 );\n\n\t\t\t// restore the original values\n\t\t\tdocElem.style.cssText = originalHTMLCSS;\n\t\t\tbody.style.cssText = originalBodyCSS;\n\n\t\t}\n\t\treturn eminpx || 16;\n\t};\n\n\t/**\n\t * Takes a string of sizes and returns the width in pixels as a number\n\t */\n\tpf.calcListLength = function( sourceSizeListStr ) {\n\t\t// Split up source size list, ie ( max-width: 30em ) 100%, ( max-width: 50em ) 50%, 33%\n\t\t//\n\t\t//                           or (min-width:30em) calc(30% - 15px)\n\t\tif ( !(sourceSizeListStr in sizeLengthCache) || cfg.uT ) {\n\t\t\tvar winningLength = pf.calcLength( parseSizes( sourceSizeListStr ) );\n\n\t\t\tsizeLengthCache[ sourceSizeListStr ] = !winningLength ? units.width : winningLength;\n\t\t}\n\n\t\treturn sizeLengthCache[ sourceSizeListStr ];\n\t};\n\n\t/**\n\t * Takes a candidate object with a srcset property in the form of url/\n\t * ex. \"images/pic-medium.png 1x, images/pic-medium-2x.png 2x\" or\n\t *     \"images/pic-medium.png 400w, images/pic-medium-2x.png 800w\" or\n\t *     \"images/pic-small.png\"\n\t * Get an array of image candidates in the form of\n\t *      {url: \"/foo/bar.png\", resolution: 1}\n\t * where resolution is http://dev.w3.org/csswg/css-values-3/#resolution-value\n\t * If sizes is specified, res is calculated\n\t */\n\tpf.setRes = function( set ) {\n\t\tvar candidates;\n\t\tif ( set ) {\n\n\t\t\tcandidates = pf.parseSet( set );\n\n\t\t\tfor ( var i = 0, len = candidates.length; i < len; i++ ) {\n\t\t\t\tsetResolution( candidates[ i ], set.sizes );\n\t\t\t}\n\t\t}\n\t\treturn candidates;\n\t};\n\n\tpf.setRes.res = setResolution;\n\n\tpf.applySetCandidate = function( candidates, img ) {\n\t\tif ( !candidates.length ) {return;}\n\t\tvar candidate,\n\t\t\ti,\n\t\t\tj,\n\t\t\tlength,\n\t\t\tbestCandidate,\n\t\t\tcurSrc,\n\t\t\tcurCan,\n\t\t\tcandidateSrc,\n\t\t\tabortCurSrc;\n\n\t\tvar imageData = img[ pf.ns ];\n\t\tvar dpr = pf.DPR;\n\n\t\tcurSrc = imageData.curSrc || img[curSrcProp];\n\n\t\tcurCan = imageData.curCan || setSrcToCur(img, curSrc, candidates[0].set);\n\n\t\t// if we have a current source, we might either become lazy or give this source some advantage\n\t\tif ( curCan && curCan.set === candidates[ 0 ].set ) {\n\n\t\t\t// if browser can abort image request and the image has a higher pixel density than needed\n\t\t\t// and this image isn't downloaded yet, we skip next part and try to save bandwidth\n\t\t\tabortCurSrc = (supportAbort && !img.complete && curCan.res - 0.1 > dpr);\n\n\t\t\tif ( !abortCurSrc ) {\n\t\t\t\tcurCan.cached = true;\n\n\t\t\t\t// if current candidate is \"best\", \"better\" or \"okay\",\n\t\t\t\t// set it to bestCandidate\n\t\t\t\tif ( curCan.res >= dpr ) {\n\t\t\t\t\tbestCandidate = curCan;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( !bestCandidate ) {\n\n\t\t\tcandidates.sort( ascendingSort );\n\n\t\t\tlength = candidates.length;\n\t\t\tbestCandidate = candidates[ length - 1 ];\n\n\t\t\tfor ( i = 0; i < length; i++ ) {\n\t\t\t\tcandidate = candidates[ i ];\n\t\t\t\tif ( candidate.res >= dpr ) {\n\t\t\t\t\tj = i - 1;\n\n\t\t\t\t\t// we have found the perfect candidate,\n\t\t\t\t\t// but let's improve this a little bit with some assumptions ;-)\n\t\t\t\t\tif (candidates[ j ] &&\n\t\t\t\t\t\t(abortCurSrc || curSrc !== pf.makeUrl( candidate.url )) &&\n\t\t\t\t\t\tchooseLowRes(candidates[ j ].res, candidate.res, dpr, candidates[ j ].cached)) {\n\n\t\t\t\t\t\tbestCandidate = candidates[ j ];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbestCandidate = candidate;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( bestCandidate ) {\n\n\t\t\tcandidateSrc = pf.makeUrl( bestCandidate.url );\n\n\t\t\timageData.curSrc = candidateSrc;\n\t\t\timageData.curCan = bestCandidate;\n\n\t\t\tif ( candidateSrc !== curSrc ) {\n\t\t\t\tpf.setSrc( img, bestCandidate );\n\t\t\t}\n\t\t\tpf.setSize( img );\n\t\t}\n\t};\n\n\tpf.setSrc = function( img, bestCandidate ) {\n\t\tvar origWidth;\n\t\timg.src = bestCandidate.url;\n\n\t\t// although this is a specific Safari issue, we don't want to take too much different code paths\n\t\tif ( bestCandidate.set.type === \"image/svg+xml\" ) {\n\t\t\torigWidth = img.style.width;\n\t\t\timg.style.width = (img.offsetWidth + 1) + \"px\";\n\n\t\t\t// next line only should trigger a repaint\n\t\t\t// if... is only done to trick dead code removal\n\t\t\tif ( img.offsetWidth + 1 ) {\n\t\t\t\timg.style.width = origWidth;\n\t\t\t}\n\t\t}\n\t};\n\n\tpf.getSet = function( img ) {\n\t\tvar i, set, supportsType;\n\t\tvar match = false;\n\t\tvar sets = img [ pf.ns ].sets;\n\n\t\tfor ( i = 0; i < sets.length && !match; i++ ) {\n\t\t\tset = sets[i];\n\n\t\t\tif ( !set.srcset || !pf.matchesMedia( set.media ) || !(supportsType = pf.supportsType( set.type )) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( supportsType === \"pending\" ) {\n\t\t\t\tset = supportsType;\n\t\t\t}\n\n\t\t\tmatch = set;\n\t\t\tbreak;\n\t\t}\n\n\t\treturn match;\n\t};\n\n\tpf.parseSets = function( element, parent, options ) {\n\t\tvar srcsetAttribute, imageSet, isWDescripor, srcsetParsed;\n\n\t\tvar hasPicture = parent && parent.nodeName.toUpperCase() === \"PICTURE\";\n\t\tvar imageData = element[ pf.ns ];\n\n\t\tif ( imageData.src === undefined || options.src ) {\n\t\t\timageData.src = getImgAttr.call( element, \"src\" );\n\t\t\tif ( imageData.src ) {\n\t\t\t\tsetImgAttr.call( element, srcAttr, imageData.src );\n\t\t\t} else {\n\t\t\t\tremoveImgAttr.call( element, srcAttr );\n\t\t\t}\n\t\t}\n\n\t\tif ( imageData.srcset === undefined || options.srcset || !pf.supSrcset || element.srcset ) {\n\t\t\tsrcsetAttribute = getImgAttr.call( element, \"srcset\" );\n\t\t\timageData.srcset = srcsetAttribute;\n\t\t\tsrcsetParsed = true;\n\t\t}\n\n\t\timageData.sets = [];\n\n\t\tif ( hasPicture ) {\n\t\t\timageData.pic = true;\n\t\t\tgetAllSourceElements( parent, imageData.sets );\n\t\t}\n\n\t\tif ( imageData.srcset ) {\n\t\t\timageSet = {\n\t\t\t\tsrcset: imageData.srcset,\n\t\t\t\tsizes: getImgAttr.call( element, \"sizes\" )\n\t\t\t};\n\n\t\t\timageData.sets.push( imageSet );\n\n\t\t\tisWDescripor = (alwaysCheckWDescriptor || imageData.src) && regWDesc.test(imageData.srcset || \"\");\n\n\t\t\t// add normal src as candidate, if source has no w descriptor\n\t\t\tif ( !isWDescripor && imageData.src && !getCandidateForSrc(imageData.src, imageSet) && !imageSet.has1x ) {\n\t\t\t\timageSet.srcset += \", \" + imageData.src;\n\t\t\t\timageSet.cands.push({\n\t\t\t\t\turl: imageData.src,\n\t\t\t\t\td: 1,\n\t\t\t\t\tset: imageSet\n\t\t\t\t});\n\t\t\t}\n\n\t\t} else if ( imageData.src ) {\n\t\t\timageData.sets.push( {\n\t\t\t\tsrcset: imageData.src,\n\t\t\t\tsizes: null\n\t\t\t} );\n\t\t}\n\n\t\timageData.curCan = null;\n\t\timageData.curSrc = undefined;\n\n\t\t// if img has picture or the srcset was removed or has a srcset and does not support srcset at all\n\t\t// or has a w descriptor (and does not support sizes) set support to false to evaluate\n\t\timageData.supported = !( hasPicture || ( imageSet && !pf.supSrcset ) || (isWDescripor && !pf.supSizes) );\n\n\t\tif ( srcsetParsed && pf.supSrcset && !imageData.supported ) {\n\t\t\tif ( srcsetAttribute ) {\n\t\t\t\tsetImgAttr.call( element, srcsetAttr, srcsetAttribute );\n\t\t\t\telement.srcset = \"\";\n\t\t\t} else {\n\t\t\t\tremoveImgAttr.call( element, srcsetAttr );\n\t\t\t}\n\t\t}\n\n\t\tif (imageData.supported && !imageData.srcset && ((!imageData.src && element.src) ||  element.src !== pf.makeUrl(imageData.src))) {\n\t\t\tif (imageData.src === null) {\n\t\t\t\telement.removeAttribute(\"src\");\n\t\t\t} else {\n\t\t\t\telement.src = imageData.src;\n\t\t\t}\n\t\t}\n\n\t\timageData.parsed = true;\n\t};\n\n\tpf.fillImg = function(element, options) {\n\t\tvar imageData;\n\t\tvar extreme = options.reselect || options.reevaluate;\n\n\t\t// expando for caching data on the img\n\t\tif ( !element[ pf.ns ] ) {\n\t\t\telement[ pf.ns ] = {};\n\t\t}\n\n\t\timageData = element[ pf.ns ];\n\n\t\t// if the element has already been evaluated, skip it\n\t\t// unless `options.reevaluate` is set to true ( this, for example,\n\t\t// is set to true when running `picturefill` on `resize` ).\n\t\tif ( !extreme && imageData.evaled === evalId ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !imageData.parsed || options.reevaluate ) {\n\t\t\tpf.parseSets( element, element.parentNode, options );\n\t\t}\n\n\t\tif ( !imageData.supported ) {\n\t\t\tapplyBestCandidate( element );\n\t\t} else {\n\t\t\timageData.evaled = evalId;\n\t\t}\n\t};\n\n\tpf.setupRun = function() {\n\t\tif ( !alreadyRun || isVwDirty || (DPR !== window.devicePixelRatio) ) {\n\t\t\tupdateMetrics();\n\t\t}\n\t};\n\n\t// If picture is supported, well, that's awesome.\n\tif ( pf.supPicture ) {\n\t\tpicturefill = noop;\n\t\tpf.fillImg = noop;\n\t} else {\n\n\t\t // Set up picture polyfill by polling the document\n\t\t(function() {\n\t\t\tvar isDomReady;\n\t\t\tvar regReady = window.attachEvent ? /d$|^c/ : /d$|^c|^i/;\n\n\t\t\tvar run = function() {\n\t\t\t\tvar readyState = document.readyState || \"\";\n\n\t\t\t\ttimerId = setTimeout(run, readyState === \"loading\" ? 200 :  999);\n\t\t\t\tif ( document.body ) {\n\t\t\t\t\tpf.fillImgs();\n\t\t\t\t\tisDomReady = isDomReady || regReady.test(readyState);\n\t\t\t\t\tif ( isDomReady ) {\n\t\t\t\t\t\tclearTimeout( timerId );\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tvar timerId = setTimeout(run, document.body ? 9 : 99);\n\n\t\t\t// Also attach picturefill on resize and readystatechange\n\t\t\t// http://modernjavascript.blogspot.com/2013/08/building-better-debounce.html\n\t\t\tvar debounce = function(func, wait) {\n\t\t\t\tvar timeout, timestamp;\n\t\t\t\tvar later = function() {\n\t\t\t\t\tvar last = (new Date()) - timestamp;\n\n\t\t\t\t\tif (last < wait) {\n\t\t\t\t\t\ttimeout = setTimeout(later, wait - last);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttimeout = null;\n\t\t\t\t\t\tfunc();\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\treturn function() {\n\t\t\t\t\ttimestamp = new Date();\n\n\t\t\t\t\tif (!timeout) {\n\t\t\t\t\t\ttimeout = setTimeout(later, wait);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\t\t\tvar lastClientWidth = docElem.clientHeight;\n\t\t\tvar onResize = function() {\n\t\t\t\tisVwDirty = Math.max(window.innerWidth || 0, docElem.clientWidth) !== units.width || docElem.clientHeight !== lastClientWidth;\n\t\t\t\tlastClientWidth = docElem.clientHeight;\n\t\t\t\tif ( isVwDirty ) {\n\t\t\t\t\tpf.fillImgs();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ton( window, \"resize\", debounce(onResize, 99 ) );\n\t\t\ton( document, \"readystatechange\", run );\n\t\t})();\n\t}\n\n\tpf.picturefill = picturefill;\n\t//use this internally for easy monkey patching/performance testing\n\tpf.fillImgs = picturefill;\n\tpf.teardownRun = noop;\n\n\t/* expose methods for testing */\n\tpicturefill._ = pf;\n\n\twindow.picturefillCFG = {\n\t\tpf: pf,\n\t\tpush: function(args) {\n\t\t\tvar name = args.shift();\n\t\t\tif (typeof pf[name] === \"function\") {\n\t\t\t\tpf[name].apply(pf, args);\n\t\t\t} else {\n\t\t\t\tcfg[name] = args[0];\n\t\t\t\tif (alreadyRun) {\n\t\t\t\t\tpf.fillImgs( { reselect: true } );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\twhile (setOptions && setOptions.length) {\n\t\twindow.picturefillCFG.push(setOptions.shift());\n\t}\n\n\t/* expose picturefill */\n\twindow.picturefill = picturefill;\n\n\t/* expose picturefill */\n\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n\t\t// CommonJS, just export\n\t\tmodule.exports = picturefill;\n\t} else if ( true ) {\n\t\t// AMD support\n\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return picturefill; }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\n\n\t// IE8 evals this sync, so it must be the last thing we do\n\tif ( !pf.supPicture ) {\n\t\ttypes[ \"image/webp\" ] = detectTypeSupport(\"image/webp\", \"data:image/webp;base64,UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAABBxAR/Q9ERP8DAABWUDggGAAAADABAJ0BKgEAAQADADQlpAADcAD++/1QAA==\" );\n\t}\n\n} )( window, document );\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGljdHVyZWZpbGwvZGlzdC9waWN0dXJlZmlsbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9waWN0dXJlZmlsbC9kaXN0L3BpY3R1cmVmaWxsLmpzP2VlYzgiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIHBpY3R1cmVmaWxsIC0gdjMuMC4yIC0gMjAxNi0wMi0xMlxuICogaHR0cHM6Ly9zY290dGplaGwuZ2l0aHViLmlvL3BpY3R1cmVmaWxsL1xuICogQ29weXJpZ2h0IChjKSAyMDE2IGh0dHBzOi8vZ2l0aHViLmNvbS9zY290dGplaGwvcGljdHVyZWZpbGwvYmxvYi9tYXN0ZXIvQXV0aG9ycy50eHQ7IExpY2Vuc2VkIE1JVFxuICovXG4vKiEgR2Vja28tUGljdHVyZSAtIHYxLjBcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zY290dGplaGwvcGljdHVyZWZpbGwvdHJlZS8zLjAvc3JjL3BsdWdpbnMvZ2Vja28tcGljdHVyZVxuICogRmlyZWZveCdzIGVhcmx5IHBpY3R1cmUgaW1wbGVtZW50YXRpb24gKHByaW9yIHRvIEZGNDEpIGlzIHN0YXRpYyBhbmQgZG9lc1xuICogbm90IHJlYWN0IHRvIHZpZXdwb3J0IGNoYW5nZXMuIFRoaXMgdGlueSBtb2R1bGUgZml4ZXMgdGhpcy5cbiAqL1xuKGZ1bmN0aW9uKHdpbmRvdykge1xuXHQvKmpzaGludCBlcW51bGw6dHJ1ZSAqL1xuXHR2YXIgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuXG5cdGlmICggd2luZG93LkhUTUxQaWN0dXJlRWxlbWVudCAmJiAoKC9lY2tvLykudGVzdCh1YSkgJiYgdWEubWF0Y2goL3J2XFw6KFxcZCspLykgJiYgUmVnRXhwLiQxIDwgNDUpICkge1xuXHRcdGFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRpbWVyO1xuXG5cdFx0XHR2YXIgZHVtbXlTcmMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic291cmNlXCIpO1xuXG5cdFx0XHR2YXIgZml4UmVzcGltZyA9IGZ1bmN0aW9uKGltZykge1xuXHRcdFx0XHR2YXIgc291cmNlLCBzaXplcztcblx0XHRcdFx0dmFyIHBpY3R1cmUgPSBpbWcucGFyZW50Tm9kZTtcblxuXHRcdFx0XHRpZiAocGljdHVyZS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSBcIlBJQ1RVUkVcIikge1xuXHRcdFx0XHRcdHNvdXJjZSA9IGR1bW15U3JjLmNsb25lTm9kZSgpO1xuXG5cdFx0XHRcdFx0cGljdHVyZS5pbnNlcnRCZWZvcmUoc291cmNlLCBwaWN0dXJlLmZpcnN0RWxlbWVudENoaWxkKTtcblx0XHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cGljdHVyZS5yZW1vdmVDaGlsZChzb3VyY2UpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCFpbWcuX3BmTGFzdFNpemUgfHwgaW1nLm9mZnNldFdpZHRoID4gaW1nLl9wZkxhc3RTaXplKSB7XG5cdFx0XHRcdFx0aW1nLl9wZkxhc3RTaXplID0gaW1nLm9mZnNldFdpZHRoO1xuXHRcdFx0XHRcdHNpemVzID0gaW1nLnNpemVzO1xuXHRcdFx0XHRcdGltZy5zaXplcyArPSBcIiwxMDB2d1wiO1xuXHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpbWcuc2l6ZXMgPSBzaXplcztcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0dmFyIGZpbmRQaWN0dXJlSW1ncyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgaTtcblx0XHRcdFx0dmFyIGltZ3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwicGljdHVyZSA+IGltZywgaW1nW3NyY3NldF1bc2l6ZXNdXCIpO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgaW1ncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGZpeFJlc3BpbWcoaW1nc1tpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHR2YXIgb25SZXNpemUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVyKTtcblx0XHRcdFx0dGltZXIgPSBzZXRUaW1lb3V0KGZpbmRQaWN0dXJlSW1ncywgOTkpO1xuXHRcdFx0fTtcblx0XHRcdHZhciBtcSA9IHdpbmRvdy5tYXRjaE1lZGlhICYmIG1hdGNoTWVkaWEoXCIob3JpZW50YXRpb246IGxhbmRzY2FwZSlcIik7XG5cdFx0XHR2YXIgaW5pdCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRvblJlc2l6ZSgpO1xuXG5cdFx0XHRcdGlmIChtcSAmJiBtcS5hZGRMaXN0ZW5lcikge1xuXHRcdFx0XHRcdG1xLmFkZExpc3RlbmVyKG9uUmVzaXplKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0ZHVtbXlTcmMuc3Jjc2V0ID0gXCJkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFBQUFDSDVCQUVLQUFFQUxBQUFBQUFCQUFFQUFBSUNUQUVBT3c9PVwiO1xuXG5cdFx0XHRpZiAoL15bY3xpXXxkJC8udGVzdChkb2N1bWVudC5yZWFkeVN0YXRlIHx8IFwiXCIpKSB7XG5cdFx0XHRcdGluaXQoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGluaXQpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb25SZXNpemU7XG5cdFx0fSkoKSk7XG5cdH1cbn0pKHdpbmRvdyk7XG5cbi8qISBQaWN0dXJlZmlsbCAtIHYzLjAuMlxuICogaHR0cDovL3Njb3R0amVobC5naXRodWIuaW8vcGljdHVyZWZpbGxcbiAqIENvcHlyaWdodCAoYykgMjAxNSBodHRwczovL2dpdGh1Yi5jb20vc2NvdHRqZWhsL3BpY3R1cmVmaWxsL2Jsb2IvbWFzdGVyL0F1dGhvcnMudHh0O1xuICogIExpY2Vuc2U6IE1JVFxuICovXG5cbihmdW5jdGlvbiggd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkICkge1xuXHQvLyBFbmFibGUgc3RyaWN0IG1vZGVcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gSFRNTCBzaGltfHYgaXQgZm9yIG9sZCBJRSAoSUU5IHdpbGwgc3RpbGwgbmVlZCB0aGUgSFRNTCB2aWRlbyB0YWcgd29ya2Fyb3VuZClcblx0ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJwaWN0dXJlXCIgKTtcblxuXHR2YXIgd2FybiwgZW1pbnB4LCBhbHdheXNDaGVja1dEZXNjcmlwdG9yLCBldmFsSWQ7XG5cdC8vIGxvY2FsIG9iamVjdCBmb3IgbWV0aG9kIHJlZmVyZW5jZXMgYW5kIHRlc3RpbmcgZXhwb3N1cmVcblx0dmFyIHBmID0ge307XG5cdHZhciBpc1N1cHBvcnRUZXN0UmVhZHkgPSBmYWxzZTtcblx0dmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuXHR2YXIgaW1hZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImltZ1wiICk7XG5cdHZhciBnZXRJbWdBdHRyID0gaW1hZ2UuZ2V0QXR0cmlidXRlO1xuXHR2YXIgc2V0SW1nQXR0ciA9IGltYWdlLnNldEF0dHJpYnV0ZTtcblx0dmFyIHJlbW92ZUltZ0F0dHIgPSBpbWFnZS5yZW1vdmVBdHRyaWJ1dGU7XG5cdHZhciBkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXHR2YXIgdHlwZXMgPSB7fTtcblx0dmFyIGNmZyA9IHtcblx0XHQvL3Jlc291cmNlIHNlbGVjdGlvbjpcblx0XHRhbGdvcml0aG06IFwiXCJcblx0fTtcblx0dmFyIHNyY0F0dHIgPSBcImRhdGEtcGZzcmNcIjtcblx0dmFyIHNyY3NldEF0dHIgPSBzcmNBdHRyICsgXCJzZXRcIjtcblx0Ly8gdWEgc25pZmZpbmcgaXMgZG9uZSBmb3IgdW5kZXRlY3RhYmxlIGltZyBsb2FkaW5nIGZlYXR1cmVzLFxuXHQvLyB0byBkbyBzb21lIG5vbiBjcnVjaWFsIHBlcmYgb3B0aW1pemF0aW9uc1xuXHR2YXIgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuXHR2YXIgc3VwcG9ydEFib3J0ID0gKC9yaWRlbnQvKS50ZXN0KHVhKSB8fCAoKC9lY2tvLykudGVzdCh1YSkgJiYgdWEubWF0Y2goL3J2XFw6KFxcZCspLykgJiYgUmVnRXhwLiQxID4gMzUgKTtcblx0dmFyIGN1clNyY1Byb3AgPSBcImN1cnJlbnRTcmNcIjtcblx0dmFyIHJlZ1dEZXNjID0gL1xccytcXCs/XFxkKyhlXFxkKyk/dy87XG5cdHZhciByZWdTaXplID0gLyhcXChbXildK1xcKSk/XFxzKiguKykvO1xuXHR2YXIgc2V0T3B0aW9ucyA9IHdpbmRvdy5waWN0dXJlZmlsbENGRztcblx0LyoqXG5cdCAqIFNob3J0Y3V0IHByb3BlcnR5IGZvciBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjL3NwZWNzL21peGVkY29udGVudC8jcmVzdHJpY3RzLW1peGVkLWNvbnRlbnQgKCBmb3IgZWFzeSBvdmVycmlkaW5nIGluIHRlc3RzIClcblx0ICovXG5cdC8vIGJhc2VTdHlsZSBhbHNvIHVzZWQgYnkgZ2V0RW1WYWx1ZSAoaS5lLjogd2lkdGg6IDFlbSBpcyBpbXBvcnRhbnQpXG5cdHZhciBiYXNlU3R5bGUgPSBcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDt2aXNpYmlsaXR5OmhpZGRlbjtkaXNwbGF5OmJsb2NrO3BhZGRpbmc6MDtib3JkZXI6bm9uZTtmb250LXNpemU6MWVtO3dpZHRoOjFlbTtvdmVyZmxvdzpoaWRkZW47Y2xpcDpyZWN0KDBweCwgMHB4LCAwcHgsIDBweClcIjtcblx0dmFyIGZzQ3NzID0gXCJmb250LXNpemU6MTAwJSFpbXBvcnRhbnQ7XCI7XG5cdHZhciBpc1Z3RGlydHkgPSB0cnVlO1xuXG5cdHZhciBjc3NDYWNoZSA9IHt9O1xuXHR2YXIgc2l6ZUxlbmd0aENhY2hlID0ge307XG5cdHZhciBEUFIgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcblx0dmFyIHVuaXRzID0ge1xuXHRcdHB4OiAxLFxuXHRcdFwiaW5cIjogOTZcblx0fTtcblx0dmFyIGFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cdC8qKlxuXHQgKiBhbHJlYWR5UnVuIGZsYWcgdXNlZCBmb3Igc2V0T3B0aW9ucy4gaXMgaXQgdHJ1ZSBzZXRPcHRpb25zIHdpbGwgcmVldmFsdWF0ZVxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0ICovXG5cdHZhciBhbHJlYWR5UnVuID0gZmFsc2U7XG5cblx0Ly8gUmV1c2FibGUsIG5vbi1cImdcIiBSZWdleGVzXG5cblx0Ly8gKERvbid0IHVzZSBcXHMsIHRvIGF2b2lkIG1hdGNoaW5nIG5vbi1icmVha2luZyBzcGFjZS4pXG5cdHZhciByZWdleExlYWRpbmdTcGFjZXMgPSAvXlsgXFx0XFxuXFxyXFx1MDAwY10rLyxcblx0ICAgIHJlZ2V4TGVhZGluZ0NvbW1hc09yU3BhY2VzID0gL15bLCBcXHRcXG5cXHJcXHUwMDBjXSsvLFxuXHQgICAgcmVnZXhMZWFkaW5nTm90U3BhY2VzID0gL15bXiBcXHRcXG5cXHJcXHUwMDBjXSsvLFxuXHQgICAgcmVnZXhUcmFpbGluZ0NvbW1hcyA9IC9bLF0rJC8sXG5cdCAgICByZWdleE5vbk5lZ2F0aXZlSW50ZWdlciA9IC9eXFxkKyQvLFxuXG5cdCAgICAvLyAoIFBvc2l0aXZlIG9yIG5lZ2F0aXZlIG9yIHVuc2lnbmVkIGludGVnZXJzIG9yIGRlY2ltYWxzLCB3aXRob3V0IG9yIHdpdGhvdXQgZXhwb25lbnRzLlxuXHQgICAgLy8gTXVzdCBpbmNsdWRlIGF0IGxlYXN0IG9uZSBkaWdpdC5cblx0ICAgIC8vIEFjY29yZGluZyB0byBzcGVjIHRlc3RzIGFueSBkZWNpbWFsIHBvaW50IG11c3QgYmUgZm9sbG93ZWQgYnkgYSBkaWdpdC5cblx0ICAgIC8vIE5vIGxlYWRpbmcgcGx1cyBzaWduIGlzIGFsbG93ZWQuKVxuXHQgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5mcmFzdHJ1Y3R1cmUuaHRtbCN2YWxpZC1mbG9hdGluZy1wb2ludC1udW1iZXJcblx0ICAgIHJlZ2V4RmxvYXRpbmdQb2ludCA9IC9eLT8oPzpbMC05XSt8WzAtOV0qXFwuWzAtOV0rKSg/OltlRV1bKy1dP1swLTldKyk/JC87XG5cblx0dmFyIG9uID0gZnVuY3Rpb24ob2JqLCBldnQsIGZuLCBjYXB0dXJlKSB7XG5cdFx0aWYgKCBvYmouYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKGV2dCwgZm4sIGNhcHR1cmUgfHwgZmFsc2UpO1xuXHRcdH0gZWxzZSBpZiAoIG9iai5hdHRhY2hFdmVudCApIHtcblx0XHRcdG9iai5hdHRhY2hFdmVudCggXCJvblwiICsgZXZ0LCBmbik7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBzaW1wbGUgbWVtb2l6ZSBmdW5jdGlvbjpcblx0ICovXG5cblx0dmFyIG1lbW9pemUgPSBmdW5jdGlvbihmbikge1xuXHRcdHZhciBjYWNoZSA9IHt9O1xuXHRcdHJldHVybiBmdW5jdGlvbihpbnB1dCkge1xuXHRcdFx0aWYgKCAhKGlucHV0IGluIGNhY2hlKSApIHtcblx0XHRcdFx0Y2FjaGVbIGlucHV0IF0gPSBmbihpbnB1dCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY2FjaGVbIGlucHV0IF07XG5cdFx0fTtcblx0fTtcblxuXHQvLyBVVElMSVRZIEZVTkNUSU9OU1xuXG5cdC8vIE1hbnVhbCBpcyBmYXN0ZXIgdGhhbiBSZWdFeFxuXHQvLyBodHRwOi8vanNwZXJmLmNvbS93aGl0ZXNwYWNlLWNoYXJhY3Rlci81XG5cdGZ1bmN0aW9uIGlzU3BhY2UoYykge1xuXHRcdHJldHVybiAoYyA9PT0gXCJcXHUwMDIwXCIgfHwgLy8gc3BhY2Vcblx0XHQgICAgICAgIGMgPT09IFwiXFx1MDAwOVwiIHx8IC8vIGhvcml6b250YWwgdGFiXG5cdFx0ICAgICAgICBjID09PSBcIlxcdTAwMEFcIiB8fCAvLyBuZXcgbGluZVxuXHRcdCAgICAgICAgYyA9PT0gXCJcXHUwMDBDXCIgfHwgLy8gZm9ybSBmZWVkXG5cdFx0ICAgICAgICBjID09PSBcIlxcdTAwMERcIik7ICAvLyBjYXJyaWFnZSByZXR1cm5cblx0fVxuXG5cdC8qKlxuXHQgKiBnZXRzIGEgbWVkaWFxdWVyeSBhbmQgcmV0dXJucyBhIGJvb2xlYW4gb3IgZ2V0cyBhIGNzcyBsZW5ndGggYW5kIHJldHVybnMgYSBudW1iZXJcblx0ICogQHBhcmFtIGNzcyBtZWRpYXF1ZXJpZXMgb3IgY3NzIGxlbmd0aFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbnxudW1iZXJ9XG5cdCAqXG5cdCAqIGJhc2VkIG9uOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9qb25hdGhhbnRuZWFsL2RiNGY3NzAwOWIxNTVmMDgzNzM4XG5cdCAqL1xuXHR2YXIgZXZhbENTUyA9IChmdW5jdGlvbigpIHtcblxuXHRcdHZhciByZWdMZW5ndGggPSAvXihbXFxkXFwuXSspKGVtfHZ3fHB4KSQvO1xuXHRcdHZhciByZXBsYWNlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cywgaW5kZXggPSAwLCBzdHJpbmcgPSBhcmdzWzBdO1xuXHRcdFx0d2hpbGUgKCsraW5kZXggaW4gYXJncykge1xuXHRcdFx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShhcmdzW2luZGV4XSwgYXJnc1srK2luZGV4XSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc3RyaW5nO1xuXHRcdH07XG5cblx0XHR2YXIgYnVpbGRTdHIgPSBtZW1vaXplKGZ1bmN0aW9uKGNzcykge1xuXG5cdFx0XHRyZXR1cm4gXCJyZXR1cm4gXCIgKyByZXBsYWNlKChjc3MgfHwgXCJcIikudG9Mb3dlckNhc2UoKSxcblx0XHRcdFx0Ly8gaW50ZXJwcmV0IGBhbmRgXG5cdFx0XHRcdC9cXGJhbmRcXGIvZywgXCImJlwiLFxuXG5cdFx0XHRcdC8vIGludGVycHJldCBgLGBcblx0XHRcdFx0LywvZywgXCJ8fFwiLFxuXG5cdFx0XHRcdC8vIGludGVycHJldCBgbWluLWAgYXMgPj1cblx0XHRcdFx0L21pbi0oW2Etei1cXHNdKyk6L2csIFwiZS4kMT49XCIsXG5cblx0XHRcdFx0Ly8gaW50ZXJwcmV0IGBtYXgtYCBhcyA8PVxuXHRcdFx0XHQvbWF4LShbYS16LVxcc10rKTovZywgXCJlLiQxPD1cIixcblxuXHRcdFx0XHQvL2NhbGMgdmFsdWVcblx0XHRcdFx0L2NhbGMoW14pXSspL2csIFwiKCQxKVwiLFxuXG5cdFx0XHRcdC8vIGludGVycHJldCBjc3MgdmFsdWVzXG5cdFx0XHRcdC8oXFxkK1tcXC5dKltcXGRdKikoW2Etel0rKS9nLCBcIigkMSAqIGUuJDIpXCIsXG5cdFx0XHRcdC8vbWFrZSBldmFsIGxlc3MgZXZpbFxuXHRcdFx0XHQvXig/IShlLlthLXpdfFswLTlcXC4mPXw+PFxcK1xcLVxcKlxcKFxcKVxcL10pKS4qL2lnLCBcIlwiXG5cdFx0XHQpICsgXCI7XCI7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oY3NzLCBsZW5ndGgpIHtcblx0XHRcdHZhciBwYXJzZWRMZW5ndGg7XG5cdFx0XHRpZiAoIShjc3MgaW4gY3NzQ2FjaGUpKSB7XG5cdFx0XHRcdGNzc0NhY2hlW2Nzc10gPSBmYWxzZTtcblx0XHRcdFx0aWYgKGxlbmd0aCAmJiAocGFyc2VkTGVuZ3RoID0gY3NzLm1hdGNoKCByZWdMZW5ndGggKSkpIHtcblx0XHRcdFx0XHRjc3NDYWNoZVtjc3NdID0gcGFyc2VkTGVuZ3RoWyAxIF0gKiB1bml0c1twYXJzZWRMZW5ndGhbIDIgXV07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Lypqc2hpbnQgZXZpbDp0cnVlICovXG5cdFx0XHRcdFx0dHJ5e1xuXHRcdFx0XHRcdFx0Y3NzQ2FjaGVbY3NzXSA9IG5ldyBGdW5jdGlvbihcImVcIiwgYnVpbGRTdHIoY3NzKSkodW5pdHMpO1xuXHRcdFx0XHRcdH0gY2F0Y2goZSkge31cblx0XHRcdFx0XHQvKmpzaGludCBldmlsOmZhbHNlICovXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBjc3NDYWNoZVtjc3NdO1xuXHRcdH07XG5cdH0pKCk7XG5cblx0dmFyIHNldFJlc29sdXRpb24gPSBmdW5jdGlvbiggY2FuZGlkYXRlLCBzaXplc2F0dHIgKSB7XG5cdFx0aWYgKCBjYW5kaWRhdGUudyApIHsgLy8gaCA9IG1lYW5zIGhlaWdodDogfHwgZGVzY3JpcHRvci50eXBlID09PSAnaCcgZG8gbm90IGhhbmRsZSB5ZXQuLi5cblx0XHRcdGNhbmRpZGF0ZS5jV2lkdGggPSBwZi5jYWxjTGlzdExlbmd0aCggc2l6ZXNhdHRyIHx8IFwiMTAwdndcIiApO1xuXHRcdFx0Y2FuZGlkYXRlLnJlcyA9IGNhbmRpZGF0ZS53IC8gY2FuZGlkYXRlLmNXaWR0aCA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNhbmRpZGF0ZS5yZXMgPSBjYW5kaWRhdGUuZDtcblx0XHR9XG5cdFx0cmV0dXJuIGNhbmRpZGF0ZTtcblx0fTtcblxuXHQvKipcblx0ICpcblx0ICogQHBhcmFtIG9wdFxuXHQgKi9cblx0dmFyIHBpY3R1cmVmaWxsID0gZnVuY3Rpb24oIG9wdCApIHtcblxuXHRcdGlmICghaXNTdXBwb3J0VGVzdFJlYWR5KSB7cmV0dXJuO31cblxuXHRcdHZhciBlbGVtZW50cywgaSwgcGxlbjtcblxuXHRcdHZhciBvcHRpb25zID0gb3B0IHx8IHt9O1xuXG5cdFx0aWYgKCBvcHRpb25zLmVsZW1lbnRzICYmIG9wdGlvbnMuZWxlbWVudHMubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRpZiAoIG9wdGlvbnMuZWxlbWVudHMubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gXCJJTUdcIiApIHtcblx0XHRcdFx0b3B0aW9ucy5lbGVtZW50cyA9ICBbIG9wdGlvbnMuZWxlbWVudHMgXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9wdGlvbnMuY29udGV4dCA9IG9wdGlvbnMuZWxlbWVudHM7XG5cdFx0XHRcdG9wdGlvbnMuZWxlbWVudHMgPSAgbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRlbGVtZW50cyA9IG9wdGlvbnMuZWxlbWVudHMgfHwgcGYucXNhKCAob3B0aW9ucy5jb250ZXh0IHx8IGRvY3VtZW50KSwgKCBvcHRpb25zLnJlZXZhbHVhdGUgfHwgb3B0aW9ucy5yZXNlbGVjdCApID8gcGYuc2VsIDogcGYuc2VsU2hvcnQgKTtcblxuXHRcdGlmICggKHBsZW4gPSBlbGVtZW50cy5sZW5ndGgpICkge1xuXG5cdFx0XHRwZi5zZXR1cFJ1biggb3B0aW9ucyApO1xuXHRcdFx0YWxyZWFkeVJ1biA9IHRydWU7XG5cblx0XHRcdC8vIExvb3AgdGhyb3VnaCBhbGwgZWxlbWVudHNcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgcGxlbjsgaSsrICkge1xuXHRcdFx0XHRwZi5maWxsSW1nKGVsZW1lbnRzWyBpIF0sIG9wdGlvbnMpO1xuXHRcdFx0fVxuXG5cdFx0XHRwZi50ZWFyZG93blJ1biggb3B0aW9ucyApO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogb3V0cHV0cyBhIHdhcm5pbmcgZm9yIHRoZSBkZXZlbG9wZXJcblx0ICogQHBhcmFtIHttZXNzYWdlfVxuXHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdCAqL1xuXHR3YXJuID0gKCB3aW5kb3cuY29uc29sZSAmJiBjb25zb2xlLndhcm4gKSA/XG5cdFx0ZnVuY3Rpb24oIG1lc3NhZ2UgKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oIG1lc3NhZ2UgKTtcblx0XHR9IDpcblx0XHRub29wXG5cdDtcblxuXHRpZiAoICEoY3VyU3JjUHJvcCBpbiBpbWFnZSkgKSB7XG5cdFx0Y3VyU3JjUHJvcCA9IFwic3JjXCI7XG5cdH1cblxuXHQvLyBBZGQgc3VwcG9ydCBmb3Igc3RhbmRhcmQgbWltZSB0eXBlcy5cblx0dHlwZXNbIFwiaW1hZ2UvanBlZ1wiIF0gPSB0cnVlO1xuXHR0eXBlc1sgXCJpbWFnZS9naWZcIiBdID0gdHJ1ZTtcblx0dHlwZXNbIFwiaW1hZ2UvcG5nXCIgXSA9IHRydWU7XG5cblx0ZnVuY3Rpb24gZGV0ZWN0VHlwZVN1cHBvcnQoIHR5cGUsIHR5cGVVcmkgKSB7XG5cdFx0Ly8gYmFzZWQgb24gTW9kZXJuaXpyJ3MgbG9zc2xlc3MgaW1nLXdlYnAgdGVzdFxuXHRcdC8vIG5vdGU6IGFzeW5jaHJvbm91c1xuXHRcdHZhciBpbWFnZSA9IG5ldyB3aW5kb3cuSW1hZ2UoKTtcblx0XHRpbWFnZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR0eXBlc1sgdHlwZSBdID0gZmFsc2U7XG5cdFx0XHRwaWN0dXJlZmlsbCgpO1xuXHRcdH07XG5cdFx0aW1hZ2Uub25sb2FkID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR0eXBlc1sgdHlwZSBdID0gaW1hZ2Uud2lkdGggPT09IDE7XG5cdFx0XHRwaWN0dXJlZmlsbCgpO1xuXHRcdH07XG5cdFx0aW1hZ2Uuc3JjID0gdHlwZVVyaTtcblx0XHRyZXR1cm4gXCJwZW5kaW5nXCI7XG5cdH1cblxuXHQvLyB0ZXN0IHN2ZyBzdXBwb3J0XG5cdHR5cGVzWyBcImltYWdlL3N2Zyt4bWxcIiBdID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSggXCJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0ltYWdlXCIsIFwiMS4xXCIgKTtcblxuXHQvKipcblx0ICogdXBkYXRlcyB0aGUgaW50ZXJuYWwgdlcgcHJvcGVydHkgd2l0aCB0aGUgY3VycmVudCB2aWV3cG9ydCB3aWR0aCBpbiBweFxuXHQgKi9cblx0ZnVuY3Rpb24gdXBkYXRlTWV0cmljcygpIHtcblxuXHRcdGlzVndEaXJ0eSA9IGZhbHNlO1xuXHRcdERQUiA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuXHRcdGNzc0NhY2hlID0ge307XG5cdFx0c2l6ZUxlbmd0aENhY2hlID0ge307XG5cblx0XHRwZi5EUFIgPSBEUFIgfHwgMTtcblxuXHRcdHVuaXRzLndpZHRoID0gTWF0aC5tYXgod2luZG93LmlubmVyV2lkdGggfHwgMCwgZG9jRWxlbS5jbGllbnRXaWR0aCk7XG5cdFx0dW5pdHMuaGVpZ2h0ID0gTWF0aC5tYXgod2luZG93LmlubmVySGVpZ2h0IHx8IDAsIGRvY0VsZW0uY2xpZW50SGVpZ2h0KTtcblxuXHRcdHVuaXRzLnZ3ID0gdW5pdHMud2lkdGggLyAxMDA7XG5cdFx0dW5pdHMudmggPSB1bml0cy5oZWlnaHQgLyAxMDA7XG5cblx0XHRldmFsSWQgPSBbIHVuaXRzLmhlaWdodCwgdW5pdHMud2lkdGgsIERQUiBdLmpvaW4oXCItXCIpO1xuXG5cdFx0dW5pdHMuZW0gPSBwZi5nZXRFbVZhbHVlKCk7XG5cdFx0dW5pdHMucmVtID0gdW5pdHMuZW07XG5cdH1cblxuXHRmdW5jdGlvbiBjaG9vc2VMb3dSZXMoIGxvd2VyVmFsdWUsIGhpZ2hlclZhbHVlLCBkcHJWYWx1ZSwgaXNDYWNoZWQgKSB7XG5cdFx0dmFyIGJvbnVzRmFjdG9yLCB0b29NdWNoLCBib251cywgbWVhbkRlbnNpdHk7XG5cblx0XHQvL2V4cGVyaW1lbnRhbFxuXHRcdGlmIChjZmcuYWxnb3JpdGhtID09PSBcInNhdmVEYXRhXCIgKXtcblx0XHRcdGlmICggbG93ZXJWYWx1ZSA+IDIuNyApIHtcblx0XHRcdFx0bWVhbkRlbnNpdHkgPSBkcHJWYWx1ZSArIDE7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0b29NdWNoID0gaGlnaGVyVmFsdWUgLSBkcHJWYWx1ZTtcblx0XHRcdFx0Ym9udXNGYWN0b3IgPSBNYXRoLnBvdyhsb3dlclZhbHVlIC0gMC42LCAxLjUpO1xuXG5cdFx0XHRcdGJvbnVzID0gdG9vTXVjaCAqIGJvbnVzRmFjdG9yO1xuXG5cdFx0XHRcdGlmIChpc0NhY2hlZCkge1xuXHRcdFx0XHRcdGJvbnVzICs9IDAuMSAqIGJvbnVzRmFjdG9yO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bWVhbkRlbnNpdHkgPSBsb3dlclZhbHVlICsgYm9udXM7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1lYW5EZW5zaXR5ID0gKGRwclZhbHVlID4gMSkgP1xuXHRcdFx0XHRNYXRoLnNxcnQobG93ZXJWYWx1ZSAqIGhpZ2hlclZhbHVlKSA6XG5cdFx0XHRcdGxvd2VyVmFsdWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1lYW5EZW5zaXR5ID4gZHByVmFsdWU7XG5cdH1cblxuXHRmdW5jdGlvbiBhcHBseUJlc3RDYW5kaWRhdGUoIGltZyApIHtcblx0XHR2YXIgc3JjU2V0Q2FuZGlkYXRlcztcblx0XHR2YXIgbWF0Y2hpbmdTZXQgPSBwZi5nZXRTZXQoIGltZyApO1xuXHRcdHZhciBldmFsdWF0ZWQgPSBmYWxzZTtcblx0XHRpZiAoIG1hdGNoaW5nU2V0ICE9PSBcInBlbmRpbmdcIiApIHtcblx0XHRcdGV2YWx1YXRlZCA9IGV2YWxJZDtcblx0XHRcdGlmICggbWF0Y2hpbmdTZXQgKSB7XG5cdFx0XHRcdHNyY1NldENhbmRpZGF0ZXMgPSBwZi5zZXRSZXMoIG1hdGNoaW5nU2V0ICk7XG5cdFx0XHRcdHBmLmFwcGx5U2V0Q2FuZGlkYXRlKCBzcmNTZXRDYW5kaWRhdGVzLCBpbWcgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aW1nWyBwZi5ucyBdLmV2YWxlZCA9IGV2YWx1YXRlZDtcblx0fVxuXG5cdGZ1bmN0aW9uIGFzY2VuZGluZ1NvcnQoIGEsIGIgKSB7XG5cdFx0cmV0dXJuIGEucmVzIC0gYi5yZXM7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRTcmNUb0N1ciggaW1nLCBzcmMsIHNldCApIHtcblx0XHR2YXIgY2FuZGlkYXRlO1xuXHRcdGlmICggIXNldCAmJiBzcmMgKSB7XG5cdFx0XHRzZXQgPSBpbWdbIHBmLm5zIF0uc2V0cztcblx0XHRcdHNldCA9IHNldCAmJiBzZXRbc2V0Lmxlbmd0aCAtIDFdO1xuXHRcdH1cblxuXHRcdGNhbmRpZGF0ZSA9IGdldENhbmRpZGF0ZUZvclNyYyhzcmMsIHNldCk7XG5cblx0XHRpZiAoIGNhbmRpZGF0ZSApIHtcblx0XHRcdHNyYyA9IHBmLm1ha2VVcmwoc3JjKTtcblx0XHRcdGltZ1sgcGYubnMgXS5jdXJTcmMgPSBzcmM7XG5cdFx0XHRpbWdbIHBmLm5zIF0uY3VyQ2FuID0gY2FuZGlkYXRlO1xuXG5cdFx0XHRpZiAoICFjYW5kaWRhdGUucmVzICkge1xuXHRcdFx0XHRzZXRSZXNvbHV0aW9uKCBjYW5kaWRhdGUsIGNhbmRpZGF0ZS5zZXQuc2l6ZXMgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhbmRpZGF0ZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldENhbmRpZGF0ZUZvclNyYyggc3JjLCBzZXQgKSB7XG5cdFx0dmFyIGksIGNhbmRpZGF0ZSwgY2FuZGlkYXRlcztcblx0XHRpZiAoIHNyYyAmJiBzZXQgKSB7XG5cdFx0XHRjYW5kaWRhdGVzID0gcGYucGFyc2VTZXQoIHNldCApO1xuXHRcdFx0c3JjID0gcGYubWFrZVVybChzcmMpO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBjYW5kaWRhdGVzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIHNyYyA9PT0gcGYubWFrZVVybChjYW5kaWRhdGVzWyBpIF0udXJsKSApIHtcblx0XHRcdFx0XHRjYW5kaWRhdGUgPSBjYW5kaWRhdGVzWyBpIF07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhbmRpZGF0ZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldEFsbFNvdXJjZUVsZW1lbnRzKCBwaWN0dXJlLCBjYW5kaWRhdGVzICkge1xuXHRcdHZhciBpLCBsZW4sIHNvdXJjZSwgc3Jjc2V0O1xuXG5cdFx0Ly8gU1BFQyBtaXNtYXRjaCBpbnRlbmRlZCBmb3Igc2l6ZSBhbmQgcGVyZjpcblx0XHQvLyBhY3R1YWxseSBvbmx5IHNvdXJjZSBlbGVtZW50cyBwcmVjZWRpbmcgdGhlIGltZyBzaG91bGQgYmUgdXNlZFxuXHRcdC8vIGFsc28gbm90ZTogZG9uJ3QgdXNlIHFzYSBoZXJlLCBiZWNhdXNlIElFOCBzb21ldGltZXMgZG9lc24ndCBsaWtlIHNvdXJjZSBhcyB0aGUga2V5IHBhcnQgaW4gYSBzZWxlY3RvclxuXHRcdHZhciBzb3VyY2VzID0gcGljdHVyZS5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJzb3VyY2VcIiApO1xuXG5cdFx0Zm9yICggaSA9IDAsIGxlbiA9IHNvdXJjZXMubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRzb3VyY2UgPSBzb3VyY2VzWyBpIF07XG5cdFx0XHRzb3VyY2VbIHBmLm5zIF0gPSB0cnVlO1xuXHRcdFx0c3Jjc2V0ID0gc291cmNlLmdldEF0dHJpYnV0ZSggXCJzcmNzZXRcIiApO1xuXG5cdFx0XHQvLyBpZiBzb3VyY2UgZG9lcyBub3QgaGF2ZSBhIHNyY3NldCBhdHRyaWJ1dGUsIHNraXBcblx0XHRcdGlmICggc3Jjc2V0ICkge1xuXHRcdFx0XHRjYW5kaWRhdGVzLnB1c2goIHtcblx0XHRcdFx0XHRzcmNzZXQ6IHNyY3NldCxcblx0XHRcdFx0XHRtZWRpYTogc291cmNlLmdldEF0dHJpYnV0ZSggXCJtZWRpYVwiICksXG5cdFx0XHRcdFx0dHlwZTogc291cmNlLmdldEF0dHJpYnV0ZSggXCJ0eXBlXCIgKSxcblx0XHRcdFx0XHRzaXplczogc291cmNlLmdldEF0dHJpYnV0ZSggXCJzaXplc1wiIClcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBTcmNzZXQgUGFyc2VyXG5cdCAqIEJ5IEFsZXggQmVsbCB8ICBNSVQgTGljZW5zZVxuXHQgKlxuXHQgKiBAcmV0dXJucyBBcnJheSBbe3VybDogXywgZDogXywgdzogXywgaDpfLCBzZXQ6Xyg/Pz8/KX0sIC4uLl1cblx0ICpcblx0ICogQmFzZWQgc3VwZXIgZHVwZXIgY2xvc2VseSBvbiB0aGUgcmVmZXJlbmNlIGFsZ29yaXRobSBhdDpcblx0ICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI3BhcnNlLWEtc3Jjc2V0LWF0dHJpYnV0ZVxuXHQgKi9cblxuXHQvLyAxLiBMZXQgaW5wdXQgYmUgdGhlIHZhbHVlIHBhc3NlZCB0byB0aGlzIGFsZ29yaXRobS5cblx0Ly8gKFRPLURPIDogRXhwbGFpbiB3aGF0IFwic2V0XCIgYXJndW1lbnQgaXMgaGVyZS4gTWF5YmUgY2hvb3NlIGEgbW9yZVxuXHQvLyBkZXNjcmlwdGl2ZSAmIG1vcmUgc2VhcmNoYWJsZSBuYW1lLiAgU2luY2UgcGFzc2luZyB0aGUgXCJzZXRcIiBpbiByZWFsbHkgaGFzXG5cdC8vIG5vdGhpbmcgdG8gZG8gd2l0aCBwYXJzaW5nIHByb3BlciwgSSB3b3VsZCBwcmVmZXIgdGhpcyBhc3NpZ25tZW50IGV2ZW50dWFsbHlcblx0Ly8gZ28gaW4gYW4gZXh0ZXJuYWwgZm4uKVxuXHRmdW5jdGlvbiBwYXJzZVNyY3NldChpbnB1dCwgc2V0KSB7XG5cblx0XHRmdW5jdGlvbiBjb2xsZWN0Q2hhcmFjdGVycyhyZWdFeCkge1xuXHRcdFx0dmFyIGNoYXJzLFxuXHRcdFx0ICAgIG1hdGNoID0gcmVnRXguZXhlYyhpbnB1dC5zdWJzdHJpbmcocG9zKSk7XG5cdFx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdFx0Y2hhcnMgPSBtYXRjaFsgMCBdO1xuXHRcdFx0XHRwb3MgKz0gY2hhcnMubGVuZ3RoO1xuXHRcdFx0XHRyZXR1cm4gY2hhcnM7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICB1cmwsXG5cdFx0ICAgIGRlc2NyaXB0b3JzLFxuXHRcdCAgICBjdXJyZW50RGVzY3JpcHRvcixcblx0XHQgICAgc3RhdGUsXG5cdFx0ICAgIGMsXG5cblx0XHQgICAgLy8gMi4gTGV0IHBvc2l0aW9uIGJlIGEgcG9pbnRlciBpbnRvIGlucHV0LCBpbml0aWFsbHkgcG9pbnRpbmcgYXQgdGhlIHN0YXJ0XG5cdFx0ICAgIC8vICAgIG9mIHRoZSBzdHJpbmcuXG5cdFx0ICAgIHBvcyA9IDAsXG5cblx0XHQgICAgLy8gMy4gTGV0IGNhbmRpZGF0ZXMgYmUgYW4gaW5pdGlhbGx5IGVtcHR5IHNvdXJjZSBzZXQuXG5cdFx0ICAgIGNhbmRpZGF0ZXMgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCogQWRkcyBkZXNjcmlwdG9yIHByb3BlcnRpZXMgdG8gYSBjYW5kaWRhdGUsIHB1c2hlcyB0byB0aGUgY2FuZGlkYXRlcyBhcnJheVxuXHRcdCogQHJldHVybiB1bmRlZmluZWRcblx0XHQqL1xuXHRcdC8vIChEZWNsYXJlZCBvdXRzaWRlIG9mIHRoZSB3aGlsZSBsb29wIHNvIHRoYXQgaXQncyBvbmx5IGNyZWF0ZWQgb25jZS5cblx0XHQvLyAoVGhpcyBmbiBpcyBkZWZpbmVkIGJlZm9yZSBpdCBpcyB1c2VkLCBpbiBvcmRlciB0byBwYXNzIEpTSElOVC5cblx0XHQvLyBVbmZvcnR1bmF0ZWx5IHRoaXMgYnJlYWtzIHRoZSBzZXF1ZW5jaW5nIG9mIHRoZSBzcGVjIGNvbW1lbnRzLiA6LyApXG5cdFx0ZnVuY3Rpb24gcGFyc2VEZXNjcmlwdG9ycygpIHtcblxuXHRcdFx0Ly8gOS4gRGVzY3JpcHRvciBwYXJzZXI6IExldCBlcnJvciBiZSBuby5cblx0XHRcdHZhciBwRXJyb3IgPSBmYWxzZSxcblxuXHRcdFx0Ly8gMTAuIExldCB3aWR0aCBiZSBhYnNlbnQuXG5cdFx0XHQvLyAxMS4gTGV0IGRlbnNpdHkgYmUgYWJzZW50LlxuXHRcdFx0Ly8gMTIuIExldCBmdXR1cmUtY29tcGF0LWggYmUgYWJzZW50LiAoV2UncmUgaW1wbGVtZW50aW5nIGl0IG5vdyBhcyBoKVxuXHRcdFx0ICAgIHcsIGQsIGgsIGksXG5cdFx0XHQgICAgY2FuZGlkYXRlID0ge30sXG5cdFx0XHQgICAgZGVzYywgbGFzdENoYXIsIHZhbHVlLCBpbnRWYWwsIGZsb2F0VmFsO1xuXG5cdFx0XHQvLyAxMy4gRm9yIGVhY2ggZGVzY3JpcHRvciBpbiBkZXNjcmlwdG9ycywgcnVuIHRoZSBhcHByb3ByaWF0ZSBzZXQgb2Ygc3RlcHNcblx0XHRcdC8vIGZyb20gdGhlIGZvbGxvd2luZyBsaXN0OlxuXHRcdFx0Zm9yIChpID0gMCA7IGkgPCBkZXNjcmlwdG9ycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRkZXNjID0gZGVzY3JpcHRvcnNbIGkgXTtcblxuXHRcdFx0XHRsYXN0Q2hhciA9IGRlc2NbIGRlc2MubGVuZ3RoIC0gMSBdO1xuXHRcdFx0XHR2YWx1ZSA9IGRlc2Muc3Vic3RyaW5nKDAsIGRlc2MubGVuZ3RoIC0gMSk7XG5cdFx0XHRcdGludFZhbCA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG5cdFx0XHRcdGZsb2F0VmFsID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGRlc2NyaXB0b3IgY29uc2lzdHMgb2YgYSB2YWxpZCBub24tbmVnYXRpdmUgaW50ZWdlciBmb2xsb3dlZCBieVxuXHRcdFx0XHQvLyBhIFUrMDA3NyBMQVRJTiBTTUFMTCBMRVRURVIgVyBjaGFyYWN0ZXJcblx0XHRcdFx0aWYgKHJlZ2V4Tm9uTmVnYXRpdmVJbnRlZ2VyLnRlc3QodmFsdWUpICYmIChsYXN0Q2hhciA9PT0gXCJ3XCIpKSB7XG5cblx0XHRcdFx0XHQvLyBJZiB3aWR0aCBhbmQgZGVuc2l0eSBhcmUgbm90IGJvdGggYWJzZW50LCB0aGVuIGxldCBlcnJvciBiZSB5ZXMuXG5cdFx0XHRcdFx0aWYgKHcgfHwgZCkge3BFcnJvciA9IHRydWU7fVxuXG5cdFx0XHRcdFx0Ly8gQXBwbHkgdGhlIHJ1bGVzIGZvciBwYXJzaW5nIG5vbi1uZWdhdGl2ZSBpbnRlZ2VycyB0byB0aGUgZGVzY3JpcHRvci5cblx0XHRcdFx0XHQvLyBJZiB0aGUgcmVzdWx0IGlzIHplcm8sIGxldCBlcnJvciBiZSB5ZXMuXG5cdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBsZXQgd2lkdGggYmUgdGhlIHJlc3VsdC5cblx0XHRcdFx0XHRpZiAoaW50VmFsID09PSAwKSB7cEVycm9yID0gdHJ1ZTt9IGVsc2Uge3cgPSBpbnRWYWw7fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBkZXNjcmlwdG9yIGNvbnNpc3RzIG9mIGEgdmFsaWQgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGZvbGxvd2VkIGJ5XG5cdFx0XHRcdC8vIGEgVSswMDc4IExBVElOIFNNQUxMIExFVFRFUiBYIGNoYXJhY3RlclxuXHRcdFx0XHR9IGVsc2UgaWYgKHJlZ2V4RmxvYXRpbmdQb2ludC50ZXN0KHZhbHVlKSAmJiAobGFzdENoYXIgPT09IFwieFwiKSkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgd2lkdGgsIGRlbnNpdHkgYW5kIGZ1dHVyZS1jb21wYXQtaCBhcmUgbm90IGFsbCBhYnNlbnQsIHRoZW4gbGV0IGVycm9yXG5cdFx0XHRcdFx0Ly8gYmUgeWVzLlxuXHRcdFx0XHRcdGlmICh3IHx8IGQgfHwgaCkge3BFcnJvciA9IHRydWU7fVxuXG5cdFx0XHRcdFx0Ly8gQXBwbHkgdGhlIHJ1bGVzIGZvciBwYXJzaW5nIGZsb2F0aW5nLXBvaW50IG51bWJlciB2YWx1ZXMgdG8gdGhlIGRlc2NyaXB0b3IuXG5cdFx0XHRcdFx0Ly8gSWYgdGhlIHJlc3VsdCBpcyBsZXNzIHRoYW4gemVybywgbGV0IGVycm9yIGJlIHllcy4gT3RoZXJ3aXNlLCBsZXQgZGVuc2l0eVxuXHRcdFx0XHRcdC8vIGJlIHRoZSByZXN1bHQuXG5cdFx0XHRcdFx0aWYgKGZsb2F0VmFsIDwgMCkge3BFcnJvciA9IHRydWU7fSBlbHNlIHtkID0gZmxvYXRWYWw7fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBkZXNjcmlwdG9yIGNvbnNpc3RzIG9mIGEgdmFsaWQgbm9uLW5lZ2F0aXZlIGludGVnZXIgZm9sbG93ZWQgYnlcblx0XHRcdFx0Ly8gYSBVKzAwNjggTEFUSU4gU01BTEwgTEVUVEVSIEggY2hhcmFjdGVyXG5cdFx0XHRcdH0gZWxzZSBpZiAocmVnZXhOb25OZWdhdGl2ZUludGVnZXIudGVzdCh2YWx1ZSkgJiYgKGxhc3RDaGFyID09PSBcImhcIikpIHtcblxuXHRcdFx0XHRcdC8vIElmIGhlaWdodCBhbmQgZGVuc2l0eSBhcmUgbm90IGJvdGggYWJzZW50LCB0aGVuIGxldCBlcnJvciBiZSB5ZXMuXG5cdFx0XHRcdFx0aWYgKGggfHwgZCkge3BFcnJvciA9IHRydWU7fVxuXG5cdFx0XHRcdFx0Ly8gQXBwbHkgdGhlIHJ1bGVzIGZvciBwYXJzaW5nIG5vbi1uZWdhdGl2ZSBpbnRlZ2VycyB0byB0aGUgZGVzY3JpcHRvci5cblx0XHRcdFx0XHQvLyBJZiB0aGUgcmVzdWx0IGlzIHplcm8sIGxldCBlcnJvciBiZSB5ZXMuIE90aGVyd2lzZSwgbGV0IGZ1dHVyZS1jb21wYXQtaFxuXHRcdFx0XHRcdC8vIGJlIHRoZSByZXN1bHQuXG5cdFx0XHRcdFx0aWYgKGludFZhbCA9PT0gMCkge3BFcnJvciA9IHRydWU7fSBlbHNlIHtoID0gaW50VmFsO31cblxuXHRcdFx0XHQvLyBBbnl0aGluZyBlbHNlLCBMZXQgZXJyb3IgYmUgeWVzLlxuXHRcdFx0XHR9IGVsc2Uge3BFcnJvciA9IHRydWU7fVxuXHRcdFx0fSAvLyAoY2xvc2Ugc3RlcCAxMyBmb3IgbG9vcClcblxuXHRcdFx0Ly8gMTUuIElmIGVycm9yIGlzIHN0aWxsIG5vLCB0aGVuIGFwcGVuZCBhIG5ldyBpbWFnZSBzb3VyY2UgdG8gY2FuZGlkYXRlcyB3aG9zZVxuXHRcdFx0Ly8gVVJMIGlzIHVybCwgYXNzb2NpYXRlZCB3aXRoIGEgd2lkdGggd2lkdGggaWYgbm90IGFic2VudCBhbmQgYSBwaXhlbFxuXHRcdFx0Ly8gZGVuc2l0eSBkZW5zaXR5IGlmIG5vdCBhYnNlbnQuIE90aGVyd2lzZSwgdGhlcmUgaXMgYSBwYXJzZSBlcnJvci5cblx0XHRcdGlmICghcEVycm9yKSB7XG5cdFx0XHRcdGNhbmRpZGF0ZS51cmwgPSB1cmw7XG5cblx0XHRcdFx0aWYgKHcpIHsgY2FuZGlkYXRlLncgPSB3O31cblx0XHRcdFx0aWYgKGQpIHsgY2FuZGlkYXRlLmQgPSBkO31cblx0XHRcdFx0aWYgKGgpIHsgY2FuZGlkYXRlLmggPSBoO31cblx0XHRcdFx0aWYgKCFoICYmICFkICYmICF3KSB7Y2FuZGlkYXRlLmQgPSAxO31cblx0XHRcdFx0aWYgKGNhbmRpZGF0ZS5kID09PSAxKSB7c2V0LmhhczF4ID0gdHJ1ZTt9XG5cdFx0XHRcdGNhbmRpZGF0ZS5zZXQgPSBzZXQ7XG5cblx0XHRcdFx0Y2FuZGlkYXRlcy5wdXNoKGNhbmRpZGF0ZSk7XG5cdFx0XHR9XG5cdFx0fSAvLyAoY2xvc2UgcGFyc2VEZXNjcmlwdG9ycyBmbilcblxuXHRcdC8qKlxuXHRcdCogVG9rZW5pemVzIGRlc2NyaXB0b3IgcHJvcGVydGllcyBwcmlvciB0byBwYXJzaW5nXG5cdFx0KiBSZXR1cm5zIHVuZGVmaW5lZC5cblx0XHQqIChBZ2FpbiwgdGhpcyBmbiBpcyBkZWZpbmVkIGJlZm9yZSBpdCBpcyB1c2VkLCBpbiBvcmRlciB0byBwYXNzIEpTSElOVC5cblx0XHQqIFVuZm9ydHVuYXRlbHkgdGhpcyBicmVha3MgdGhlIGxvZ2ljYWwgc2VxdWVuY2luZyBvZiB0aGUgc3BlYyBjb21tZW50cy4gOi8gKVxuXHRcdCovXG5cdFx0ZnVuY3Rpb24gdG9rZW5pemUoKSB7XG5cblx0XHRcdC8vIDguMS4gRGVzY3JpcHRvciB0b2tlbmlzZXI6IFNraXAgd2hpdGVzcGFjZVxuXHRcdFx0Y29sbGVjdENoYXJhY3RlcnMocmVnZXhMZWFkaW5nU3BhY2VzKTtcblxuXHRcdFx0Ly8gOC4yLiBMZXQgY3VycmVudCBkZXNjcmlwdG9yIGJlIHRoZSBlbXB0eSBzdHJpbmcuXG5cdFx0XHRjdXJyZW50RGVzY3JpcHRvciA9IFwiXCI7XG5cblx0XHRcdC8vIDguMy4gTGV0IHN0YXRlIGJlIGluIGRlc2NyaXB0b3IuXG5cdFx0XHRzdGF0ZSA9IFwiaW4gZGVzY3JpcHRvclwiO1xuXG5cdFx0XHR3aGlsZSAodHJ1ZSkge1xuXG5cdFx0XHRcdC8vIDguNC4gTGV0IGMgYmUgdGhlIGNoYXJhY3RlciBhdCBwb3NpdGlvbi5cblx0XHRcdFx0YyA9IGlucHV0LmNoYXJBdChwb3MpO1xuXG5cdFx0XHRcdC8vICBEbyB0aGUgZm9sbG93aW5nIGRlcGVuZGluZyBvbiB0aGUgdmFsdWUgb2Ygc3RhdGUuXG5cdFx0XHRcdC8vICBGb3IgdGhlIHB1cnBvc2Ugb2YgdGhpcyBzdGVwLCBcIkVPRlwiIGlzIGEgc3BlY2lhbCBjaGFyYWN0ZXIgcmVwcmVzZW50aW5nXG5cdFx0XHRcdC8vICB0aGF0IHBvc2l0aW9uIGlzIHBhc3QgdGhlIGVuZCBvZiBpbnB1dC5cblxuXHRcdFx0XHQvLyBJbiBkZXNjcmlwdG9yXG5cdFx0XHRcdGlmIChzdGF0ZSA9PT0gXCJpbiBkZXNjcmlwdG9yXCIpIHtcblx0XHRcdFx0XHQvLyBEbyB0aGUgZm9sbG93aW5nLCBkZXBlbmRpbmcgb24gdGhlIHZhbHVlIG9mIGM6XG5cblx0XHRcdFx0ICAvLyBTcGFjZSBjaGFyYWN0ZXJcblx0XHRcdFx0ICAvLyBJZiBjdXJyZW50IGRlc2NyaXB0b3IgaXMgbm90IGVtcHR5LCBhcHBlbmQgY3VycmVudCBkZXNjcmlwdG9yIHRvXG5cdFx0XHRcdCAgLy8gZGVzY3JpcHRvcnMgYW5kIGxldCBjdXJyZW50IGRlc2NyaXB0b3IgYmUgdGhlIGVtcHR5IHN0cmluZy5cblx0XHRcdFx0ICAvLyBTZXQgc3RhdGUgdG8gYWZ0ZXIgZGVzY3JpcHRvci5cblx0XHRcdFx0XHRpZiAoaXNTcGFjZShjKSkge1xuXHRcdFx0XHRcdFx0aWYgKGN1cnJlbnREZXNjcmlwdG9yKSB7XG5cdFx0XHRcdFx0XHRcdGRlc2NyaXB0b3JzLnB1c2goY3VycmVudERlc2NyaXB0b3IpO1xuXHRcdFx0XHRcdFx0XHRjdXJyZW50RGVzY3JpcHRvciA9IFwiXCI7XG5cdFx0XHRcdFx0XHRcdHN0YXRlID0gXCJhZnRlciBkZXNjcmlwdG9yXCI7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBVKzAwMkMgQ09NTUEgKCwpXG5cdFx0XHRcdFx0Ly8gQWR2YW5jZSBwb3NpdGlvbiB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgaW4gaW5wdXQuIElmIGN1cnJlbnQgZGVzY3JpcHRvclxuXHRcdFx0XHRcdC8vIGlzIG5vdCBlbXB0eSwgYXBwZW5kIGN1cnJlbnQgZGVzY3JpcHRvciB0byBkZXNjcmlwdG9ycy4gSnVtcCB0byB0aGUgc3RlcFxuXHRcdFx0XHRcdC8vIGxhYmVsZWQgZGVzY3JpcHRvciBwYXJzZXIuXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChjID09PSBcIixcIikge1xuXHRcdFx0XHRcdFx0cG9zICs9IDE7XG5cdFx0XHRcdFx0XHRpZiAoY3VycmVudERlc2NyaXB0b3IpIHtcblx0XHRcdFx0XHRcdFx0ZGVzY3JpcHRvcnMucHVzaChjdXJyZW50RGVzY3JpcHRvcik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRwYXJzZURlc2NyaXB0b3JzKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0XHQvLyBVKzAwMjggTEVGVCBQQVJFTlRIRVNJUyAoKClcblx0XHRcdFx0XHQvLyBBcHBlbmQgYyB0byBjdXJyZW50IGRlc2NyaXB0b3IuIFNldCBzdGF0ZSB0byBpbiBwYXJlbnMuXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChjID09PSBcIlxcdTAwMjhcIikge1xuXHRcdFx0XHRcdFx0Y3VycmVudERlc2NyaXB0b3IgPSBjdXJyZW50RGVzY3JpcHRvciArIGM7XG5cdFx0XHRcdFx0XHRzdGF0ZSA9IFwiaW4gcGFyZW5zXCI7XG5cblx0XHRcdFx0XHQvLyBFT0Zcblx0XHRcdFx0XHQvLyBJZiBjdXJyZW50IGRlc2NyaXB0b3IgaXMgbm90IGVtcHR5LCBhcHBlbmQgY3VycmVudCBkZXNjcmlwdG9yIHRvXG5cdFx0XHRcdFx0Ly8gZGVzY3JpcHRvcnMuIEp1bXAgdG8gdGhlIHN0ZXAgbGFiZWxlZCBkZXNjcmlwdG9yIHBhcnNlci5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGMgPT09IFwiXCIpIHtcblx0XHRcdFx0XHRcdGlmIChjdXJyZW50RGVzY3JpcHRvcikge1xuXHRcdFx0XHRcdFx0XHRkZXNjcmlwdG9ycy5wdXNoKGN1cnJlbnREZXNjcmlwdG9yKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHBhcnNlRGVzY3JpcHRvcnMoKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdC8vIEFueXRoaW5nIGVsc2Vcblx0XHRcdFx0XHQvLyBBcHBlbmQgYyB0byBjdXJyZW50IGRlc2NyaXB0b3IuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGN1cnJlbnREZXNjcmlwdG9yID0gY3VycmVudERlc2NyaXB0b3IgKyBjO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0Ly8gKGVuZCBcImluIGRlc2NyaXB0b3JcIlxuXG5cdFx0XHRcdC8vIEluIHBhcmVuc1xuXHRcdFx0XHR9IGVsc2UgaWYgKHN0YXRlID09PSBcImluIHBhcmVuc1wiKSB7XG5cblx0XHRcdFx0XHQvLyBVKzAwMjkgUklHSFQgUEFSRU5USEVTSVMgKCkpXG5cdFx0XHRcdFx0Ly8gQXBwZW5kIGMgdG8gY3VycmVudCBkZXNjcmlwdG9yLiBTZXQgc3RhdGUgdG8gaW4gZGVzY3JpcHRvci5cblx0XHRcdFx0XHRpZiAoYyA9PT0gXCIpXCIpIHtcblx0XHRcdFx0XHRcdGN1cnJlbnREZXNjcmlwdG9yID0gY3VycmVudERlc2NyaXB0b3IgKyBjO1xuXHRcdFx0XHRcdFx0c3RhdGUgPSBcImluIGRlc2NyaXB0b3JcIjtcblxuXHRcdFx0XHRcdC8vIEVPRlxuXHRcdFx0XHRcdC8vIEFwcGVuZCBjdXJyZW50IGRlc2NyaXB0b3IgdG8gZGVzY3JpcHRvcnMuIEp1bXAgdG8gdGhlIHN0ZXAgbGFiZWxlZFxuXHRcdFx0XHRcdC8vIGRlc2NyaXB0b3IgcGFyc2VyLlxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoYyA9PT0gXCJcIikge1xuXHRcdFx0XHRcdFx0ZGVzY3JpcHRvcnMucHVzaChjdXJyZW50RGVzY3JpcHRvcik7XG5cdFx0XHRcdFx0XHRwYXJzZURlc2NyaXB0b3JzKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0XHQvLyBBbnl0aGluZyBlbHNlXG5cdFx0XHRcdFx0Ly8gQXBwZW5kIGMgdG8gY3VycmVudCBkZXNjcmlwdG9yLlxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjdXJyZW50RGVzY3JpcHRvciA9IGN1cnJlbnREZXNjcmlwdG9yICsgYztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQWZ0ZXIgZGVzY3JpcHRvclxuXHRcdFx0XHR9IGVsc2UgaWYgKHN0YXRlID09PSBcImFmdGVyIGRlc2NyaXB0b3JcIikge1xuXG5cdFx0XHRcdFx0Ly8gRG8gdGhlIGZvbGxvd2luZywgZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZSBvZiBjOlxuXHRcdFx0XHRcdC8vIFNwYWNlIGNoYXJhY3RlcjogU3RheSBpbiB0aGlzIHN0YXRlLlxuXHRcdFx0XHRcdGlmIChpc1NwYWNlKGMpKSB7XG5cblx0XHRcdFx0XHQvLyBFT0Y6IEp1bXAgdG8gdGhlIHN0ZXAgbGFiZWxlZCBkZXNjcmlwdG9yIHBhcnNlci5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGMgPT09IFwiXCIpIHtcblx0XHRcdFx0XHRcdHBhcnNlRGVzY3JpcHRvcnMoKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdC8vIEFueXRoaW5nIGVsc2Vcblx0XHRcdFx0XHQvLyBTZXQgc3RhdGUgdG8gaW4gZGVzY3JpcHRvci4gU2V0IHBvc2l0aW9uIHRvIHRoZSBwcmV2aW91cyBjaGFyYWN0ZXIgaW4gaW5wdXQuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHN0YXRlID0gXCJpbiBkZXNjcmlwdG9yXCI7XG5cdFx0XHRcdFx0XHRwb3MgLT0gMTtcblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkdmFuY2UgcG9zaXRpb24gdG8gdGhlIG5leHQgY2hhcmFjdGVyIGluIGlucHV0LlxuXHRcdFx0XHRwb3MgKz0gMTtcblxuXHRcdFx0Ly8gUmVwZWF0IHRoaXMgc3RlcC5cblx0XHRcdH0gLy8gKGNsb3NlIHdoaWxlIHRydWUgbG9vcClcblx0XHR9XG5cblx0XHQvLyA0LiBTcGxpdHRpbmcgbG9vcDogQ29sbGVjdCBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgdGhhdCBhcmUgc3BhY2Vcblx0XHQvLyAgICBjaGFyYWN0ZXJzIG9yIFUrMDAyQyBDT01NQSBjaGFyYWN0ZXJzLiBJZiBhbnkgVSswMDJDIENPTU1BIGNoYXJhY3RlcnNcblx0XHQvLyAgICB3ZXJlIGNvbGxlY3RlZCwgdGhhdCBpcyBhIHBhcnNlIGVycm9yLlxuXHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRjb2xsZWN0Q2hhcmFjdGVycyhyZWdleExlYWRpbmdDb21tYXNPclNwYWNlcyk7XG5cblx0XHRcdC8vIDUuIElmIHBvc2l0aW9uIGlzIHBhc3QgdGhlIGVuZCBvZiBpbnB1dCwgcmV0dXJuIGNhbmRpZGF0ZXMgYW5kIGFib3J0IHRoZXNlIHN0ZXBzLlxuXHRcdFx0aWYgKHBvcyA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gY2FuZGlkYXRlczsgLy8gKHdlJ3JlIGRvbmUsIHRoaXMgaXMgdGhlIHNvbGUgcmV0dXJuIHBhdGgpXG5cdFx0XHR9XG5cblx0XHRcdC8vIDYuIENvbGxlY3QgYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIHRoYXQgYXJlIG5vdCBzcGFjZSBjaGFyYWN0ZXJzLFxuXHRcdFx0Ly8gICAgYW5kIGxldCB0aGF0IGJlIHVybC5cblx0XHRcdHVybCA9IGNvbGxlY3RDaGFyYWN0ZXJzKHJlZ2V4TGVhZGluZ05vdFNwYWNlcyk7XG5cblx0XHRcdC8vIDcuIExldCBkZXNjcmlwdG9ycyBiZSBhIG5ldyBlbXB0eSBsaXN0LlxuXHRcdFx0ZGVzY3JpcHRvcnMgPSBbXTtcblxuXHRcdFx0Ly8gOC4gSWYgdXJsIGVuZHMgd2l0aCBhIFUrMDAyQyBDT01NQSBjaGFyYWN0ZXIgKCwpLCBmb2xsb3cgdGhlc2Ugc3Vic3RlcHM6XG5cdFx0XHQvL1x0XHQoMSkuIFJlbW92ZSBhbGwgdHJhaWxpbmcgVSswMDJDIENPTU1BIGNoYXJhY3RlcnMgZnJvbSB1cmwuIElmIHRoaXMgcmVtb3ZlZFxuXHRcdFx0Ly8gICAgICAgICBtb3JlIHRoYW4gb25lIGNoYXJhY3RlciwgdGhhdCBpcyBhIHBhcnNlIGVycm9yLlxuXHRcdFx0aWYgKHVybC5zbGljZSgtMSkgPT09IFwiLFwiKSB7XG5cdFx0XHRcdHVybCA9IHVybC5yZXBsYWNlKHJlZ2V4VHJhaWxpbmdDb21tYXMsIFwiXCIpO1xuXHRcdFx0XHQvLyAoSnVtcCBhaGVhZCB0byBzdGVwIDkgdG8gc2tpcCB0b2tlbml6YXRpb24gYW5kIGp1c3QgcHVzaCB0aGUgY2FuZGlkYXRlKS5cblx0XHRcdFx0cGFyc2VEZXNjcmlwdG9ycygpO1xuXG5cdFx0XHQvL1x0T3RoZXJ3aXNlLCBmb2xsb3cgdGhlc2Ugc3Vic3RlcHM6XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0b2tlbml6ZSgpO1xuXHRcdFx0fSAvLyAoY2xvc2UgZWxzZSBvZiBzdGVwIDgpXG5cblx0XHQvLyAxNi4gUmV0dXJuIHRvIHRoZSBzdGVwIGxhYmVsZWQgc3BsaXR0aW5nIGxvb3AuXG5cdFx0fSAvLyAoQ2xvc2Ugb2YgYmlnIHdoaWxlIGxvb3AuKVxuXHR9XG5cblx0Lypcblx0ICogU2l6ZXMgUGFyc2VyXG5cdCAqXG5cdCAqIEJ5IEFsZXggQmVsbCB8ICBNSVQgTGljZW5zZVxuXHQgKlxuXHQgKiBOb24tc3RyaWN0IGJ1dCBhY2N1cmF0ZSBhbmQgbGlnaHR3ZWlnaHQgSlMgUGFyc2VyIGZvciB0aGUgc3RyaW5nIHZhbHVlIDxpbWcgc2l6ZXM9XCJoZXJlXCI+XG5cdCAqXG5cdCAqIFJlZmVyZW5jZSBhbGdvcml0aG0gYXQ6XG5cdCAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNwYXJzZS1hLXNpemVzLWF0dHJpYnV0ZVxuXHQgKlxuXHQgKiBNb3N0IGNvbW1lbnRzIGFyZSBjb3BpZWQgaW4gZGlyZWN0bHkgZnJvbSB0aGUgc3BlY1xuXHQgKiAoZXhjZXB0IGZvciBjb21tZW50cyBpbiBwYXJlbnMpLlxuXHQgKlxuXHQgKiBHcmFtbWFyIGlzOlxuXHQgKiA8c291cmNlLXNpemUtbGlzdD4gPSA8c291cmNlLXNpemU+IyBbICwgPHNvdXJjZS1zaXplLXZhbHVlPiBdPyB8IDxzb3VyY2Utc2l6ZS12YWx1ZT5cblx0ICogPHNvdXJjZS1zaXplPiA9IDxtZWRpYS1jb25kaXRpb24+IDxzb3VyY2Utc2l6ZS12YWx1ZT5cblx0ICogPHNvdXJjZS1zaXplLXZhbHVlPiA9IDxsZW5ndGg+XG5cdCAqIGh0dHA6Ly93d3cudzMub3JnL2h0bWwvd2cvZHJhZnRzL2h0bWwvbWFzdGVyL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNhdHRyLWltZy1zaXplc1xuXHQgKlxuXHQgKiBFLmcuIFwiKG1heC13aWR0aDogMzBlbSkgMTAwdncsIChtYXgtd2lkdGg6IDUwZW0pIDcwdncsIDEwMHZ3XCJcblx0ICogb3IgXCIobWluLXdpZHRoOiAzMGVtKSwgY2FsYygzMHZ3IC0gMTVweClcIiBvciBqdXN0IFwiMzB2d1wiXG5cdCAqXG5cdCAqIFJldHVybnMgdGhlIGZpcnN0IHZhbGlkIDxjc3MtbGVuZ3RoPiB3aXRoIGEgbWVkaWEgY29uZGl0aW9uIHRoYXQgZXZhbHVhdGVzIHRvIHRydWUsXG5cdCAqIG9yIFwiMTAwdndcIiBpZiBhbGwgdmFsaWQgbWVkaWEgY29uZGl0aW9ucyBldmFsdWF0ZSB0byBmYWxzZS5cblx0ICpcblx0ICovXG5cblx0ZnVuY3Rpb24gcGFyc2VTaXplcyhzdHJWYWx1ZSkge1xuXG5cdFx0Ly8gKFBlcmNlbnRhZ2UgQ1NTIGxlbmd0aHMgYXJlIG5vdCBhbGxvd2VkIGluIHRoaXMgY2FzZSwgdG8gYXZvaWQgY29uZnVzaW9uOlxuXHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCN2YWxpZC1zb3VyY2Utc2l6ZS1saXN0XG5cdFx0Ly8gQ1NTIGFsbG93cyBhIHNpbmdsZSBvcHRpb25hbCBwbHVzIG9yIG1pbnVzIHNpZ246XG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMi9zeW5kYXRhLmh0bWwjbnVtYmVyc1xuXHRcdC8vIENTUyBpcyBBU0NJSSBjYXNlLWluc2Vuc2l0aXZlOlxuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIvc3luZGF0YS5odG1sI2NoYXJhY3RlcnMgKVxuXHRcdC8vIFNwZWMgYWxsb3dzIGV4cG9uZW50aWFsIG5vdGF0aW9uIGZvciA8bnVtYmVyPiB0eXBlOlxuXHRcdC8vIGh0dHA6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzcy12YWx1ZXMvI251bWJlcnNcblx0XHR2YXIgcmVnZXhDc3NMZW5ndGhXaXRoVW5pdHMgPSAvXig/OlsrLV0/WzAtOV0rfFswLTldKlxcLlswLTldKykoPzpbZUVdWystXT9bMC05XSspPyg/OmNofGNtfGVtfGV4fGlufG1tfHBjfHB0fHB4fHJlbXx2aHx2bWlufHZtYXh8dncpJC9pO1xuXG5cdFx0Ly8gKFRoaXMgaXMgYSBxdWljayBhbmQgbGVuaWVudCB0ZXN0LiBCZWNhdXNlIG9mIG9wdGlvbmFsIHVubGltaXRlZC1kZXB0aCBpbnRlcm5hbFxuXHRcdC8vIGdyb3VwaW5nIHBhcmVucyBhbmQgc3RyaWN0IHNwYWNpbmcgcnVsZXMsIHRoaXMgY291bGQgZ2V0IHZlcnkgY29tcGxpY2F0ZWQuKVxuXHRcdHZhciByZWdleENzc0NhbGMgPSAvXmNhbGNcXCgoPzpbMC05YS16IFxcLlxcK1xcLVxcKlxcL1xcKFxcKV0rKVxcKSQvaTtcblxuXHRcdHZhciBpO1xuXHRcdHZhciB1bnBhcnNlZFNpemVzTGlzdDtcblx0XHR2YXIgdW5wYXJzZWRTaXplc0xpc3RMZW5ndGg7XG5cdFx0dmFyIHVucGFyc2VkU2l6ZTtcblx0XHR2YXIgbGFzdENvbXBvbmVudFZhbHVlO1xuXHRcdHZhciBzaXplO1xuXG5cdFx0Ly8gVVRJTElUWSBGVU5DVElPTlNcblxuXHRcdC8vICAoVG95IENTUyBwYXJzZXIuIFRoZSBnb2FscyBoZXJlIGFyZTpcblx0XHQvLyAgMSkgZXhwYW5zaXZlIHRlc3QgY292ZXJhZ2Ugd2l0aG91dCB0aGUgd2VpZ2h0IG9mIGEgZnVsbCBDU1MgcGFyc2VyLlxuXHRcdC8vICAyKSBBdm9pZGluZyByZWdleCB3aGVyZXZlciBjb252ZW5pZW50LlxuXHRcdC8vICBRdWljayB0ZXN0czogaHR0cDovL2pzZmlkZGxlLm5ldC9ndG50TDRnci8zL1xuXHRcdC8vICBSZXR1cm5zIGFuIGFycmF5IG9mIGFycmF5cy4pXG5cdFx0ZnVuY3Rpb24gcGFyc2VDb21wb25lbnRWYWx1ZXMoc3RyKSB7XG5cdFx0XHR2YXIgY2hyY3RyO1xuXHRcdFx0dmFyIGNvbXBvbmVudCA9IFwiXCI7XG5cdFx0XHR2YXIgY29tcG9uZW50QXJyYXkgPSBbXTtcblx0XHRcdHZhciBsaXN0QXJyYXkgPSBbXTtcblx0XHRcdHZhciBwYXJlbkRlcHRoID0gMDtcblx0XHRcdHZhciBwb3MgPSAwO1xuXHRcdFx0dmFyIGluQ29tbWVudCA9IGZhbHNlO1xuXG5cdFx0XHRmdW5jdGlvbiBwdXNoQ29tcG9uZW50KCkge1xuXHRcdFx0XHRpZiAoY29tcG9uZW50KSB7XG5cdFx0XHRcdFx0Y29tcG9uZW50QXJyYXkucHVzaChjb21wb25lbnQpO1xuXHRcdFx0XHRcdGNvbXBvbmVudCA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gcHVzaENvbXBvbmVudEFycmF5KCkge1xuXHRcdFx0XHRpZiAoY29tcG9uZW50QXJyYXlbMF0pIHtcblx0XHRcdFx0XHRsaXN0QXJyYXkucHVzaChjb21wb25lbnRBcnJheSk7XG5cdFx0XHRcdFx0Y29tcG9uZW50QXJyYXkgPSBbXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyAoTG9vcCBmb3J3YXJkcyBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHN0cmluZy4pXG5cdFx0XHR3aGlsZSAodHJ1ZSkge1xuXHRcdFx0XHRjaHJjdHIgPSBzdHIuY2hhckF0KHBvcyk7XG5cblx0XHRcdFx0aWYgKGNocmN0ciA9PT0gXCJcIikgeyAvLyAoIEVuZCBvZiBzdHJpbmcgcmVhY2hlZC4pXG5cdFx0XHRcdFx0cHVzaENvbXBvbmVudCgpO1xuXHRcdFx0XHRcdHB1c2hDb21wb25lbnRBcnJheSgpO1xuXHRcdFx0XHRcdHJldHVybiBsaXN0QXJyYXk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoaW5Db21tZW50KSB7XG5cdFx0XHRcdFx0aWYgKChjaHJjdHIgPT09IFwiKlwiKSAmJiAoc3RyW3BvcyArIDFdID09PSBcIi9cIikpIHsgLy8gKEF0IGVuZCBvZiBhIGNvbW1lbnQuKVxuXHRcdFx0XHRcdFx0aW5Db21tZW50ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRwb3MgKz0gMjtcblx0XHRcdFx0XHRcdHB1c2hDb21wb25lbnQoKTtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwb3MgKz0gMTsgLy8gKFNraXAgYWxsIGNoYXJhY3RlcnMgaW5zaWRlIGNvbW1lbnRzLilcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChpc1NwYWNlKGNocmN0cikpIHtcblx0XHRcdFx0XHQvLyAoSWYgcHJldmlvdXMgY2hhcmFjdGVyIGluIGxvb3Agd2FzIGFsc28gYSBzcGFjZSwgb3IgaWZcblx0XHRcdFx0XHQvLyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzdHJpbmcsIGRvIG5vdCBhZGQgc3BhY2UgY2hhciB0b1xuXHRcdFx0XHRcdC8vIGNvbXBvbmVudC4pXG5cdFx0XHRcdFx0aWYgKCAoc3RyLmNoYXJBdChwb3MgLSAxKSAmJiBpc1NwYWNlKCBzdHIuY2hhckF0KHBvcyAtIDEpICkgKSB8fCAhY29tcG9uZW50ICkge1xuXHRcdFx0XHRcdFx0cG9zICs9IDE7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHBhcmVuRGVwdGggPT09IDApIHtcblx0XHRcdFx0XHRcdHB1c2hDb21wb25lbnQoKTtcblx0XHRcdFx0XHRcdHBvcyArPTE7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gKFJlcGxhY2UgYW55IHNwYWNlIGNoYXJhY3RlciB3aXRoIGEgcGxhaW4gc3BhY2UgZm9yIGxlZ2liaWxpdHkuKVxuXHRcdFx0XHRcdFx0Y2hyY3RyID0gXCIgXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGNocmN0ciA9PT0gXCIoXCIpIHtcblx0XHRcdFx0XHRwYXJlbkRlcHRoICs9IDE7XG5cdFx0XHRcdH0gZWxzZSBpZiAoY2hyY3RyID09PSBcIilcIikge1xuXHRcdFx0XHRcdHBhcmVuRGVwdGggLT0gMTtcblx0XHRcdFx0fSBlbHNlIGlmIChjaHJjdHIgPT09IFwiLFwiKSB7XG5cdFx0XHRcdFx0cHVzaENvbXBvbmVudCgpO1xuXHRcdFx0XHRcdHB1c2hDb21wb25lbnRBcnJheSgpO1xuXHRcdFx0XHRcdHBvcyArPSAxO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCAoY2hyY3RyID09PSBcIi9cIikgJiYgKHN0ci5jaGFyQXQocG9zICsgMSkgPT09IFwiKlwiKSApIHtcblx0XHRcdFx0XHRpbkNvbW1lbnQgPSB0cnVlO1xuXHRcdFx0XHRcdHBvcyArPSAyO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29tcG9uZW50ID0gY29tcG9uZW50ICsgY2hyY3RyO1xuXHRcdFx0XHRwb3MgKz0gMTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc1ZhbGlkTm9uTmVnYXRpdmVTb3VyY2VTaXplVmFsdWUocykge1xuXHRcdFx0aWYgKHJlZ2V4Q3NzTGVuZ3RoV2l0aFVuaXRzLnRlc3QocykgJiYgKHBhcnNlRmxvYXQocykgPj0gMCkpIHtyZXR1cm4gdHJ1ZTt9XG5cdFx0XHRpZiAocmVnZXhDc3NDYWxjLnRlc3QocykpIHtyZXR1cm4gdHJ1ZTt9XG5cdFx0XHQvLyAoIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIvc3luZGF0YS5odG1sI251bWJlcnMgc2F5czpcblx0XHRcdC8vIFwiLTAgaXMgZXF1aXZhbGVudCB0byAwIGFuZCBpcyBub3QgYSBuZWdhdGl2ZSBudW1iZXIuXCIgd2hpY2ggbWVhbnMgdGhhdFxuXHRcdFx0Ly8gdW5pdGxlc3MgemVybyBhbmQgdW5pdGxlc3MgbmVnYXRpdmUgemVybyBtdXN0IGJlIGFjY2VwdGVkIGFzIHNwZWNpYWwgY2FzZXMuKVxuXHRcdFx0aWYgKChzID09PSBcIjBcIikgfHwgKHMgPT09IFwiLTBcIikgfHwgKHMgPT09IFwiKzBcIikpIHtyZXR1cm4gdHJ1ZTt9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiBhc2tlZCB0byBwYXJzZSBhIHNpemVzIGF0dHJpYnV0ZSBmcm9tIGFuIGVsZW1lbnQsIHBhcnNlIGFcblx0XHQvLyBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBjb21wb25lbnQgdmFsdWVzIGZyb20gdGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50J3Ncblx0XHQvLyBzaXplcyBhdHRyaWJ1dGUgKG9yIHRoZSBlbXB0eSBzdHJpbmcsIGlmIHRoZSBhdHRyaWJ1dGUgaXMgYWJzZW50KSwgYW5kIGxldFxuXHRcdC8vIHVucGFyc2VkIHNpemVzIGxpc3QgYmUgdGhlIHJlc3VsdC5cblx0XHQvLyBodHRwOi8vZGV2LnczLm9yZy9jc3N3Zy9jc3Mtc3ludGF4LyNwYXJzZS1jb21tYS1zZXBhcmF0ZWQtbGlzdC1vZi1jb21wb25lbnQtdmFsdWVzXG5cblx0XHR1bnBhcnNlZFNpemVzTGlzdCA9IHBhcnNlQ29tcG9uZW50VmFsdWVzKHN0clZhbHVlKTtcblx0XHR1bnBhcnNlZFNpemVzTGlzdExlbmd0aCA9IHVucGFyc2VkU2l6ZXNMaXN0Lmxlbmd0aDtcblxuXHRcdC8vIEZvciBlYWNoIHVucGFyc2VkIHNpemUgaW4gdW5wYXJzZWQgc2l6ZXMgbGlzdDpcblx0XHRmb3IgKGkgPSAwOyBpIDwgdW5wYXJzZWRTaXplc0xpc3RMZW5ndGg7IGkrKykge1xuXHRcdFx0dW5wYXJzZWRTaXplID0gdW5wYXJzZWRTaXplc0xpc3RbaV07XG5cblx0XHRcdC8vIDEuIFJlbW92ZSBhbGwgY29uc2VjdXRpdmUgPHdoaXRlc3BhY2UtdG9rZW4+cyBmcm9tIHRoZSBlbmQgb2YgdW5wYXJzZWQgc2l6ZS5cblx0XHRcdC8vICggcGFyc2VDb21wb25lbnRWYWx1ZXMoKSBhbHJlYWR5IG9taXRzIHNwYWNlcyBvdXRzaWRlIG9mIHBhcmVucy4gKVxuXG5cdFx0XHQvLyBJZiB1bnBhcnNlZCBzaXplIGlzIG5vdyBlbXB0eSwgdGhhdCBpcyBhIHBhcnNlIGVycm9yOyBjb250aW51ZSB0byB0aGUgbmV4dFxuXHRcdFx0Ly8gaXRlcmF0aW9uIG9mIHRoaXMgYWxnb3JpdGhtLlxuXHRcdFx0Ly8gKCBwYXJzZUNvbXBvbmVudFZhbHVlcygpIHdvbid0IHB1c2ggYW4gZW1wdHkgYXJyYXkuIClcblxuXHRcdFx0Ly8gMi4gSWYgdGhlIGxhc3QgY29tcG9uZW50IHZhbHVlIGluIHVucGFyc2VkIHNpemUgaXMgYSB2YWxpZCBub24tbmVnYXRpdmVcblx0XHRcdC8vIDxzb3VyY2Utc2l6ZS12YWx1ZT4sIGxldCBzaXplIGJlIGl0cyB2YWx1ZSBhbmQgcmVtb3ZlIHRoZSBjb21wb25lbnQgdmFsdWVcblx0XHRcdC8vIGZyb20gdW5wYXJzZWQgc2l6ZS4gQW55IENTUyBmdW5jdGlvbiBvdGhlciB0aGFuIHRoZSBjYWxjKCkgZnVuY3Rpb24gaXNcblx0XHRcdC8vIGludmFsaWQuIE90aGVyd2lzZSwgdGhlcmUgaXMgYSBwYXJzZSBlcnJvcjsgY29udGludWUgdG8gdGhlIG5leHQgaXRlcmF0aW9uXG5cdFx0XHQvLyBvZiB0aGlzIGFsZ29yaXRobS5cblx0XHRcdC8vIGh0dHA6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzcy1zeW50YXgvI3BhcnNlLWNvbXBvbmVudC12YWx1ZVxuXHRcdFx0bGFzdENvbXBvbmVudFZhbHVlID0gdW5wYXJzZWRTaXplW3VucGFyc2VkU2l6ZS5sZW5ndGggLSAxXTtcblxuXHRcdFx0aWYgKGlzVmFsaWROb25OZWdhdGl2ZVNvdXJjZVNpemVWYWx1ZShsYXN0Q29tcG9uZW50VmFsdWUpKSB7XG5cdFx0XHRcdHNpemUgPSBsYXN0Q29tcG9uZW50VmFsdWU7XG5cdFx0XHRcdHVucGFyc2VkU2l6ZS5wb3AoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyAzLiBSZW1vdmUgYWxsIGNvbnNlY3V0aXZlIDx3aGl0ZXNwYWNlLXRva2VuPnMgZnJvbSB0aGUgZW5kIG9mIHVucGFyc2VkXG5cdFx0XHQvLyBzaXplLiBJZiB1bnBhcnNlZCBzaXplIGlzIG5vdyBlbXB0eSwgcmV0dXJuIHNpemUgYW5kIGV4aXQgdGhpcyBhbGdvcml0aG0uXG5cdFx0XHQvLyBJZiB0aGlzIHdhcyBub3QgdGhlIGxhc3QgaXRlbSBpbiB1bnBhcnNlZCBzaXplcyBsaXN0LCB0aGF0IGlzIGEgcGFyc2UgZXJyb3IuXG5cdFx0XHRpZiAodW5wYXJzZWRTaXplLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gc2l6ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gNC4gUGFyc2UgdGhlIHJlbWFpbmluZyBjb21wb25lbnQgdmFsdWVzIGluIHVucGFyc2VkIHNpemUgYXMgYVxuXHRcdFx0Ly8gPG1lZGlhLWNvbmRpdGlvbj4uIElmIGl0IGRvZXMgbm90IHBhcnNlIGNvcnJlY3RseSwgb3IgaXQgZG9lcyBwYXJzZVxuXHRcdFx0Ly8gY29ycmVjdGx5IGJ1dCB0aGUgPG1lZGlhLWNvbmRpdGlvbj4gZXZhbHVhdGVzIHRvIGZhbHNlLCBjb250aW51ZSB0byB0aGVcblx0XHRcdC8vIG5leHQgaXRlcmF0aW9uIG9mIHRoaXMgYWxnb3JpdGhtLlxuXHRcdFx0Ly8gKFBhcnNpbmcgYWxsIHBvc3NpYmxlIGNvbXBvdW5kIG1lZGlhIGNvbmRpdGlvbnMgaW4gSlMgaXMgaGVhdnksIGNvbXBsaWNhdGVkLFxuXHRcdFx0Ly8gYW5kIHRoZSBwYXlvZmYgaXMgdW5jbGVhci4gSXMgdGhlcmUgZXZlciBhbiBzaXR1YXRpb24gd2hlcmUgdGhlXG5cdFx0XHQvLyBtZWRpYSBjb25kaXRpb24gcGFyc2VzIGluY29ycmVjdGx5IGJ1dCBzdGlsbCBzb21laG93IGV2YWx1YXRlcyB0byB0cnVlP1xuXHRcdFx0Ly8gQ2FuIHdlIGp1c3QgcmVseSBvbiB0aGUgYnJvd3Nlci9wb2x5ZmlsbCB0byBkbyBpdD8pXG5cdFx0XHR1bnBhcnNlZFNpemUgPSB1bnBhcnNlZFNpemUuam9pbihcIiBcIik7XG5cdFx0XHRpZiAoIShwZi5tYXRjaGVzTWVkaWEoIHVucGFyc2VkU2l6ZSApICkgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyA1LiBSZXR1cm4gc2l6ZSBhbmQgZXhpdCB0aGlzIGFsZ29yaXRobS5cblx0XHRcdHJldHVybiBzaXplO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZSBhYm92ZSBhbGdvcml0aG0gZXhoYXVzdHMgdW5wYXJzZWQgc2l6ZXMgbGlzdCB3aXRob3V0IHJldHVybmluZyBhXG5cdFx0Ly8gc2l6ZSB2YWx1ZSwgcmV0dXJuIDEwMHZ3LlxuXHRcdHJldHVybiBcIjEwMHZ3XCI7XG5cdH1cblxuXHQvLyBuYW1lc3BhY2Vcblx0cGYubnMgPSAoXCJwZlwiICsgbmV3IERhdGUoKS5nZXRUaW1lKCkpLnN1YnN0cigwLCA5KTtcblxuXHQvLyBzcmNzZXQgc3VwcG9ydCB0ZXN0XG5cdHBmLnN1cFNyY3NldCA9IFwic3Jjc2V0XCIgaW4gaW1hZ2U7XG5cdHBmLnN1cFNpemVzID0gXCJzaXplc1wiIGluIGltYWdlO1xuXHRwZi5zdXBQaWN0dXJlID0gISF3aW5kb3cuSFRNTFBpY3R1cmVFbGVtZW50O1xuXG5cdC8vIFVDIGJyb3dzZXIgZG9lcyBjbGFpbSB0byBzdXBwb3J0IHNyY3NldCBhbmQgcGljdHVyZSwgYnV0IG5vdCBzaXplcyxcblx0Ly8gdGhpcyBleHRlbmRlZCB0ZXN0IHJldmVhbHMgdGhlIGJyb3dzZXIgZG9lcyBzdXBwb3J0IG5vdGhpbmdcblx0aWYgKHBmLnN1cFNyY3NldCAmJiBwZi5zdXBQaWN0dXJlICYmICFwZi5zdXBTaXplcykge1xuXHRcdChmdW5jdGlvbihpbWFnZTIpIHtcblx0XHRcdGltYWdlLnNyY3NldCA9IFwiZGF0YTosYVwiO1xuXHRcdFx0aW1hZ2UyLnNyYyA9IFwiZGF0YTosYVwiO1xuXHRcdFx0cGYuc3VwU3Jjc2V0ID0gaW1hZ2UuY29tcGxldGUgPT09IGltYWdlMi5jb21wbGV0ZTtcblx0XHRcdHBmLnN1cFBpY3R1cmUgPSBwZi5zdXBTcmNzZXQgJiYgcGYuc3VwUGljdHVyZTtcblx0XHR9KShkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpKTtcblx0fVxuXG5cdC8vIFNhZmFyaTkgaGFzIGJhc2ljIHN1cHBvcnQgZm9yIHNpemVzLCBidXQgZG9lcyd0IGV4cG9zZSB0aGUgYHNpemVzYCBpZGwgYXR0cmlidXRlXG5cdGlmIChwZi5zdXBTcmNzZXQgJiYgIXBmLnN1cFNpemVzKSB7XG5cblx0XHQoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgd2lkdGgyID0gXCJkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBZ0FCQVBBQUFQLy8vd0FBQUNINUJBQUFBQUFBTEFBQUFBQUNBQUVBQUFJQ0JBb0FPdz09XCI7XG5cdFx0XHR2YXIgd2lkdGgxID0gXCJkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFBQUFDSDVCQUVLQUFFQUxBQUFBQUFCQUFFQUFBSUNUQUVBT3c9PVwiO1xuXHRcdFx0dmFyIGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG5cdFx0XHR2YXIgdGVzdCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgd2lkdGggPSBpbWcud2lkdGg7XG5cblx0XHRcdFx0aWYgKHdpZHRoID09PSAyKSB7XG5cdFx0XHRcdFx0cGYuc3VwU2l6ZXMgPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YWx3YXlzQ2hlY2tXRGVzY3JpcHRvciA9IHBmLnN1cFNyY3NldCAmJiAhcGYuc3VwU2l6ZXM7XG5cblx0XHRcdFx0aXNTdXBwb3J0VGVzdFJlYWR5ID0gdHJ1ZTtcblx0XHRcdFx0Ly8gZm9yY2UgYXN5bmNcblx0XHRcdFx0c2V0VGltZW91dChwaWN0dXJlZmlsbCk7XG5cdFx0XHR9O1xuXG5cdFx0XHRpbWcub25sb2FkID0gdGVzdDtcblx0XHRcdGltZy5vbmVycm9yID0gdGVzdDtcblx0XHRcdGltZy5zZXRBdHRyaWJ1dGUoXCJzaXplc1wiLCBcIjlweFwiKTtcblxuXHRcdFx0aW1nLnNyY3NldCA9IHdpZHRoMSArIFwiIDF3LFwiICsgd2lkdGgyICsgXCIgOXdcIjtcblx0XHRcdGltZy5zcmMgPSB3aWR0aDE7XG5cdFx0fSkoKTtcblxuXHR9IGVsc2Uge1xuXHRcdGlzU3VwcG9ydFRlc3RSZWFkeSA9IHRydWU7XG5cdH1cblxuXHQvLyB1c2luZyBwZi5xc2EgaW5zdGVhZCBvZiBkb20gdHJhdmVyc2luZyBkb2VzIHNjYWxlIG11Y2ggYmV0dGVyLFxuXHQvLyBlc3BlY2lhbGx5IG9uIHNpdGVzIG1peGluZyByZXNwb25zaXZlIGFuZCBub24tcmVzcG9uc2l2ZSBpbWFnZXNcblx0cGYuc2VsU2hvcnQgPSBcInBpY3R1cmU+aW1nLGltZ1tzcmNzZXRdXCI7XG5cdHBmLnNlbCA9IHBmLnNlbFNob3J0O1xuXHRwZi5jZmcgPSBjZmc7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHByb3BlcnR5IGZvciBgZGV2aWNlUGl4ZWxSYXRpb2AgKCBmb3IgZWFzeSBvdmVycmlkaW5nIGluIHRlc3RzIClcblx0ICovXG5cdHBmLkRQUiA9IChEUFIgIHx8IDEgKTtcblx0cGYudSA9IHVuaXRzO1xuXG5cdC8vIGNvbnRhaW5lciBvZiBzdXBwb3J0ZWQgbWltZSB0eXBlcyB0aGF0IG9uZSBtaWdodCBuZWVkIHRvIHF1YWxpZnkgYmVmb3JlIHVzaW5nXG5cdHBmLnR5cGVzID0gIHR5cGVzO1xuXG5cdHBmLnNldFNpemUgPSBub29wO1xuXG5cdC8qKlxuXHQgKiBHZXRzIGEgc3RyaW5nIGFuZCByZXR1cm5zIHRoZSBhYnNvbHV0ZSBVUkxcblx0ICogQHBhcmFtIHNyY1xuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBhYnNvbHV0ZSBVUkxcblx0ICovXG5cblx0cGYubWFrZVVybCA9IG1lbW9pemUoZnVuY3Rpb24oc3JjKSB7XG5cdFx0YW5jaG9yLmhyZWYgPSBzcmM7XG5cdFx0cmV0dXJuIGFuY2hvci5ocmVmO1xuXHR9KTtcblxuXHQvKipcblx0ICogR2V0cyBhIERPTSBlbGVtZW50IG9yIGRvY3VtZW50IGFuZCBhIHNlbGN0b3IgYW5kIHJldHVybnMgdGhlIGZvdW5kIG1hdGNoZXNcblx0ICogQ2FuIGJlIGV4dGVuZGVkIHdpdGggalF1ZXJ5L1NpenpsZSBmb3IgSUU3IHN1cHBvcnRcblx0ICogQHBhcmFtIGNvbnRleHRcblx0ICogQHBhcmFtIHNlbFxuXHQgKiBAcmV0dXJucyB7Tm9kZUxpc3R8QXJyYXl9XG5cdCAqL1xuXHRwZi5xc2EgPSBmdW5jdGlvbihjb250ZXh0LCBzZWwpIHtcblx0XHRyZXR1cm4gKCBcInF1ZXJ5U2VsZWN0b3JcIiBpbiBjb250ZXh0ICkgPyBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsKSA6IFtdO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCBtZXRob2QgZm9yIG1hdGNoTWVkaWEgKCBmb3IgZWFzeSBvdmVycmlkaW5nIGluIHRlc3RzIClcblx0ICogd2V0aGVyIG5hdGl2ZSBvciBwZi5tTVEgaXMgdXNlZCB3aWxsIGJlIGRlY2lkZWQgbGF6eSBvbiBmaXJzdCBjYWxsXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0cGYubWF0Y2hlc01lZGlhID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCB3aW5kb3cubWF0Y2hNZWRpYSAmJiAobWF0Y2hNZWRpYSggXCIobWluLXdpZHRoOiAwLjFlbSlcIiApIHx8IHt9KS5tYXRjaGVzICkge1xuXHRcdFx0cGYubWF0Y2hlc01lZGlhID0gZnVuY3Rpb24oIG1lZGlhICkge1xuXHRcdFx0XHRyZXR1cm4gIW1lZGlhIHx8ICggbWF0Y2hNZWRpYSggbWVkaWEgKS5tYXRjaGVzICk7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwZi5tYXRjaGVzTWVkaWEgPSBwZi5tTVE7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBmLm1hdGNoZXNNZWRpYS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxpZmllZCBtYXRjaE1lZGlhIGltcGxlbWVudGF0aW9uIGZvciBJRTggYW5kIElFOVxuXHQgKiBoYW5kbGVzIG9ubHkgbWluLXdpZHRoL21heC13aWR0aCB3aXRoIHB4IG9yIGVtIHZhbHVlc1xuXHQgKiBAcGFyYW0gbWVkaWFcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRwZi5tTVEgPSBmdW5jdGlvbiggbWVkaWEgKSB7XG5cdFx0cmV0dXJuIG1lZGlhID8gZXZhbENTUyhtZWRpYSkgOiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBjYWxjdWxhdGVkIGxlbmd0aCBpbiBjc3MgcGl4ZWwgZnJvbSB0aGUgZ2l2ZW4gc291cmNlU2l6ZVZhbHVlXG5cdCAqIGh0dHA6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzcy12YWx1ZXMtMy8jbGVuZ3RoLXZhbHVlXG5cdCAqIGludGVuZGVkIFNwZWMgbWlzbWF0Y2hlczpcblx0ICogKiBEb2VzIG5vdCBjaGVjayBmb3IgaW52YWxpZCB1c2Ugb2YgQ1NTIGZ1bmN0aW9uc1xuXHQgKiAqIERvZXMgaGFuZGxlIGEgY29tcHV0ZWQgbGVuZ3RoIG9mIDAgdGhlIHNhbWUgYXMgYSBuZWdhdGl2ZSBhbmQgdGhlcmVmb3JlIGludmFsaWQgdmFsdWVcblx0ICogQHBhcmFtIHNvdXJjZVNpemVWYWx1ZVxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfVxuXHQgKi9cblx0cGYuY2FsY0xlbmd0aCA9IGZ1bmN0aW9uKCBzb3VyY2VTaXplVmFsdWUgKSB7XG5cblx0XHR2YXIgdmFsdWUgPSBldmFsQ1NTKHNvdXJjZVNpemVWYWx1ZSwgdHJ1ZSkgfHwgZmFsc2U7XG5cdFx0aWYgKHZhbHVlIDwgMCkge1xuXHRcdFx0dmFsdWUgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRha2VzIGEgdHlwZSBzdHJpbmcgYW5kIGNoZWNrcyBpZiBpdHMgc3VwcG9ydGVkXG5cdCAqL1xuXG5cdHBmLnN1cHBvcnRzVHlwZSA9IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiAoIHR5cGUgKSA/IHR5cGVzWyB0eXBlIF0gOiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQYXJzZXMgYSBzb3VyY2VTaXplIGludG8gbWVkaWFDb25kaXRpb24gKG1lZGlhKSBhbmQgc291cmNlU2l6ZVZhbHVlIChsZW5ndGgpXG5cdCAqIEBwYXJhbSBzb3VyY2VTaXplU3RyXG5cdCAqIEByZXR1cm5zIHsqfVxuXHQgKi9cblx0cGYucGFyc2VTaXplID0gbWVtb2l6ZShmdW5jdGlvbiggc291cmNlU2l6ZVN0ciApIHtcblx0XHR2YXIgbWF0Y2ggPSAoIHNvdXJjZVNpemVTdHIgfHwgXCJcIiApLm1hdGNoKHJlZ1NpemUpO1xuXHRcdHJldHVybiB7XG5cdFx0XHRtZWRpYTogbWF0Y2ggJiYgbWF0Y2hbMV0sXG5cdFx0XHRsZW5ndGg6IG1hdGNoICYmIG1hdGNoWzJdXG5cdFx0fTtcblx0fSk7XG5cblx0cGYucGFyc2VTZXQgPSBmdW5jdGlvbiggc2V0ICkge1xuXHRcdGlmICggIXNldC5jYW5kcyApIHtcblx0XHRcdHNldC5jYW5kcyA9IHBhcnNlU3Jjc2V0KHNldC5zcmNzZXQsIHNldCk7XG5cdFx0fVxuXHRcdHJldHVybiBzZXQuY2FuZHM7XG5cdH07XG5cblx0LyoqXG5cdCAqIHJldHVybnMgMWVtIGluIGNzcyBweCBmb3IgaHRtbC9ib2R5IGRlZmF1bHQgc2l6ZVxuXHQgKiBmdW5jdGlvbiB0YWtlbiBmcm9tIHJlc3BvbmRqc1xuXHQgKiBAcmV0dXJucyB7KnxudW1iZXJ9XG5cdCAqL1xuXHRwZi5nZXRFbVZhbHVlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGJvZHk7XG5cdFx0aWYgKCAhZW1pbnB4ICYmIChib2R5ID0gZG9jdW1lbnQuYm9keSkgKSB7XG5cdFx0XHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLFxuXHRcdFx0XHRvcmlnaW5hbEhUTUxDU1MgPSBkb2NFbGVtLnN0eWxlLmNzc1RleHQsXG5cdFx0XHRcdG9yaWdpbmFsQm9keUNTUyA9IGJvZHkuc3R5bGUuY3NzVGV4dDtcblxuXHRcdFx0ZGl2LnN0eWxlLmNzc1RleHQgPSBiYXNlU3R5bGU7XG5cblx0XHRcdC8vIDFlbSBpbiBhIG1lZGlhIHF1ZXJ5IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZGVmYXVsdCBmb250IHNpemUgb2YgdGhlIGJyb3dzZXJcblx0XHRcdC8vIHJlc2V0IGRvY0VsZW0gYW5kIGJvZHkgdG8gZW5zdXJlIHRoZSBjb3JyZWN0IHZhbHVlIGlzIHJldHVybmVkXG5cdFx0XHRkb2NFbGVtLnN0eWxlLmNzc1RleHQgPSBmc0Nzcztcblx0XHRcdGJvZHkuc3R5bGUuY3NzVGV4dCA9IGZzQ3NzO1xuXG5cdFx0XHRib2R5LmFwcGVuZENoaWxkKCBkaXYgKTtcblx0XHRcdGVtaW5weCA9IGRpdi5vZmZzZXRXaWR0aDtcblx0XHRcdGJvZHkucmVtb3ZlQ2hpbGQoIGRpdiApO1xuXG5cdFx0XHQvL2Fsc28gdXBkYXRlIGVtaW5weCBiZWZvcmUgcmV0dXJuaW5nXG5cdFx0XHRlbWlucHggPSBwYXJzZUZsb2F0KCBlbWlucHgsIDEwICk7XG5cblx0XHRcdC8vIHJlc3RvcmUgdGhlIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0ZG9jRWxlbS5zdHlsZS5jc3NUZXh0ID0gb3JpZ2luYWxIVE1MQ1NTO1xuXHRcdFx0Ym9keS5zdHlsZS5jc3NUZXh0ID0gb3JpZ2luYWxCb2R5Q1NTO1xuXG5cdFx0fVxuXHRcdHJldHVybiBlbWlucHggfHwgMTY7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRha2VzIGEgc3RyaW5nIG9mIHNpemVzIGFuZCByZXR1cm5zIHRoZSB3aWR0aCBpbiBwaXhlbHMgYXMgYSBudW1iZXJcblx0ICovXG5cdHBmLmNhbGNMaXN0TGVuZ3RoID0gZnVuY3Rpb24oIHNvdXJjZVNpemVMaXN0U3RyICkge1xuXHRcdC8vIFNwbGl0IHVwIHNvdXJjZSBzaXplIGxpc3QsIGllICggbWF4LXdpZHRoOiAzMGVtICkgMTAwJSwgKCBtYXgtd2lkdGg6IDUwZW0gKSA1MCUsIDMzJVxuXHRcdC8vXG5cdFx0Ly8gICAgICAgICAgICAgICAgICAgICAgICAgICBvciAobWluLXdpZHRoOjMwZW0pIGNhbGMoMzAlIC0gMTVweClcblx0XHRpZiAoICEoc291cmNlU2l6ZUxpc3RTdHIgaW4gc2l6ZUxlbmd0aENhY2hlKSB8fCBjZmcudVQgKSB7XG5cdFx0XHR2YXIgd2lubmluZ0xlbmd0aCA9IHBmLmNhbGNMZW5ndGgoIHBhcnNlU2l6ZXMoIHNvdXJjZVNpemVMaXN0U3RyICkgKTtcblxuXHRcdFx0c2l6ZUxlbmd0aENhY2hlWyBzb3VyY2VTaXplTGlzdFN0ciBdID0gIXdpbm5pbmdMZW5ndGggPyB1bml0cy53aWR0aCA6IHdpbm5pbmdMZW5ndGg7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNpemVMZW5ndGhDYWNoZVsgc291cmNlU2l6ZUxpc3RTdHIgXTtcblx0fTtcblxuXHQvKipcblx0ICogVGFrZXMgYSBjYW5kaWRhdGUgb2JqZWN0IHdpdGggYSBzcmNzZXQgcHJvcGVydHkgaW4gdGhlIGZvcm0gb2YgdXJsL1xuXHQgKiBleC4gXCJpbWFnZXMvcGljLW1lZGl1bS5wbmcgMXgsIGltYWdlcy9waWMtbWVkaXVtLTJ4LnBuZyAyeFwiIG9yXG5cdCAqICAgICBcImltYWdlcy9waWMtbWVkaXVtLnBuZyA0MDB3LCBpbWFnZXMvcGljLW1lZGl1bS0yeC5wbmcgODAwd1wiIG9yXG5cdCAqICAgICBcImltYWdlcy9waWMtc21hbGwucG5nXCJcblx0ICogR2V0IGFuIGFycmF5IG9mIGltYWdlIGNhbmRpZGF0ZXMgaW4gdGhlIGZvcm0gb2Zcblx0ICogICAgICB7dXJsOiBcIi9mb28vYmFyLnBuZ1wiLCByZXNvbHV0aW9uOiAxfVxuXHQgKiB3aGVyZSByZXNvbHV0aW9uIGlzIGh0dHA6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzcy12YWx1ZXMtMy8jcmVzb2x1dGlvbi12YWx1ZVxuXHQgKiBJZiBzaXplcyBpcyBzcGVjaWZpZWQsIHJlcyBpcyBjYWxjdWxhdGVkXG5cdCAqL1xuXHRwZi5zZXRSZXMgPSBmdW5jdGlvbiggc2V0ICkge1xuXHRcdHZhciBjYW5kaWRhdGVzO1xuXHRcdGlmICggc2V0ICkge1xuXG5cdFx0XHRjYW5kaWRhdGVzID0gcGYucGFyc2VTZXQoIHNldCApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGxlbiA9IGNhbmRpZGF0ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdHNldFJlc29sdXRpb24oIGNhbmRpZGF0ZXNbIGkgXSwgc2V0LnNpemVzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjYW5kaWRhdGVzO1xuXHR9O1xuXG5cdHBmLnNldFJlcy5yZXMgPSBzZXRSZXNvbHV0aW9uO1xuXG5cdHBmLmFwcGx5U2V0Q2FuZGlkYXRlID0gZnVuY3Rpb24oIGNhbmRpZGF0ZXMsIGltZyApIHtcblx0XHRpZiAoICFjYW5kaWRhdGVzLmxlbmd0aCApIHtyZXR1cm47fVxuXHRcdHZhciBjYW5kaWRhdGUsXG5cdFx0XHRpLFxuXHRcdFx0aixcblx0XHRcdGxlbmd0aCxcblx0XHRcdGJlc3RDYW5kaWRhdGUsXG5cdFx0XHRjdXJTcmMsXG5cdFx0XHRjdXJDYW4sXG5cdFx0XHRjYW5kaWRhdGVTcmMsXG5cdFx0XHRhYm9ydEN1clNyYztcblxuXHRcdHZhciBpbWFnZURhdGEgPSBpbWdbIHBmLm5zIF07XG5cdFx0dmFyIGRwciA9IHBmLkRQUjtcblxuXHRcdGN1clNyYyA9IGltYWdlRGF0YS5jdXJTcmMgfHwgaW1nW2N1clNyY1Byb3BdO1xuXG5cdFx0Y3VyQ2FuID0gaW1hZ2VEYXRhLmN1ckNhbiB8fCBzZXRTcmNUb0N1cihpbWcsIGN1clNyYywgY2FuZGlkYXRlc1swXS5zZXQpO1xuXG5cdFx0Ly8gaWYgd2UgaGF2ZSBhIGN1cnJlbnQgc291cmNlLCB3ZSBtaWdodCBlaXRoZXIgYmVjb21lIGxhenkgb3IgZ2l2ZSB0aGlzIHNvdXJjZSBzb21lIGFkdmFudGFnZVxuXHRcdGlmICggY3VyQ2FuICYmIGN1ckNhbi5zZXQgPT09IGNhbmRpZGF0ZXNbIDAgXS5zZXQgKSB7XG5cblx0XHRcdC8vIGlmIGJyb3dzZXIgY2FuIGFib3J0IGltYWdlIHJlcXVlc3QgYW5kIHRoZSBpbWFnZSBoYXMgYSBoaWdoZXIgcGl4ZWwgZGVuc2l0eSB0aGFuIG5lZWRlZFxuXHRcdFx0Ly8gYW5kIHRoaXMgaW1hZ2UgaXNuJ3QgZG93bmxvYWRlZCB5ZXQsIHdlIHNraXAgbmV4dCBwYXJ0IGFuZCB0cnkgdG8gc2F2ZSBiYW5kd2lkdGhcblx0XHRcdGFib3J0Q3VyU3JjID0gKHN1cHBvcnRBYm9ydCAmJiAhaW1nLmNvbXBsZXRlICYmIGN1ckNhbi5yZXMgLSAwLjEgPiBkcHIpO1xuXG5cdFx0XHRpZiAoICFhYm9ydEN1clNyYyApIHtcblx0XHRcdFx0Y3VyQ2FuLmNhY2hlZCA9IHRydWU7XG5cblx0XHRcdFx0Ly8gaWYgY3VycmVudCBjYW5kaWRhdGUgaXMgXCJiZXN0XCIsIFwiYmV0dGVyXCIgb3IgXCJva2F5XCIsXG5cdFx0XHRcdC8vIHNldCBpdCB0byBiZXN0Q2FuZGlkYXRlXG5cdFx0XHRcdGlmICggY3VyQ2FuLnJlcyA+PSBkcHIgKSB7XG5cdFx0XHRcdFx0YmVzdENhbmRpZGF0ZSA9IGN1ckNhbjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIWJlc3RDYW5kaWRhdGUgKSB7XG5cblx0XHRcdGNhbmRpZGF0ZXMuc29ydCggYXNjZW5kaW5nU29ydCApO1xuXG5cdFx0XHRsZW5ndGggPSBjYW5kaWRhdGVzLmxlbmd0aDtcblx0XHRcdGJlc3RDYW5kaWRhdGUgPSBjYW5kaWRhdGVzWyBsZW5ndGggLSAxIF07XG5cblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGNhbmRpZGF0ZSA9IGNhbmRpZGF0ZXNbIGkgXTtcblx0XHRcdFx0aWYgKCBjYW5kaWRhdGUucmVzID49IGRwciApIHtcblx0XHRcdFx0XHRqID0gaSAtIDE7XG5cblx0XHRcdFx0XHQvLyB3ZSBoYXZlIGZvdW5kIHRoZSBwZXJmZWN0IGNhbmRpZGF0ZSxcblx0XHRcdFx0XHQvLyBidXQgbGV0J3MgaW1wcm92ZSB0aGlzIGEgbGl0dGxlIGJpdCB3aXRoIHNvbWUgYXNzdW1wdGlvbnMgOy0pXG5cdFx0XHRcdFx0aWYgKGNhbmRpZGF0ZXNbIGogXSAmJlxuXHRcdFx0XHRcdFx0KGFib3J0Q3VyU3JjIHx8IGN1clNyYyAhPT0gcGYubWFrZVVybCggY2FuZGlkYXRlLnVybCApKSAmJlxuXHRcdFx0XHRcdFx0Y2hvb3NlTG93UmVzKGNhbmRpZGF0ZXNbIGogXS5yZXMsIGNhbmRpZGF0ZS5yZXMsIGRwciwgY2FuZGlkYXRlc1sgaiBdLmNhY2hlZCkpIHtcblxuXHRcdFx0XHRcdFx0YmVzdENhbmRpZGF0ZSA9IGNhbmRpZGF0ZXNbIGogXTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRiZXN0Q2FuZGlkYXRlID0gY2FuZGlkYXRlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggYmVzdENhbmRpZGF0ZSApIHtcblxuXHRcdFx0Y2FuZGlkYXRlU3JjID0gcGYubWFrZVVybCggYmVzdENhbmRpZGF0ZS51cmwgKTtcblxuXHRcdFx0aW1hZ2VEYXRhLmN1clNyYyA9IGNhbmRpZGF0ZVNyYztcblx0XHRcdGltYWdlRGF0YS5jdXJDYW4gPSBiZXN0Q2FuZGlkYXRlO1xuXG5cdFx0XHRpZiAoIGNhbmRpZGF0ZVNyYyAhPT0gY3VyU3JjICkge1xuXHRcdFx0XHRwZi5zZXRTcmMoIGltZywgYmVzdENhbmRpZGF0ZSApO1xuXHRcdFx0fVxuXHRcdFx0cGYuc2V0U2l6ZSggaW1nICk7XG5cdFx0fVxuXHR9O1xuXG5cdHBmLnNldFNyYyA9IGZ1bmN0aW9uKCBpbWcsIGJlc3RDYW5kaWRhdGUgKSB7XG5cdFx0dmFyIG9yaWdXaWR0aDtcblx0XHRpbWcuc3JjID0gYmVzdENhbmRpZGF0ZS51cmw7XG5cblx0XHQvLyBhbHRob3VnaCB0aGlzIGlzIGEgc3BlY2lmaWMgU2FmYXJpIGlzc3VlLCB3ZSBkb24ndCB3YW50IHRvIHRha2UgdG9vIG11Y2ggZGlmZmVyZW50IGNvZGUgcGF0aHNcblx0XHRpZiAoIGJlc3RDYW5kaWRhdGUuc2V0LnR5cGUgPT09IFwiaW1hZ2Uvc3ZnK3htbFwiICkge1xuXHRcdFx0b3JpZ1dpZHRoID0gaW1nLnN0eWxlLndpZHRoO1xuXHRcdFx0aW1nLnN0eWxlLndpZHRoID0gKGltZy5vZmZzZXRXaWR0aCArIDEpICsgXCJweFwiO1xuXG5cdFx0XHQvLyBuZXh0IGxpbmUgb25seSBzaG91bGQgdHJpZ2dlciBhIHJlcGFpbnRcblx0XHRcdC8vIGlmLi4uIGlzIG9ubHkgZG9uZSB0byB0cmljayBkZWFkIGNvZGUgcmVtb3ZhbFxuXHRcdFx0aWYgKCBpbWcub2Zmc2V0V2lkdGggKyAxICkge1xuXHRcdFx0XHRpbWcuc3R5bGUud2lkdGggPSBvcmlnV2lkdGg7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdHBmLmdldFNldCA9IGZ1bmN0aW9uKCBpbWcgKSB7XG5cdFx0dmFyIGksIHNldCwgc3VwcG9ydHNUeXBlO1xuXHRcdHZhciBtYXRjaCA9IGZhbHNlO1xuXHRcdHZhciBzZXRzID0gaW1nIFsgcGYubnMgXS5zZXRzO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBzZXRzLmxlbmd0aCAmJiAhbWF0Y2g7IGkrKyApIHtcblx0XHRcdHNldCA9IHNldHNbaV07XG5cblx0XHRcdGlmICggIXNldC5zcmNzZXQgfHwgIXBmLm1hdGNoZXNNZWRpYSggc2V0Lm1lZGlhICkgfHwgIShzdXBwb3J0c1R5cGUgPSBwZi5zdXBwb3J0c1R5cGUoIHNldC50eXBlICkpICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzdXBwb3J0c1R5cGUgPT09IFwicGVuZGluZ1wiICkge1xuXHRcdFx0XHRzZXQgPSBzdXBwb3J0c1R5cGU7XG5cdFx0XHR9XG5cblx0XHRcdG1hdGNoID0gc2V0O1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoO1xuXHR9O1xuXG5cdHBmLnBhcnNlU2V0cyA9IGZ1bmN0aW9uKCBlbGVtZW50LCBwYXJlbnQsIG9wdGlvbnMgKSB7XG5cdFx0dmFyIHNyY3NldEF0dHJpYnV0ZSwgaW1hZ2VTZXQsIGlzV0Rlc2NyaXBvciwgc3Jjc2V0UGFyc2VkO1xuXG5cdFx0dmFyIGhhc1BpY3R1cmUgPSBwYXJlbnQgJiYgcGFyZW50Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09IFwiUElDVFVSRVwiO1xuXHRcdHZhciBpbWFnZURhdGEgPSBlbGVtZW50WyBwZi5ucyBdO1xuXG5cdFx0aWYgKCBpbWFnZURhdGEuc3JjID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5zcmMgKSB7XG5cdFx0XHRpbWFnZURhdGEuc3JjID0gZ2V0SW1nQXR0ci5jYWxsKCBlbGVtZW50LCBcInNyY1wiICk7XG5cdFx0XHRpZiAoIGltYWdlRGF0YS5zcmMgKSB7XG5cdFx0XHRcdHNldEltZ0F0dHIuY2FsbCggZWxlbWVudCwgc3JjQXR0ciwgaW1hZ2VEYXRhLnNyYyApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVtb3ZlSW1nQXR0ci5jYWxsKCBlbGVtZW50LCBzcmNBdHRyICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBpbWFnZURhdGEuc3Jjc2V0ID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5zcmNzZXQgfHwgIXBmLnN1cFNyY3NldCB8fCBlbGVtZW50LnNyY3NldCApIHtcblx0XHRcdHNyY3NldEF0dHJpYnV0ZSA9IGdldEltZ0F0dHIuY2FsbCggZWxlbWVudCwgXCJzcmNzZXRcIiApO1xuXHRcdFx0aW1hZ2VEYXRhLnNyY3NldCA9IHNyY3NldEF0dHJpYnV0ZTtcblx0XHRcdHNyY3NldFBhcnNlZCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aW1hZ2VEYXRhLnNldHMgPSBbXTtcblxuXHRcdGlmICggaGFzUGljdHVyZSApIHtcblx0XHRcdGltYWdlRGF0YS5waWMgPSB0cnVlO1xuXHRcdFx0Z2V0QWxsU291cmNlRWxlbWVudHMoIHBhcmVudCwgaW1hZ2VEYXRhLnNldHMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGltYWdlRGF0YS5zcmNzZXQgKSB7XG5cdFx0XHRpbWFnZVNldCA9IHtcblx0XHRcdFx0c3Jjc2V0OiBpbWFnZURhdGEuc3Jjc2V0LFxuXHRcdFx0XHRzaXplczogZ2V0SW1nQXR0ci5jYWxsKCBlbGVtZW50LCBcInNpemVzXCIgKVxuXHRcdFx0fTtcblxuXHRcdFx0aW1hZ2VEYXRhLnNldHMucHVzaCggaW1hZ2VTZXQgKTtcblxuXHRcdFx0aXNXRGVzY3JpcG9yID0gKGFsd2F5c0NoZWNrV0Rlc2NyaXB0b3IgfHwgaW1hZ2VEYXRhLnNyYykgJiYgcmVnV0Rlc2MudGVzdChpbWFnZURhdGEuc3Jjc2V0IHx8IFwiXCIpO1xuXG5cdFx0XHQvLyBhZGQgbm9ybWFsIHNyYyBhcyBjYW5kaWRhdGUsIGlmIHNvdXJjZSBoYXMgbm8gdyBkZXNjcmlwdG9yXG5cdFx0XHRpZiAoICFpc1dEZXNjcmlwb3IgJiYgaW1hZ2VEYXRhLnNyYyAmJiAhZ2V0Q2FuZGlkYXRlRm9yU3JjKGltYWdlRGF0YS5zcmMsIGltYWdlU2V0KSAmJiAhaW1hZ2VTZXQuaGFzMXggKSB7XG5cdFx0XHRcdGltYWdlU2V0LnNyY3NldCArPSBcIiwgXCIgKyBpbWFnZURhdGEuc3JjO1xuXHRcdFx0XHRpbWFnZVNldC5jYW5kcy5wdXNoKHtcblx0XHRcdFx0XHR1cmw6IGltYWdlRGF0YS5zcmMsXG5cdFx0XHRcdFx0ZDogMSxcblx0XHRcdFx0XHRzZXQ6IGltYWdlU2V0XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggaW1hZ2VEYXRhLnNyYyApIHtcblx0XHRcdGltYWdlRGF0YS5zZXRzLnB1c2goIHtcblx0XHRcdFx0c3Jjc2V0OiBpbWFnZURhdGEuc3JjLFxuXHRcdFx0XHRzaXplczogbnVsbFxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGltYWdlRGF0YS5jdXJDYW4gPSBudWxsO1xuXHRcdGltYWdlRGF0YS5jdXJTcmMgPSB1bmRlZmluZWQ7XG5cblx0XHQvLyBpZiBpbWcgaGFzIHBpY3R1cmUgb3IgdGhlIHNyY3NldCB3YXMgcmVtb3ZlZCBvciBoYXMgYSBzcmNzZXQgYW5kIGRvZXMgbm90IHN1cHBvcnQgc3Jjc2V0IGF0IGFsbFxuXHRcdC8vIG9yIGhhcyBhIHcgZGVzY3JpcHRvciAoYW5kIGRvZXMgbm90IHN1cHBvcnQgc2l6ZXMpIHNldCBzdXBwb3J0IHRvIGZhbHNlIHRvIGV2YWx1YXRlXG5cdFx0aW1hZ2VEYXRhLnN1cHBvcnRlZCA9ICEoIGhhc1BpY3R1cmUgfHwgKCBpbWFnZVNldCAmJiAhcGYuc3VwU3Jjc2V0ICkgfHwgKGlzV0Rlc2NyaXBvciAmJiAhcGYuc3VwU2l6ZXMpICk7XG5cblx0XHRpZiAoIHNyY3NldFBhcnNlZCAmJiBwZi5zdXBTcmNzZXQgJiYgIWltYWdlRGF0YS5zdXBwb3J0ZWQgKSB7XG5cdFx0XHRpZiAoIHNyY3NldEF0dHJpYnV0ZSApIHtcblx0XHRcdFx0c2V0SW1nQXR0ci5jYWxsKCBlbGVtZW50LCBzcmNzZXRBdHRyLCBzcmNzZXRBdHRyaWJ1dGUgKTtcblx0XHRcdFx0ZWxlbWVudC5zcmNzZXQgPSBcIlwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVtb3ZlSW1nQXR0ci5jYWxsKCBlbGVtZW50LCBzcmNzZXRBdHRyICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGltYWdlRGF0YS5zdXBwb3J0ZWQgJiYgIWltYWdlRGF0YS5zcmNzZXQgJiYgKCghaW1hZ2VEYXRhLnNyYyAmJiBlbGVtZW50LnNyYykgfHwgIGVsZW1lbnQuc3JjICE9PSBwZi5tYWtlVXJsKGltYWdlRGF0YS5zcmMpKSkge1xuXHRcdFx0aWYgKGltYWdlRGF0YS5zcmMgPT09IG51bGwpIHtcblx0XHRcdFx0ZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJzcmNcIik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtZW50LnNyYyA9IGltYWdlRGF0YS5zcmM7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aW1hZ2VEYXRhLnBhcnNlZCA9IHRydWU7XG5cdH07XG5cblx0cGYuZmlsbEltZyA9IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcblx0XHR2YXIgaW1hZ2VEYXRhO1xuXHRcdHZhciBleHRyZW1lID0gb3B0aW9ucy5yZXNlbGVjdCB8fCBvcHRpb25zLnJlZXZhbHVhdGU7XG5cblx0XHQvLyBleHBhbmRvIGZvciBjYWNoaW5nIGRhdGEgb24gdGhlIGltZ1xuXHRcdGlmICggIWVsZW1lbnRbIHBmLm5zIF0gKSB7XG5cdFx0XHRlbGVtZW50WyBwZi5ucyBdID0ge307XG5cdFx0fVxuXG5cdFx0aW1hZ2VEYXRhID0gZWxlbWVudFsgcGYubnMgXTtcblxuXHRcdC8vIGlmIHRoZSBlbGVtZW50IGhhcyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkLCBza2lwIGl0XG5cdFx0Ly8gdW5sZXNzIGBvcHRpb25zLnJlZXZhbHVhdGVgIGlzIHNldCB0byB0cnVlICggdGhpcywgZm9yIGV4YW1wbGUsXG5cdFx0Ly8gaXMgc2V0IHRvIHRydWUgd2hlbiBydW5uaW5nIGBwaWN0dXJlZmlsbGAgb24gYHJlc2l6ZWAgKS5cblx0XHRpZiAoICFleHRyZW1lICYmIGltYWdlRGF0YS5ldmFsZWQgPT09IGV2YWxJZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoICFpbWFnZURhdGEucGFyc2VkIHx8IG9wdGlvbnMucmVldmFsdWF0ZSApIHtcblx0XHRcdHBmLnBhcnNlU2V0cyggZWxlbWVudCwgZWxlbWVudC5wYXJlbnROb2RlLCBvcHRpb25zICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhaW1hZ2VEYXRhLnN1cHBvcnRlZCApIHtcblx0XHRcdGFwcGx5QmVzdENhbmRpZGF0ZSggZWxlbWVudCApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbWFnZURhdGEuZXZhbGVkID0gZXZhbElkO1xuXHRcdH1cblx0fTtcblxuXHRwZi5zZXR1cFJ1biA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggIWFscmVhZHlSdW4gfHwgaXNWd0RpcnR5IHx8IChEUFIgIT09IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKSApIHtcblx0XHRcdHVwZGF0ZU1ldHJpY3MoKTtcblx0XHR9XG5cdH07XG5cblx0Ly8gSWYgcGljdHVyZSBpcyBzdXBwb3J0ZWQsIHdlbGwsIHRoYXQncyBhd2Vzb21lLlxuXHRpZiAoIHBmLnN1cFBpY3R1cmUgKSB7XG5cdFx0cGljdHVyZWZpbGwgPSBub29wO1xuXHRcdHBmLmZpbGxJbWcgPSBub29wO1xuXHR9IGVsc2Uge1xuXG5cdFx0IC8vIFNldCB1cCBwaWN0dXJlIHBvbHlmaWxsIGJ5IHBvbGxpbmcgdGhlIGRvY3VtZW50XG5cdFx0KGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGlzRG9tUmVhZHk7XG5cdFx0XHR2YXIgcmVnUmVhZHkgPSB3aW5kb3cuYXR0YWNoRXZlbnQgPyAvZCR8XmMvIDogL2QkfF5jfF5pLztcblxuXHRcdFx0dmFyIHJ1biA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcmVhZHlTdGF0ZSA9IGRvY3VtZW50LnJlYWR5U3RhdGUgfHwgXCJcIjtcblxuXHRcdFx0XHR0aW1lcklkID0gc2V0VGltZW91dChydW4sIHJlYWR5U3RhdGUgPT09IFwibG9hZGluZ1wiID8gMjAwIDogIDk5OSk7XG5cdFx0XHRcdGlmICggZG9jdW1lbnQuYm9keSApIHtcblx0XHRcdFx0XHRwZi5maWxsSW1ncygpO1xuXHRcdFx0XHRcdGlzRG9tUmVhZHkgPSBpc0RvbVJlYWR5IHx8IHJlZ1JlYWR5LnRlc3QocmVhZHlTdGF0ZSk7XG5cdFx0XHRcdFx0aWYgKCBpc0RvbVJlYWR5ICkge1xuXHRcdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KCB0aW1lcklkICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdHZhciB0aW1lcklkID0gc2V0VGltZW91dChydW4sIGRvY3VtZW50LmJvZHkgPyA5IDogOTkpO1xuXG5cdFx0XHQvLyBBbHNvIGF0dGFjaCBwaWN0dXJlZmlsbCBvbiByZXNpemUgYW5kIHJlYWR5c3RhdGVjaGFuZ2Vcblx0XHRcdC8vIGh0dHA6Ly9tb2Rlcm5qYXZhc2NyaXB0LmJsb2dzcG90LmNvbS8yMDEzLzA4L2J1aWxkaW5nLWJldHRlci1kZWJvdW5jZS5odG1sXG5cdFx0XHR2YXIgZGVib3VuY2UgPSBmdW5jdGlvbihmdW5jLCB3YWl0KSB7XG5cdFx0XHRcdHZhciB0aW1lb3V0LCB0aW1lc3RhbXA7XG5cdFx0XHRcdHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBsYXN0ID0gKG5ldyBEYXRlKCkpIC0gdGltZXN0YW1wO1xuXG5cdFx0XHRcdFx0aWYgKGxhc3QgPCB3YWl0KSB7XG5cdFx0XHRcdFx0XHR0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCAtIGxhc3QpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aW1lb3V0ID0gbnVsbDtcblx0XHRcdFx0XHRcdGZ1bmMoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG5cblx0XHRcdFx0XHRpZiAoIXRpbWVvdXQpIHtcblx0XHRcdFx0XHRcdHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0dmFyIGxhc3RDbGllbnRXaWR0aCA9IGRvY0VsZW0uY2xpZW50SGVpZ2h0O1xuXHRcdFx0dmFyIG9uUmVzaXplID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlzVndEaXJ0eSA9IE1hdGgubWF4KHdpbmRvdy5pbm5lcldpZHRoIHx8IDAsIGRvY0VsZW0uY2xpZW50V2lkdGgpICE9PSB1bml0cy53aWR0aCB8fCBkb2NFbGVtLmNsaWVudEhlaWdodCAhPT0gbGFzdENsaWVudFdpZHRoO1xuXHRcdFx0XHRsYXN0Q2xpZW50V2lkdGggPSBkb2NFbGVtLmNsaWVudEhlaWdodDtcblx0XHRcdFx0aWYgKCBpc1Z3RGlydHkgKSB7XG5cdFx0XHRcdFx0cGYuZmlsbEltZ3MoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0b24oIHdpbmRvdywgXCJyZXNpemVcIiwgZGVib3VuY2Uob25SZXNpemUsIDk5ICkgKTtcblx0XHRcdG9uKCBkb2N1bWVudCwgXCJyZWFkeXN0YXRlY2hhbmdlXCIsIHJ1biApO1xuXHRcdH0pKCk7XG5cdH1cblxuXHRwZi5waWN0dXJlZmlsbCA9IHBpY3R1cmVmaWxsO1xuXHQvL3VzZSB0aGlzIGludGVybmFsbHkgZm9yIGVhc3kgbW9ua2V5IHBhdGNoaW5nL3BlcmZvcm1hbmNlIHRlc3Rpbmdcblx0cGYuZmlsbEltZ3MgPSBwaWN0dXJlZmlsbDtcblx0cGYudGVhcmRvd25SdW4gPSBub29wO1xuXG5cdC8qIGV4cG9zZSBtZXRob2RzIGZvciB0ZXN0aW5nICovXG5cdHBpY3R1cmVmaWxsLl8gPSBwZjtcblxuXHR3aW5kb3cucGljdHVyZWZpbGxDRkcgPSB7XG5cdFx0cGY6IHBmLFxuXHRcdHB1c2g6IGZ1bmN0aW9uKGFyZ3MpIHtcblx0XHRcdHZhciBuYW1lID0gYXJncy5zaGlmdCgpO1xuXHRcdFx0aWYgKHR5cGVvZiBwZltuYW1lXSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdHBmW25hbWVdLmFwcGx5KHBmLCBhcmdzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNmZ1tuYW1lXSA9IGFyZ3NbMF07XG5cdFx0XHRcdGlmIChhbHJlYWR5UnVuKSB7XG5cdFx0XHRcdFx0cGYuZmlsbEltZ3MoIHsgcmVzZWxlY3Q6IHRydWUgfSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdHdoaWxlIChzZXRPcHRpb25zICYmIHNldE9wdGlvbnMubGVuZ3RoKSB7XG5cdFx0d2luZG93LnBpY3R1cmVmaWxsQ0ZHLnB1c2goc2V0T3B0aW9ucy5zaGlmdCgpKTtcblx0fVxuXG5cdC8qIGV4cG9zZSBwaWN0dXJlZmlsbCAqL1xuXHR3aW5kb3cucGljdHVyZWZpbGwgPSBwaWN0dXJlZmlsbDtcblxuXHQvKiBleHBvc2UgcGljdHVyZWZpbGwgKi9cblx0aWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHQvLyBDb21tb25KUywganVzdCBleHBvcnRcblx0XHRtb2R1bGUuZXhwb3J0cyA9IHBpY3R1cmVmaWxsO1xuXHR9IGVsc2UgaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0XHQvLyBBTUQgc3VwcG9ydFxuXHRcdGRlZmluZSggXCJwaWN0dXJlZmlsbFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHBpY3R1cmVmaWxsOyB9ICk7XG5cdH1cblxuXHQvLyBJRTggZXZhbHMgdGhpcyBzeW5jLCBzbyBpdCBtdXN0IGJlIHRoZSBsYXN0IHRoaW5nIHdlIGRvXG5cdGlmICggIXBmLnN1cFBpY3R1cmUgKSB7XG5cdFx0dHlwZXNbIFwiaW1hZ2Uvd2VicFwiIF0gPSBkZXRlY3RUeXBlU3VwcG9ydChcImltYWdlL3dlYnBcIiwgXCJkYXRhOmltYWdlL3dlYnA7YmFzZTY0LFVrbEdSa29BQUFCWFJVSlFWbEE0V0FvQUFBQVFBQUFBQUFBQUFBQUFRVXhRU0F3QUFBQUJCeEFSL1E5RVJQOERBQUJXVURnZ0dBQUFBREFCQUowQktnRUFBUUFEQURRbHBBQURjQUQrKy8xUUFBPT1cIiApO1xuXHR9XG5cbn0gKSggd2luZG93LCBkb2N1bWVudCApO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/picturefill/dist/picturefill.js\n");

/***/ }),

/***/ "./node_modules/tiny-emitter/index.js":
/*!********************************************!*\
  !*** ./node_modules/tiny-emitter/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function E () {\n  // Keep this empty so it's easier to inherit from\n  // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)\n}\n\nE.prototype = {\n  on: function (name, callback, ctx) {\n    var e = this.e || (this.e = {});\n\n    (e[name] || (e[name] = [])).push({\n      fn: callback,\n      ctx: ctx\n    });\n\n    return this;\n  },\n\n  once: function (name, callback, ctx) {\n    var self = this;\n    function listener () {\n      self.off(name, listener);\n      callback.apply(ctx, arguments);\n    };\n\n    listener._ = callback\n    return this.on(name, listener, ctx);\n  },\n\n  emit: function (name) {\n    var data = [].slice.call(arguments, 1);\n    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();\n    var i = 0;\n    var len = evtArr.length;\n\n    for (i; i < len; i++) {\n      evtArr[i].fn.apply(evtArr[i].ctx, data);\n    }\n\n    return this;\n  },\n\n  off: function (name, callback) {\n    var e = this.e || (this.e = {});\n    var evts = e[name];\n    var liveEvents = [];\n\n    if (evts && callback) {\n      for (var i = 0, len = evts.length; i < len; i++) {\n        if (evts[i].fn !== callback && evts[i].fn._ !== callback)\n          liveEvents.push(evts[i]);\n      }\n    }\n\n    // Remove event from queue to prevent memory leak\n    // Suggested by https://github.com/lazd\n    // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910\n\n    (liveEvents.length)\n      ? e[name] = liveEvents\n      : delete e[name];\n\n    return this;\n  }\n};\n\nmodule.exports = E;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGlueS1lbWl0dGVyL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RpbnktZW1pdHRlci9pbmRleC5qcz9jMGUyIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIEUgKCkge1xuICAvLyBLZWVwIHRoaXMgZW1wdHkgc28gaXQncyBlYXNpZXIgdG8gaW5oZXJpdCBmcm9tXG4gIC8vICh2aWEgaHR0cHM6Ly9naXRodWIuY29tL2xpcHNtYWNrIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3Njb3R0Y29yZ2FuL3RpbnktZW1pdHRlci9pc3N1ZXMvMylcbn1cblxuRS5wcm90b3R5cGUgPSB7XG4gIG9uOiBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2ssIGN0eCkge1xuICAgIHZhciBlID0gdGhpcy5lIHx8ICh0aGlzLmUgPSB7fSk7XG5cbiAgICAoZVtuYW1lXSB8fCAoZVtuYW1lXSA9IFtdKSkucHVzaCh7XG4gICAgICBmbjogY2FsbGJhY2ssXG4gICAgICBjdHg6IGN0eFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgb25jZTogZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrLCBjdHgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgZnVuY3Rpb24gbGlzdGVuZXIgKCkge1xuICAgICAgc2VsZi5vZmYobmFtZSwgbGlzdGVuZXIpO1xuICAgICAgY2FsbGJhY2suYXBwbHkoY3R4LCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBsaXN0ZW5lci5fID0gY2FsbGJhY2tcbiAgICByZXR1cm4gdGhpcy5vbihuYW1lLCBsaXN0ZW5lciwgY3R4KTtcbiAgfSxcblxuICBlbWl0OiBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBkYXRhID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHZhciBldnRBcnIgPSAoKHRoaXMuZSB8fCAodGhpcy5lID0ge30pKVtuYW1lXSB8fCBbXSkuc2xpY2UoKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IGV2dEFyci5sZW5ndGg7XG5cbiAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xuICAgICAgZXZ0QXJyW2ldLmZuLmFwcGx5KGV2dEFycltpXS5jdHgsIGRhdGEpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIG9mZjogZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGUgPSB0aGlzLmUgfHwgKHRoaXMuZSA9IHt9KTtcbiAgICB2YXIgZXZ0cyA9IGVbbmFtZV07XG4gICAgdmFyIGxpdmVFdmVudHMgPSBbXTtcblxuICAgIGlmIChldnRzICYmIGNhbGxiYWNrKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZXZ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoZXZ0c1tpXS5mbiAhPT0gY2FsbGJhY2sgJiYgZXZ0c1tpXS5mbi5fICE9PSBjYWxsYmFjaylcbiAgICAgICAgICBsaXZlRXZlbnRzLnB1c2goZXZ0c1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGV2ZW50IGZyb20gcXVldWUgdG8gcHJldmVudCBtZW1vcnkgbGVha1xuICAgIC8vIFN1Z2dlc3RlZCBieSBodHRwczovL2dpdGh1Yi5jb20vbGF6ZFxuICAgIC8vIFJlZjogaHR0cHM6Ly9naXRodWIuY29tL3Njb3R0Y29yZ2FuL3RpbnktZW1pdHRlci9jb21taXQvYzZlYmZhYTliYzk3M2IzM2QxMTBhODRhMzA3NzQyYjdjZjk0Yzk1MyNjb21taXRjb21tZW50LTUwMjQ5MTBcblxuICAgIChsaXZlRXZlbnRzLmxlbmd0aClcbiAgICAgID8gZVtuYW1lXSA9IGxpdmVFdmVudHNcbiAgICAgIDogZGVsZXRlIGVbbmFtZV07XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tiny-emitter/index.js\n");

/***/ }),

/***/ "./src/app/index.js":
/*!**************************!*\
  !*** ./src/app/index.js ***!
  \**************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _styles_main_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../styles/main.scss */ \"./src/styles/main.scss\");\n/* harmony import */ var _styles_main_scss__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_styles_main_scss__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _odopod_odo_responsive_images__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @odopod/odo-responsive-images */ \"./node_modules/@odopod/odo-responsive-images/dist/odo-responsive-images.esm.js\");\n/* harmony import */ var _odopod_odo_carousel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @odopod/odo-carousel */ \"./node_modules/@odopod/odo-carousel/dist/odo-carousel.esm.js\");\n/* harmony import */ var _modules_card_carousel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modules/card-carousel */ \"./src/app/modules/card-carousel.js\");\n\n\n\n\n\n\n_odopod_odo_responsive_images__WEBPACK_IMPORTED_MODULE_1__[\"default\"].initialize();\n_modules_card_carousel__WEBPACK_IMPORTED_MODULE_3__[\"default\"].initializeAll();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBwL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9hcHAvaW5kZXguanM/NmZjNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJy4uL3N0eWxlcy9tYWluLnNjc3MnO1xuXG5pbXBvcnQgT2RvUmVzcG9uc2l2ZUltYWdlcyBmcm9tICdAb2RvcG9kL29kby1yZXNwb25zaXZlLWltYWdlcyc7XG5pbXBvcnQgT2RvQ2Fyb3VzZWwgZnJvbSAnQG9kb3BvZC9vZG8tY2Fyb3VzZWwnO1xuaW1wb3J0IENhcmRDYXJvdXNlbCBmcm9tICcuL21vZHVsZXMvY2FyZC1jYXJvdXNlbCdcblxuT2RvUmVzcG9uc2l2ZUltYWdlcy5pbml0aWFsaXplKCk7XG5DYXJkQ2Fyb3VzZWwuaW5pdGlhbGl6ZUFsbCgpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/app/index.js\n");

/***/ }),

/***/ "./src/app/modules/card-carousel.js":
/*!******************************************!*\
  !*** ./src/app/modules/card-carousel.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _odopod_odo_carousel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @odopod/odo-carousel */ \"./node_modules/@odopod/odo-carousel/dist/odo-carousel.esm.js\");\n/* harmony import */ var _carousel_slide__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./carousel-slide */ \"./src/app/modules/carousel-slide.js\");\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\n\nvar SETTINGS = {\n  ClassName: {\n    BASE: 'card-carousel',\n    SLIDE: 'card-carousel__slide'\n  }\n};\n\nvar CardCarousel = function () {\n  function CardCarousel(base) {\n    _classCallCheck(this, CardCarousel);\n\n    this.base = base;\n\n    this.carousel = new _odopod_odo_carousel__WEBPACK_IMPORTED_MODULE_0__[\"default\"](base);\n\n    this.slideEls = this.base.querySelectorAll('.' + SETTINGS.ClassName.SLIDE);\n\n    this.slides = Array.from(this.slideEls).map(function (el) {\n      return new _carousel_slide__WEBPACK_IMPORTED_MODULE_1__[\"default\"](el);\n    });\n  }\n\n  _createClass(CardCarousel, null, [{\n    key: 'initializeAll',\n    value: function initializeAll() {\n      var modules = document.querySelectorAll('.' + SETTINGS.ClassName.BASE);\n      return Array.from(modules).map(function (el) {\n        return new CardCarousel(el);\n      });\n    }\n  }]);\n\n  return CardCarousel;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (CardCarousel);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBwL21vZHVsZXMvY2FyZC1jYXJvdXNlbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvYXBwL21vZHVsZXMvY2FyZC1jYXJvdXNlbC5qcz84NzA2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBPZG9DYXJvdXNlbCBmcm9tICdAb2RvcG9kL29kby1jYXJvdXNlbCc7XG5pbXBvcnQgU2xpZGUgZnJvbSAnLi9jYXJvdXNlbC1zbGlkZSc7XG5cbmNvbnN0IFNFVFRJTkdTID0ge1xuICBDbGFzc05hbWU6IHtcbiAgICBCQVNFOiAnY2FyZC1jYXJvdXNlbCcsXG4gICAgU0xJREU6ICdjYXJkLWNhcm91c2VsX19zbGlkZSdcbiAgfVxufTtcblxuY2xhc3MgQ2FyZENhcm91c2VsIHtcbiAgY29uc3RydWN0b3IoYmFzZSkge1xuICAgIHRoaXMuYmFzZSA9IGJhc2U7XG5cbiAgICB0aGlzLmNhcm91c2VsID0gbmV3IE9kb0Nhcm91c2VsKGJhc2UpO1xuXG4gICAgdGhpcy5zbGlkZUVscyA9IHRoaXMuYmFzZS5xdWVyeVNlbGVjdG9yQWxsKGAuJHtTRVRUSU5HUy5DbGFzc05hbWUuU0xJREV9YCk7XG5cbiAgICB0aGlzLnNsaWRlcyA9IEFycmF5LmZyb20odGhpcy5zbGlkZUVscykubWFwKGVsID0+IG5ldyBTbGlkZShlbCkpO1xuICB9XG5cbiAgc3RhdGljIGluaXRpYWxpemVBbGwoKSB7XG4gICAgY29uc3QgbW9kdWxlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke1NFVFRJTkdTLkNsYXNzTmFtZS5CQVNFfWApO1xuICAgIHJldHVybiBBcnJheS5mcm9tKG1vZHVsZXMpLm1hcChlbCA9PiBuZXcgQ2FyZENhcm91c2VsKGVsKSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2FyZENhcm91c2VsO1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBQ0E7QUFNQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7Ozs7O0FBR0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/app/modules/card-carousel.js\n");

/***/ }),

/***/ "./src/app/modules/carousel-slide.js":
/*!*******************************************!*\
  !*** ./src/app/modules/carousel-slide.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _odopod_odo_dialog__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @odopod/odo-dialog */ \"./node_modules/@odopod/odo-dialog/dist/odo-dialog.esm.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\nvar SETTINGS = {\n  ClassName: {\n    DIALOG: 'card-carousel__dialog'\n  }\n};\n\nvar Slide = function Slide(base) {\n  _classCallCheck(this, Slide);\n\n  this.base = base;\n\n  this.dialogEl = document.querySelector('.' + SETTINGS.ClassName.DIALOG);\n\n  this.dialog = new _odopod_odo_dialog__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.dialogEl);\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Slide);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBwL21vZHVsZXMvY2Fyb3VzZWwtc2xpZGUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2FwcC9tb2R1bGVzL2Nhcm91c2VsLXNsaWRlLmpzP2IwNGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE9kb0RpYWxvZyBmcm9tICdAb2RvcG9kL29kby1kaWFsb2cnO1xuXG5jb25zdCBTRVRUSU5HUyA9IHtcbiAgQ2xhc3NOYW1lOiB7XG4gICAgRElBTE9HOiAnY2FyZC1jYXJvdXNlbF9fZGlhbG9nJ1xuICB9XG59O1xuXG5jbGFzcyBTbGlkZSB7XG4gIGNvbnN0cnVjdG9yKGJhc2UpIHtcbiAgICB0aGlzLmJhc2UgPSBiYXNlO1xuXG4gICAgdGhpcy5kaWFsb2dFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYC4ke1NFVFRJTkdTLkNsYXNzTmFtZS5ESUFMT0d9YCk7XG5cbiAgICB0aGlzLmRpYWxvZyA9IG5ldyBPZG9EaWFsb2codGhpcy5kaWFsb2dFbCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2xpZGU7XG4iXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/app/modules/carousel-slide.js\n");

/***/ }),

/***/ "./src/styles/main.scss":
/*!******************************!*\
  !*** ./src/styles/main.scss ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc3R5bGVzL21haW4uc2Nzcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9zdHlsZXMvbWFpbi5zY3NzPzYyMmQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/styles/main.scss\n");

/***/ })

/******/ });